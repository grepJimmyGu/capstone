created_utc,id,title,author,ups,downs,num_comments,selftext,subreddit_id,is_self
1268071466.0,bargt,"You win. CarlHProgramming (HigherComputingForEveryone) will be entirely free, powered by donations and non-obstructive ads. No one will have to pay, but in exchange for this *please* help me to spread this, and help to make this a success :)",CarlH,42,,False
1300902512.0,g9uua,[CarlHProgramming] I am still here!,CarlH,359,44,38,"Reading the most recent posts I can see there is a lot of concern for my welfare

I don't make it a point to submit posts here to this subreddit very often because I don't want to clog up everyone's homepage. Nonetheless,False,,t5_2r81y,False,,,t3_g9uua
1269595254.0,bihvd,CarlHProgramming Update : HigherComputingForEveryone.Com Online!,CarlH,254,14,66,"Hello Everyone

While it is still very much in the construction phase, but will be soon.

My goal is going to be to operate this without fees, and following that, I will be expanding on the course.

Thank you everyone for all of your support,,False,,t5_2r81y,True,,True
1267856549.0,b9xhr,"I am back! CarlHProgramming to resume starting this weekend. However, please read:",CarlH,246,18,http://www.reddit.com/r/carlhprogramming/comments/b9xhr/i_am_back_carlhprogramming_to_resume_starting/

Now

I did *not* remotely expect or anticipate the level of interest and support that this subreddit has generated. There are over 5

How many of you would be seriously willing to spend a small monthly fee (around $5-$10) for these lessons? To be clear, but to expand this. 

If there is enough interest, creating high-def videos, hiring people to create demonstrations, animations, etc. The sky is the limit based on the interest. 

So

1 : I am going to leave this as a hobby

or

2 : If you take this seriously, transform this from a simple sub-reddit into something that I hope will truly be able to make a difference for thousands of people who want to learn programming.

It's your call :) Either way

**Edit: Regarding Donations**

Thank you to everyone who has offered donations. I do not want to diminish this generosity in any way.

The problem with donations is that they are unpredictable, there were (let's say) only 100 people each paying $10.00/month, that would be $1,000/month in steady revenue. 

A history of even a small amount of steady revenue can be used to hire people, with a steady revenue I can devote my focus to this fully. 

My intention is to create something which would truly be exceptional, for various languages, with example programs, internet-based conference sessions, professionally made animations to demonstrate concepts, etc. I would also like to put time into helping those who complete the lessons to find jobs.

If I go forward with this as more than a hobby, and stopping other significant projects in favor of doing this. 

Either way, but it all depends on everyone here. 

----

TLDR: I am considering taking this to a much higher level

Please post your thoughts in this thread. ",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/b9xhr/i_am_back_carlhprogramming_to_resume_starting/
1278245386.0,cluqu,[CarlHProgramming] Update: No more donations. Content still free.,CarlH,247,23,45,"First

The monthly overhead for the higher computing website is quite small. Small enough I can pay for it without needing donations. I want this to simply be a free resource intended to help people learn

I have therefore removed the ability to donate from the website. All content will remain free.
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/cluqu/carlhprogramming_update_no_more_donations_content/
1288961030.0,e1o19,CarlHProgramming Update,CarlH,255,31,38,"Life has been incredibly hectic, my family

I *will* be continuing this course at some point, and continue to provide for free), thousands of people have been able to gain an enjoyment from and perhaps even a love of programming and higher computing. That far surpasses any goals I had for this project, which started out with the simple goal to help maybe a dozen or so people learn the basics of programming.

I have received many positive and encouraging messages from people who have gotten their first programming job

Besides the direct impact that this has had, and many other similar projects were started. I love to see that, and I love to think that I had a small part in helping that happen. 

I will continue this,,False,,t5_2r81y,True,,True
1310717849.0,iq92w,[CarlHProgramming] New lessons soon!,CarlH,224,19,35,"Hello everyone

The good news is

Now

Reddit unfortunately archives posts older than a certain time

Unfortunately

Edit: farfaraway suggested I install Disqus on the website. Done. 

That is all I can say for now

Thank you to everyone for your continued interest and support.
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/iq92w/carlhprogramming_new_lessons_soon/
1253901470.0,9o3km,Lesson 1 : Some thoughts about programming language tutorials and books.,CarlH,728,540,101,"Here is lesson one. I think it is important for everyone to know this

Here I am going to briefly discuss the difference between knowing a programming language

----
Most programming tutorials focus on how to do the most basic programming instructions like if, and while statements. All of the focus is on *how* a particular language does these things. Every programming language has this functionality, they all do it in their own unique way.

Very rarely do any of these tutorials explain beyond this. As a result, and then finally displaying some text output to the screen. 

This is what virtually every book you will buy at Barnes and Noble will give you the ability to do. For this reason

**What is the missing link?**

Libraries. These are the TOOLS you need as a programmer to actually make things. In short

This is how advanced applications and games are built. These libraries themselves are put together and packaged for programmers to use

We will be spending a great deal of time working with these types of libraries to build real

----
Feel free to post any questions or comments.

When you have finished this lesson

http://www.reddit.com/r/carlhprogramming/comments/9o8ey/lesson_2_c_c_python_ruby_perl_a_language_for/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9o3km/lesson_1_some_thoughts_about_programming_language/
1258340672.0,a4qi1,Important update regarding new lessons on /r/carlhprogramming,CarlH,199,16,32,"A few of you have asked when the next lessons will be published. I realize that especially because I am providing these lessons for free

I want everyone to know first of all that I am not abandoning this. I have every intention of publishing many more lessons

As I am sure all of you can appreciate

Besides having the time to write new lessons

As soon as the situation becomes less hectic

Meanwhile, and help out by answering questions asked by others in earlier lessons. Even though I am not publishing lessons for the time being, I am still here and I will answer questions as I am able. Also, remember that the only way to truly learn programming is by writing programs. If you haven't, take the time to apply what you have learned by writing your own simple programs.

I want to close by saying that I greatly appreciate all of the messages I have received regarding this course

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/a4qi1/important_update_regarding_new_lessons_on/
1253941987.0,9o8ey,"Lesson 2 : C, C++, Python, Ruby, Perl... A language for every day of the year.. but why? Which one is best?",693,"This is bound to be a question foremost on a lot of people's minds from beginners on up. There is a lot of depth to this question
----
As strange as it sounds, are designed to be understood only by humans, not computers. Even assembly language is written to be understood only by humans. There is only one language that your computer understands, the language of 1s and 0s. 

**The need for programming languages.**

The magic of computing is that sequences of 1s and 0s flowing non stop inside of your computer make everything happen. Everything. However

The first fundamental principle of programming I want you to learn is this: Programming languages exist in order to make it possible to do a great many operations (think trillions) with very few instructions.

The second principle I want you to learn is related: Good programmers figure out ways to do complex tasks

For example, any where, to draw circles. Thankfully, you will never have to worry about that.

If you want to design a game for example, or create weapons, enemies, etc. All of this work has been done FOR YOU by all those who have come before since the dawn of computing. 

Just about everything you can imagine is already out there. Everything from making windows appear on your screen, to libraries that play movies -- everything. All you have to do is learn how to obtain and use these and you will be able to produce just about anything.

**Why are there so many languages?**

In the end, you are likely to find some languages suit you better than others. 

**Which language is best?**

There is no ""best"" language. Every language is a tool designed to be useful in certain situations

The more popular a language becomes

1. Support. It is a lot easier to find help for more popular languages because there are more people using it. This means more tutorials, etc.
2. Libraries. The more people use a language

In general

There are many other considerations to this which we will be going over later on
----
Please ask questions if you need to. It is important that everyone understands everything written here.

When you have finished this

http://www.reddit.com/r/carlhprogramming/comments/9oabt/lesson_3_010011111010_err_i_mean_1274_computers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9o8ey/lesson_2_c_c_python_ruby_perl_a_language_for/
1253960935.0,9oabt,"Lesson 3 : 010011111010; Err.. I mean: 1,274. Computers count differently than we do. Lets explore that.",CarlH,619,441,http://www.reddit.com/r/carlhprogramming/comments/9oabt/lesson_3_010011111010_err_i_mean_1274_computers/, this will not be the only lesson I do on this subject

Go through this slowly

**Please remember this for all lessons:**

This course is designed so that you can go as slow as you need to. Do not worry about falling behind, and that is fine. There is no need to rush to ""catch up"". *Take your time.*

----
**How humans count**

When we count, 2, 3, 4, 5, 6, 7, 9 -- and then ""ten"". Why ten? Well

For example

17, 20, 21, 22

and

4:57, 5:00, 5:01

The general rule to remember is this: When one column is FULL

18, so it becomes zero. The column next to it (the ""tens"" column) increments by one to become 2.

**How computers count**

Remember that inside a computer everything is represented as 1s and 0s. A sequence of 1s and 0s is actually a number, a column is full once it reaches 9. In base 60 a column is full once it reaches 59. Well, in base 2 (binary, 1s and 0s), a column is full once it reaches ONE. 

So

Ok, so it must become zero, and the column over to the left must now become a 1. So:

0

ten? No. Two. Don't be confused. 10 all your life has meant ""ten""

Lets talk about the number 35 (thirty-five). It really means: 3 in the tens column, hundreds, thousands, etc. 

In base 2 (binary), 2, 4, 8, 16, etc.

For example, and a 1 in the fours place, and a 0 in the eights place. Therefore, the number is ""four"". 

So lets go back to counting in binary:

0, we go to the next column)
then: 11 (three), 110 (six), 111 (seven).

Now

999 + 1

1000

Three columns are full

111 + 1

1000

A thousand? No - eight. There is a one in the eights place
----
It is very important that everyone masters this. Please feel free to ask any questions.

When you have finished this

http://www.reddit.com/r/carlhprogramming/comments/9oba7/lesson_4_alright_now_i_can_count_in_binary_other/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oabt/lesson_3_010011111010_err_i_mean_1274_computers/
1256347500.0,9x7lb,A message to everyone regarding /r/carlhprogramming,CarlH,193,18,48,"I just wanted to write a quick note to everyone that there won't be any new Lessons until Monday. I am not going to have time to publish new lessons until then. 

I will still be around to answer questions. Also

Anyone who has at least 5 years of professional C experience who wishes to be a moderator, I can use all the help I can get.

I am glad that these lessons are helping everyone

There is much
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9x7lb/a_message_to_everyone_regarding_rcarlhprogramming/
1349301601.0,10wdy9,[CarlHProgramming] A fun idea.. Who wants me to do this?,CarlH,182,18,51,"I was thinking about a weekly/bi-weekly video I could put together where I basically write a program from start to finish based on a request (voted on perhaps)? 

Now obviously we are not talking about 10+ hour projects here

There are a lot of programming challenge websites/subreddits/etc. which I thought could provide the material. 

If you would like to see me do this,False,,t5_2r81y,1349304744.0,,,t3_10wdy9
1253874308.0,9nz5s,Welcome Everyone. Some Details.,CarlH,627,487,177,"Some notes about this course:

This course is for all levels of skill from total beginner on up. I plan to have much to offer advanced programmers as well. Including how to take the knowledge of programming learned from books/courses and apply it to making *real* programs, etc.

**Please remember this for all lessons:**

This course is designed so that you can go as slow as you need to. Do not worry about falling behind, and that is fine. There is no need to rush to ""catch up"". *Take your time.*

Proceed through each lesson slowly

Feel free to introduce yourselves and tell a bit about your backgrounds especially concerning past programming experience.  This will help me plan this out as everyone has different starting points.

----
**Links to all lessons

(Please let me know if any of these links do not work.)

[Lesson 1 : Some thoughts about programming languages](http://www.reddit.com/r/carlhprogramming/comments/9o3km/lesson_1_some_thoughts_about_programming_language/)

[Lesson 2 : About the many programming languages available ](http://www.reddit.com/r/carlhprogramming/comments/9o8ey/lesson_2_c_c_python_ruby_perl_a_language_for/)

[Lesson 3 : How to count like a computer](http://www.reddit.com/r/carlhprogramming/comments/9oabt/lesson_3_010011111010_err_i_mean_1274_computers/)

[Lesson 4 : Practical applications of binary](http://www.reddit.com/r/carlhprogramming/comments/9oba7/lesson_4_alright_now_i_can_count_in_binary_other/)

[Lesson 5 : About starting a career in programming](http://www.reddit.com/r/carlhprogramming/comments/9ocjz/lesson_5_how_to_begin_a_career_in_programming/)

[Lesson 6 : More about counting like a computer](http://www.reddit.com/r/carlhprogramming/comments/9oet6/lesson_6_more_about_counting_like_a_computer/)

[Lesson 7 : Include statements](http://www.reddit.com/r/carlhprogramming/comments/9ohlu/lesson_7_include_statements/)

[Lesson 8 : How programming languages work with data](http://www.reddit.com/r/carlhprogramming/comments/9ohx4/lesson_8_how_programming_languages_work_with_data/)

[Lesson 9 : Some basics about RAM](http://www.reddit.com/r/carlhprogramming/comments/9oi16/lesson_9_some_basics_about_ram/)

[Lesson 10 : Programs are data too](http://www.reddit.com/r/carlhprogramming/comments/9oi96/lesson_10_programs_are_data_too/)

[Lesson 11 : More about program flow](http://www.reddit.com/r/carlhprogramming/comments/9ok6s/lesson_11_more_about_program_flow/)

[Lesson 12 : The basics concerning functions](http://www.reddit.com/r/carlhprogramming/comments/9oknd/lesson_12_the_basics_of_functions_methods/)

[Lesson 13 : About parameters and return values](http://www.reddit.com/r/carlhprogramming/comments/9olf8/lesson_13_about_parameters_and_return_values/)

[Lesson 14 : About syntax and function vocabulary](http://www.reddit.com/r/carlhprogramming/comments/9olme/lesson_14_about_syntax_and_function_vocabulary/)

[Lesson 15 : Your first program!](http://www.reddit.com/r/carlhprogramming/comments/9olx4/lesson_15_your_first_program/)

[Lesson 16 : Let's go over your first program.](http://www.reddit.com/r/carlhprogramming/comments/9oqxp/lesson_16_lets_go_over_your_first_program/)

[Lesson 17 : Run your first program.](http://www.reddit.com/r/carlhprogramming/comments/9or2s/lesson_17_run_your_first_program/)

[Lesson 18 : The basics of signed and unsigned numbers](http://www.reddit.com/r/carlhprogramming/comments/9os31/lesson_18_the_basics_of_signed_and_unsigned/)

[Lesson 19 : The basics of numeric overflow](http://www.reddit.com/r/carlhprogramming/comments/9osdw/lesson_19_basics_of_numeric_overflow/)

[Lesson 20 : The basics of fractional numbers in binary.](http://www.reddit.com/r/carlhprogramming/comments/9ouzt/lesson_20_basics_of_fractional_numbers_in_binary/)

[Lesson 21 : The basics of numeric data types in c](http://www.reddit.com/r/carlhprogramming/comments/9ovi4/lesson_21_the_basics_of_numeric_data_types_in_c/)

[Lesson 22 : The char data type and the basics of ASCII](http://www.reddit.com/r/carlhprogramming/comments/9ow85/lesson_22_the_char_data_type_and_the_basics_of/)

[Lesson 23 : The numbers on your keyboard as characters](http://www.reddit.com/r/carlhprogramming/comments/9owj2/lesson_23_the_numbers_on_your_keyboard_as/)

[Lesson 24 : About maximum values for unsigned integers](http://www.reddit.com/r/carlhprogramming/comments/9p4h2/lesson_24_about_maximum_values_for_unsigned/)

[Lesson 25 : Minimum and maximum values of signed integers](http://www.reddit.com/r/carlhprogramming/comments/9p61e/lesson_25_minimum_and_maximum_values_of_signed/)

[Lesson 26 : Introducing variables](http://www.reddit.com/r/carlhprogramming/comments/9p6me/lesson_26_introducing_variables/)

[Lesson 27 : The connection between function return values and variables.](http://www.reddit.com/r/carlhprogramming/comments/9p71a/lesson_27_the_connection_between_function_return/)

[Lesson 28 : About terminating strings of text and other data](http://www.reddit.com/r/carlhprogramming/comments/9p7yd/lesson_28_about_terminating_strings_of_text_and/)

[Lesson 29 : More about printf() and introduction to place holders.](http://www.reddit.com/r/carlhprogramming/comments/9pa83/lesson_29_more_about_printf_and_introduction_to/)

[Lesson 30 : Introducing arrays and pointers part one](http://www.reddit.com/r/carlhprogramming/comments/9pfgk/lesson_30_introducing_arrays_and_pointers_part_one/)

[Lesson 31 : Introducing arrays and pointers part two](http://www.reddit.com/r/carlhprogramming/comments/9pfuj/lesson_31_introducing_arrays_and_pointers_part_two/)

[Lesson 32 : Introducing the pointer data type](http://www.reddit.com/r/carlhprogramming/comments/9pgmv/lesson_32_introducing_the_pointer_data_type/)

[Lesson 33 : How to create a pointer](http://www.reddit.com/r/carlhprogramming/comments/9pimr/lesson_33_how_to_create_a_pointer/)

[Lesson 34 : Assigning a value to a pointer](http://www.reddit.com/r/carlhprogramming/comments/9pkde/lesson_34_assigning_a_value_to_a_pointer/)

[Lesson 35 : Getting the value that was stored at a memory address](http://www.reddit.com/r/carlhprogramming/comments/9plo8/lesson_35_getting_the_value_that_was_stored_at_a/)

[Lesson 36 : Use what you have learned.](http://www.reddit.com/r/carlhprogramming/comments/9pn3c/lesson_36_use_what_you_have_learned/)

[Lesson 37 : Using pointers for directly manipulating data in memory.](http://www.reddit.com/r/carlhprogramming/comments/9pu1h/lesson_37_using_pointers_for_directly/)

[Lesson 38 : About changing the memory address stored in a pointer](http://www.reddit.com/r/carlhprogramming/comments/9pv6q/lesson_38_about_changing_the_memory_address/)

[Lesson 39 : About pointers concerning multi-byte variables](http://www.reddit.com/r/carlhprogramming/comments/9pwqs/lesson_39_about_pointers_concerning_multibyte/)

[Lesson 40 : Pointers have memory address too.](http://www.reddit.com/r/carlhprogramming/comments/9py2s/lesson_40_pointers_have_memory_addresses_too/)

[Lesson 41 : Why do I need to know pointers?](http://www.reddit.com/r/carlhprogramming/comments/9pyom/lesson_41_why_do_i_need_to_know_pointers/)

[Lesson 42 : Introducing the char* pointer](http://www.reddit.com/r/carlhprogramming/comments/9q01u/lesson_42_introducing_the_char_pointer/)

[Lesson 43 : Introducing the constant.](http://www.reddit.com/r/carlhprogramming/comments/9q0mg/lesson_43_introducing_the_constant/)

[Lesson 44 : Important review and clarification of prior lessons.](http://www.reddit.com/r/carlhprogramming/comments/9q543/lesson_44_important_review_and_clarification_of/)

[Lesson 45 : More about strings and constants.](http://www.reddit.com/r/carlhprogramming/comments/9q5t9/lesson_45_more_about_strings_and_constants/)

[Lesson 46 : A new way to visualize memory.](http://www.reddit.com/r/carlhprogramming/comments/9q7fs/lesson_46_a_new_way_to_visualize_memory/)

[Lesson 47 : Introducing the character string as an array.](http://www.reddit.com/r/carlhprogramming/comments/9q80s/lesson_47_introducing_the_character_string_as_an/)

[Lesson 48 : Using pointers to manipulate character arrays.](http://www.reddit.com/r/carlhprogramming/comments/9qask/lesson_48_using_pointers_to_manipulate_character/)

[Lesson 49 : Introducing conditional flow statements.](http://www.reddit.com/r/carlhprogramming/comments/9qfha/lesson_49_introducing_conditional_flow_statements/)

[Lesson 50 : More on conditional flow statements](http://www.reddit.com/r/carlhprogramming/comments/9qk90
/lesson_50_more_on_conditional_flow_statements/)

[Lesson 51 : Introducing OR for conditional flow statements](http://www.reddit.com/r/carlhprogramming/comments/9qoze/lesson_51_introducing_or_for_conditional_flow/)

[Lesson 52 : Introducing the ""goto"" statement.](http://www.reddit.com/r/carlhprogramming/comments/9qpv3/lesson_52_introducing_the_goto_statement/)

[Lesson 53 : About blocks of code](http://www.reddit.com/r/carlhprogramming/comments/9qqc8/lesson_53_about_blocks_of_code/)

[Lesson 54 : Introducing Loops](http://www.reddit.com/r/carlhprogramming/comments/9qr1h/lesson_54_introducing_loops/)

[Lesson 55 : Introducing custom functions](http://www.reddit.com/r/carlhprogramming/comments/9qrj2/lesson_55_introducing_custom_functions/)

[Lesson 56 : Introducing Boolean logic](http://www.reddit.com/r/carlhprogramming/comments/9qs1f/lesson_56_introducing_boolean_logic/)

Reddit has a limit on the maximum size of a post

Soon I will set up a post for ""overflow"".",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9nz5s/welcome_everyone_some_details/
1253971166.0,9oba7,"Lesson 4 : Alright now I can count in binary! Other than to impress my girlfriend (or scare her away), why do I have to know this?",CarlH,531,393,http://www.reddit.com/r/carlhprogramming/comments/9oba7/lesson_4_alright_now_i_can_count_in_binary_other/

However

**Working with data formats**

It is important to understand that *everything* in your computer is encoded in binary. Everything that is encoded in binary (movies

In .bmp image files for example

&lt;2 bytes&gt; &lt;4 bytes&gt; ... and so on.

The first set of 2 bytes identify the format of the BMP file (Windows

Why is it important to know binary in this case? You need to be able to state the size of the file - in binary. 

Many format specifications you will encounter require knowledge of binary in order to write programs that can produce or read that type of data. Well designed data format specifications often use binary values in various ways. This is especially true any time within the format that some quantity has to be known. Almost all such quantities are represented in binary.

**Flags**

The next reason you should know binary involves understanding something called ""flags"". Flags are representations in binary of several true/false states of something. Lets say for example you are designing a game

You can do this with a single byte! Eight bits. Each position can represent a given weapon. 1 = yes you have it

0100 = (0 in the ""plasma cannon"" place, and 0 in the ""knife"" place).

Adding a weapon to inventory

You will run into flags often especially with data formats

There are many other applications as well
----
Please feel free to ask any questions and ensure you have mastered the material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9ocjz/lesson_5_how_to_begin_a_career_in_programming/

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oba7/lesson_4_alright_now_i_can_count_in_binary_other/
1262617460.0,aled1,Quick Update on carlhprogramming,CarlH,154,15,46,"Hi Everyone

For right now the posting schedule is going to be slow. I am still working on a number of projects which need to be finished sooner rather than later. Once they are completed

I just want everyone to know that I am still here, I have no intentions to stop producing lessons or to stop maintaining this subreddit. 

Meanwhile,,False,,t5_2r81y,False,,True
1254003514.0,9oet6,Lesson 6 : More about counting like a computer.,CarlH,370,234,190,"In lesson 3

I realise some of this material may be difficult at first. Take your time
----
First, to movies, etc.

Now, instead of writing: 01100011 we would write: 0110 0011

Why is that? It simply makes it easier to read. Compare: 011111000001 to: 0111 1100 0001. Now we need to illustrate how to convert from binary to normal base-ten

&gt; 0000 : 0

&gt; 0001 : 1 (since there is a 1 in the ones place)

&gt; 0010 : 2 (since there is a 1 in the twos place)

&gt; 0011 : 3 (1 in two

&gt; 0100 : 4 (1 in four's place)

&gt; 0101 : 5 (1 in four

&gt; 0110 : 6 (1 in four

&gt; 0111 : 7 (1 in four

&gt; 1000 : 8 (1 in eight's place)

&gt; 1001 : 9 (1 in eight

Now what? We have used all our available digits from zero to nine. In base ten, and so on. You will see why soon.

&gt; 1010 : A (1 in eight

&gt; 1011 : B (1 in eight

&gt; 1100 : C (1 in eight

&gt; 1101 : D (1 in eight

&gt; 1110 : E (1 in eight

&gt; 1111 : F (1 in eight, 1 in one = 8+4+2+1 = 15)

Examine only the column of this table containing the letters A through F. Now, If we are at 9, what is the next number? The answer is ""10"" which means that the first column becomes 0, and the column next to it becomes 1.

So, look at our above sequence - we went: 13, 14, 15 -- what comes next? sixteen! It is a curious fact that ""10"" (a one and a zero) means whatever base you are counting in. In base binary, 10 means two. In base ten, 10 means ten. In base sixteen, 10 means sixteen. And so on.

Therefore, or ""hexadecimal"" is extremely useful because you can represent ANY binary sequence using hexadecimal. 

Lets keep counting so you can see that demonstrated:

&gt; 0000 1111 : F (1 in eight, 1 in one = 8+4+2+1 = 15)

&gt; 0001 0000 : 10 (not G

Look at the binary of this. If we go 1, 8, 16 - then you will see clearly there is a 1 in the sixteen's place. Also, you will notice from the the above table that 0001 corresponds to 1, and 0000 corresponds to 0. It turns out that you can *ALWAYS* represent four binary digits with exactly one hexadecimal digit. 

For example

0110 : six (6)

1010 : ten (A)

0011 : three (3) 

Therefore

Now lets do it the other way around. How can you convert 5F1 from hexadecimal to binary? Well

Therefore

----
Please feel free to ask any questions

http://www.reddit.com/r/carlhprogramming/comments/9ohlu/lesson_7_include_statements/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oet6/lesson_6_more_about_counting_like_a_computer/
1254041405.0,9ohx4,Lesson 8 : How programming languages work with data.,CarlH,282,151,30,"There are many types of data, etc) to very complex data structures that could encode something like graphics or sound. All programming languages have built in mechanisms for understanding how to deal with the different types of data you will use.

Remember that all data, or music is all going to be encoded in the same way. Binary. When you look inside your computer at the binary, you will not be able to tell the difference between one data type and another. 

How can you know for example if: 0111 1110 is referring to a number

For example, you need to tell the program that the type of data you expect to work with are numbers.

Each programming language has slightly different ways of doing this

For example

Many languages will understand numbers by just typing them out. Just simply typing 5 will be enough that the programming language knows you mean the number five. 

----
Please feel free to ask any questions and make sure you master this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9oi16/lesson_9_some_basics_about_ram/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ohx4/lesson_8_how_programming_languages_work_with_data/
1276505470.0,ceqx8,"I need your help. After editing 120+ lessons, I am sure there are mistakes. Please help me to find them. [CarlHProgramming]",CarlH,138,9,http://www.reddit.com/r/carlhprogramming/comments/ceqx8/i_need_your_help_after_editing_120_lessons_i_am/

If you find examples that will not compile, please let me know. Also, please track your progress in the comments so I/others can see them and we can avoid doing the same work multiple times.

Thank you everyone for your help and support on this project.

",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/ceqx8/i_need_your_help_after_editing_120_lessons_i_am/
1268040785.0,balak,"Introducing our new home: www.highercomputingforeveryone.com -- Also, about your host.",CarlH,144,13,http://www.reddit.com/r/carlhprogramming/comments/balak/introducing_our_new_home/, etc. Maybe about a week..) 

First

My real name is Carl Herold. I am 29 years old, a company that I am still involved in.

Feel free to ask me any questions

----

Now

My goal here is not merely to create a programming class, web design, system administration, databases, and anything else that comes up. 

My goal is to popularize higher computing to a large mass of people including many who thought they could never be programmers. There are many people who would start their own businesses but can't simply because they do not know how to put their ideas into reality. There are many people who want to learn these skills but cannot because they cannot afford it.

For everyone, I am not looking to squeeze someone's last dollar. Therefore:

**If you cannot afford $9.00/month, and I do not wish to leave anyone out. **

(Note: $6.00/mo for age 21 and under

Meanwhile

**Edit: Change of plans. Everything will stay free. **",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/balak/introducing_our_new_home/
1253982039.0,9ocjz,Lesson 5 : How to begin a career in programming.,CarlH,443,315,104,"Before we continue to the next lesson

If you listen to half the people commenting on this subject

If you are planning to take the first job that comes along, this is as true for programmers as it is true for engineers or any field which involves building something as part of your job.

You must be patient, and set high standards for yourself. 

If you set low standards for yourself

**How do you get a job without a college education?**

Credentials, that is not a company you want to work with.

Many companies understand this, or similar wording. 

I find that a self taught programmer who has actually built stuff is a far better fit for a programming position than a college graduate who has only the knowledge they gained from college. Many companies feel the same and this situation is getting better and better for the self-taught programmer. All of that said

**With so many jobs outsourced

If all you know is html

You *must* build skills that go above and beyond the basics

No company wants to send their trade secrets to some third world country

----
Feel free to ask me any questions about this. 

When you are ready to proceed

http://www.reddit.com/r/carlhprogramming/comments/9oet6/lesson_6_more_about_counting_like_a_computer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ocjz/lesson_5_how_to_begin_a_career_in_programming/
1254042871.0,9oi16,Lesson 9 : Some basics about RAM.,CarlH,284,155,59,"Unlike data stored on disk

When you run a program on your computer, the contents of that document can be loaded into your ram and then the program can manipulate the document as you edit it. 

When you are satisfied

If you have four gigabytes of ram, and for making sure that RAM in use by one program cannot be used by another until it is done.

Every one of those sequences of eight 1s and 0s has an address. The addresses start at 0 and work their way up to four billion. The exact way this is done is more complex

You as the programmer will need to store data at an address in ram, I have to first retrieve it from ram. That means I have to know where it was put, or what address it has.

It would be quite tedious if I had to remember some enormous number as an address in memory every time I needed to store something. This leads us to the next role a programming language has. Programming languages have functionality that keeps track of these addresses for us

Here is a sample of this in action. I tell my programming language to store the string of text ""Hello Reddit"" in memory somewhere. I have no way to know where. Then

Later, and actually printing the string of text ""Hello Reddit"". 

Notice that the programming language is really keeping track of two things. First

----
Please feel free to ask any questions and make sure you master this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9oi96/lesson_10_programs_are_data_too/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oi16/lesson_9_some_basics_about_ram/
1254037422.0,9ohlu,Lesson 7 : Include statements.,CarlH,296,168,31,"I know many of you are anxious to begin writing your first program, and you will be programming in no time.

----

There is certain functionality that is shared by all languages. Some of this functionality is critical to understand even before you write your first line of real code.

Lets imagine you are trying to achieve some task inside a program you are writing, here just include this code inside your program."" This of course happens a lot.

There are really several ways you can do this. You could copy and paste the code right into your program. This can create issues because your program could become too long and difficult to understand. Just imagine how complicated it would be if you had to cut-and-paste lets say ten such files into your code. Also

For this reason

In general it works like this:

    include somefile.blah

As soon as you put that line in any of your programs

This is important for many reasons. First

Which is easier

Remember that programmers are always looking for ways to make things easier

Include statements were developed so that with a single line of code

----

Addendum: It is worth pointing out that the functionality I just described differs between programming languages. Some programming languages use the ""Include"" statements as a replacement for actually copy-pasting the entire contents of that file. Other languages use ""Include"" statements as a way to simply make functions found in the file available in the program you are writing. 

The main thing that you need to understand however is that the *purpose* of using an ""Include"" statement in any language is to enable you to be able to use functions and commands that are available in the file you are including. For example, then you can draw the circle.

In this way

----
Please feel free to ask any questions and make sure you have mastered this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9ohx4/lesson_8_how_programming_languages_work_with_data/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ohlu/lesson_7_include_statements/
1260806950.0,aejhf,Resuming New Lessons,CarlH,132,12,41,"I know it has been a longer than usual delay

I know many of you have asked questions in threads and to me personally. I have had very little time to respond to those questions,False,,t5_2r81y,False,,,t3_aejhf
1375187711.0,1jcevb,[CarlHProgramming] Cross post from University of Reddit: Anyone interested in me live-streaming how to create from scratch a real world web application that actually generates income?,CarlH,134,16,16,,t5_2r81y,False
1276323581.0,ce6zk,Major CarlHProgramming Update: 06/12/2010,CarlH,129,12,12,"Finally. It took me over 3 months and a lot of hours

This was not just a matter of copy-pasting 127 lessons. It meant creating server-side programs and a proper database to store and index them, descriptions, and more. I also had to develop a back-end management system to make it possible for me to publish/edit lessons easily, as well as a system capable of automatically storing, indexing, and publishing new lessons. 

It has been quite a project. However

All of the lessons are now organized by unit

Therefore

1. I need to go through all published lessons, and I need to double check that none are missing/no bad links etc. **Completely Finished!**

2. As soon as that is done

----


**All lessons  are now fully edited,False,,t5_2r81y,True,,,t3_ce6zk
1341430006.0,w1l8u,[CarlHProgramming/HCFE] : Important update for everyone,CarlH,132,12,23,"Hello everyone

When I started these classes in 2009
willing to continue providing these lessons for free as long as possible. It was something that I was doing outside of my normal work that I greatly enjoyed. 

These courses gained a *lot* of popularity and visibility very quickly and at the time
focus.

Therefore

I am going to be resuming these lessons starting this month
the lessons already published so I get a feel for where things are. And then I am going to start publishing new lessons. 

Secondly, and it doesn't have to be a 
lot. I will not charge for the lessons

1. I am going to add advertising
2. I am going to re-add a ""donations"" link for those individuals who wish to compensate me for the lessons. Of course

Thank you everyone for your support,,False,,t5_2r81y,1341430756.0,,True
1254828615.0,9ramx,You can now vote on posts and comments in the carlhprogramming subreddit.,CarlH,127,10,12,"Reddit hasn't yet fixed the bugs concerning restricted subreddits

Please keep in mind the following: 

1. A lot of your comments are at 0 votes. This is not because anyone downvoted you. This is because of the voting bugs on Reddit. 
2. Anything you have voted for (comment or submission) was ignored by Reddit
3. Even though I moved from restricted to public

Remember that this sub-reddit is only for me to post lessons. If you have a useful submission that will benefit others trying to learn
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ramx/you_can_now_vote_on_posts_and_comments_in_the/
1254082424.0,9olx4,Lesson 15 : Your first program!,CarlH,247,131,299,"It is time to write your first program.

I am going to explain to you what the program is

The goal is to create a program that will print the text ""Hello Reddit!"" to the screen. 

The language we will be doing this in is called C. Here are the rules for C you need to know in order to make this program.

* We will be using a library that comes packaged with C. This library is called the ""Standard Input/Output"" library.
* To use the functions in this library

      #include &lt;filename.blah&gt;

Note that the greater than and less than sign are part of the instruction. They must also be present.

* I mentioned some programming languages require you to create a function in order to write a program. C is one such language. Therefore

For your main() function in C

    int main(void) {
        .... any code goes here ...
    }

The word ""`int`"" at the start simply means ""integer"". It specifies that the main() function will return some number as an indicator of whether or not it was successful. The ""void"" within the parentheses just means that you are not sending any arguments to the function. In other words

* ALL code for the main() function must be between the opening ""{"" and the closing ""}""
* The function in the ""Standard Input/Output"" library we are going to be using is called printf. This function takes a single argument
* You call a function in C by simply putting the function name along with any arguments within parenthesis. At the end

    example_function(""A text argument"");

You may find during this course that I sometimes refer to the extra information you send to functions as parameters

* At the end of the main() program in C

    return 0;

Edit: Originally I had this saying return 1, 0 is best. Ironically, for functions it is usually the opposite. We will get to that later.

The number you return from a main() function identifies whether or not the program was successful. 

You now have everything you need in order to write this first program in C. Try to do it yourself

Note about Reddit formatting:

To format properly
----
Please feel free to ask any questions. When you have mastered this material proceed to:

http://www.reddit.com/r/carlhprogramming/comments/9oqxp/lesson_16_lets_go_over_your_first_program/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9olx4/lesson_15_your_first_program/
1342260569.0,wjmls,"[CarlHProgramming] Over 20 new videos published including some entirely new lessons (on binary), and more to come!",CarlH,131,16,http://www.reddit.com/r/carlhprogramming/comments/wjmls/carlhprogramming_over_20_new_videos_published/

So on July 4th I officially announced the return of CarlHProgramming and Higher Computing for Everyone. In those 10 days

There are now over 20 video lessons covering every lesson from 1.1 through 6.1 -- almost half of the first course. Also I have been going through lessons updating and editing them.

In the coming days I will be adding more video lessons until every existing lesson has both a text and video version. After that

[A youtube playlist of all currently uploaded lessons is available here

If you want to help support this project

Questions and comments are welcome.

----

Edit: All lessons through 7.2 now available as video",,t5_2r81y,1342305187.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/wjmls/carlhprogramming_over_20_new_videos_published/
1267965821.0,baabh,"Future plans for carlhprogramming. Please read, and post your thoughts.",CarlH,130,14,http://www.reddit.com/r/carlhprogramming/comments/baabh/future_plans_for_carlhprogramming_please_read_and/

I believe based on the replies I have seen that obtaining at least 100 paying members is entirely doable

I would appreciate everyone's thoughts on my ideas. 

----

** 1. Pay Structure **

My goal is to structure this in such a way that those who pay are rewarded for being paying members

So first of all

1. Anyone under the age of 18 / anyone still in high school gets full access to all material free of charge.

2. Anyone under the age of 22 gets full access to all materials for $6.00/month. 

3. For anyone not in groups 1 or 2

And that leaves the ""Free"" plan which will work the following way:

1. Access to text lessons will be available. 
2. Personalized help/grading from me will be limited.
3. No access to videos/demos/animations/etc.
4. Instant access to next lesson not available. 

To clarify #4: For anyone who is paying or in a free/reduced price plan based on age

Ok

----

**Edit: Change of plans. Everything will stay free. **

----

**2. Coming Changes **

1. Right now we have 127 lessons which is overwhelming to someone new who signs up. Therefore, you would specify that when you sign up. Then the system will automatically track progress, and move you through to new lessons as you proceed with the course. The idea is to make this more focused so that each lesson is followed by a ""Congratulations, you just finished lesson 5! Click here to begin lesson 6!""

2. Currently the entire course is limited to C. I believe that learning the basics of C is important to any programmer, I plan to introduce courses on a variety of related skills including SQL, web design, networking, system administration, etc.

3. Quizes and Tests to advance will be required. If you reach lesson #19 and there is a test to proceed

4. The r/carlhprogramming sub-reddit will still be used for posting links to new lessons as they become available. However

5. It will still be possible to post questions/answers here on this sub-reddit

6. These courses will not be limited to just text lessons. I plan to have video demos

7. A significant focus will be placed on helping people who complete lessons to obtain jobs. Therefore, and will be describing the skills necessary, what lessons should have been completed, etc. 

----

**TLDR Part 2**: New domain

----

In addition to what I posted

Please post your thoughts in this thread.

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/baabh/future_plans_for_carlhprogramming_please_read_and/
1279296198.0,cqc43,"[CarlHProgramming] New Lessons Coming This Weekend. Also, a new course starting.",CarlH,125,8,http://www.reddit.com/r/carlhprogramming/comments/cqc43/carlhprogramming_new_lessons_coming_this_weekend/

Also, and possibly SQLite. Suggestions welcome.

Edit: 9 pm EST : I just wrote the first lesson:

http://www.reddit.com/r/carlhprogramming/comments/cqi6q/carlhprogramming_new_unit_new_lesson_251/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/cqc43/carlhprogramming_new_lessons_coming_this_weekend/
1254071214.0,9oknd,"Lesson 12 : The basics of Functions, Methods, Routines... etc.",CarlH,239,45
----
You now know that your CPU keeps track of the address of programming instructions being executed using an ""instruction pointer"". 

Everything we talked about in lesson 11 involved a single program in memory; a single list of tasks to do today. What would happen if you had two lists of tasks to do today instead of one?

First, followed by item #3, then you might jump to the second list and complete all the items on that list, then jump back to where you left off on the first list. 

It turns out that just like the above example

In an earlier lesson

Well, by just stating plain English names? The answer is yes - you can. Every programming language makes this possible in fact.

I could choose to call one function by the name of:

    business_to_do_today

and I could name another function: 

    personal_to_do_today

When I want a function to run, and everything else. As a programmer I do not have to worry about any of those details.

Every programming language does this differently. Some languages call these things functions, etc. The idea is the same. 

If it is a list of programming instructions meant to be executed and called by some plain English name
----
Please ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9olf8/lesson_13_about_parameters_and_return_values/



",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oknd/lesson_12_the_basics_of_functions_methods/
1254078057.0,9olf8,Lesson 13 : About parameters and return values.,CarlH,241,126,37,"In lesson 12 we learned the basics about functions. Primarily we learned that functions are programs that reside in memory just like data and that you can instruct your computer to jump to that point in memory

Now
----
Every program would be useless if it didn't have a way to display something to the screen. You could write a program for example that can convert a binary number to a hexadecimal number

It should then be clear that one function that is packaged with just about every programming language

Lets call this function ""print"" for the sake of this lesson. Imagine that ""print"" is a function that sits in memory, how could I do it?

First

You can give a function as many parameters as you like. For example, the color of the circle, the thickness, maybe even whether or not it is a dashed line or a solid line. 

Every programming language does this differently

Whenever a function finishes executing, or whether or not it was successful, or even to return complex data.

This is called a ""return value"". In our drawCircle example

1. Successful
2. Not successful

This is a simple example

In this case, and this can be used by whatever called the function.

Functions are everywhere in programming. Even your main program is itself a function. Some programming languages in fact require you to expressly create a function for your main program.
----
Please ask any questions you need to and ensure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9olme/lesson_14_about_syntax_and_function_vocabulary/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9olf8/lesson_13_about_parameters_and_return_values/
1254045745.0,9oi96,Lesson 10 : Programs are data too.,CarlH,263,147,21,"We have already learned that data such as numbers, as far as your computer is concerned

So in addition to some sequence of binary like 0110 0111 being possibly a number or text like we talked about

Every single instruction that is ever processed by your computer is encoded the same way as everything else. You guessed it

A program is fundamentally a sequence of many sets of 1s and 0s, and other instructions might be larger. Each instruction represents actual high/low voltage sequences which are transmitted directly to your CPU chip. Your CPU chip is designed to do many different things depending on exactly which sequence is received.

When a program is loaded into memory and executed, is sent to the CPU. The CPU then does what that instruction says to do. 

This is known as ""executing"" an instruction. Then the next sequence is executed. Then the next. And so on. This is done extremely fast until every single instruction in the program has been executed. This process of executing one instruction after another is known as ""program flow.""

At the end of the entire program, and we will go into it in greater detail later.

Now

----
Please feel free to ask any questions and make sure you have mastered this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9oiuc/test_of_lessons_1_through_10/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oi96/lesson_10_programs_are_data_too/
1254067117.0,9ok6s,Lesson 11 : More about program flow.,CarlH,247,141,31,"We are getting closer to being able to write our first program. We are now going to start to learn about the structure that defines all programs.

Now, you *really* understand it. Patience, and you will be writing real programs in no time.
----
We talked about how a program is a sequence of instructions. Every program has an address in memory where it begins. The CPU looks at that address in memory and executes the instruction found there

The way this works is simple: The CPU keeps track of the address in memory of the programming instructions to execute. Every time an instruction is executed

Think of it like this: You have a list of tasks to complete today. You number each of these items on a piece of paper. Here is an example:

1. Fix breakfast.
2. Go to the bank.
3. Deposit check.
4. Pay electric bill.
5. Wash the car.
6. Drive home.

Each of these steps can be thought of as a programming instruction. Now imagine that each of these numbers one through six is the ""address"" of that particular instruction. For example

You point a pen at item one, you mark it and point the pen to the next item on the list. You do this until everything is completed. The pen acts as a pointer to the instruction being executed so you can keep track of it. 

At any given time during this process you need to be aware of what step you are on. In other words

Inside your computer

Once a programming instruction is executed, but later on found out that you had to go back, it would be possible for you to move the pen back to the instruction that says ""Drive to the bank."". It is still written on the paper, and nothing stops you from executing that instruction again. 

Very often in a program it is necessary to repeat an instruction. This is achieved by telling the CPU to ""go back"" to an address in memory of an instruction that has already executed. 

For example, you could simply tell your program to go back to that instruction and repeat it - ten times.

It used to be that programmers had to keep track of the addresses in memory of various parts of the program they might want to re-execute. Fortunately

----
Please ask any questions and be sure you master this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9oknd/lesson_12_the_basics_of_functions_methods/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ok6s/lesson_11_more_about_program_flow/
1254079898.0,9olme,Lesson 14 : About syntax and function vocabulary.,CarlH,226,118,14,"Every programming language has two aspects that you need to know about. The first is called syntax

Syntax refers to the specific way in which a function requires you to do all of the things we have talked about up until now. In most languages for example

When two languages allow you to create the same function called myFunction

Learning the syntax of a language is really all that is meant by learning a programming language. However

Of course, and the functions that go with them.

So lets sum this up a bit. You can't learn how to use the functions that come with a language properly until you understand the syntax of that language. Also

Now

Therefore

1. Learn the syntax.
2. Learn the built in functions.
3. Obtain and learn the functions that come with libraries.

With #2 above

With #3 above

Remember that what you can create is always limited by the types of functions available to you

----

Please feel free to ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9olx4/lesson_15_your_first_program/

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9olme/lesson_14_about_syntax_and_function_vocabulary/
1326022519.0,o7vph,r/carlhprogramming : an update regarding highercomputingforeveryone domain.,CarlH,121,11,11,"Hi everyone

I received an email today from GoDaddy informing me that highercomputingforeveryone.com is coming up for renewal in a few months. I am not going to be renewing through GoDaddy in opposition to GoDaddy's support of SOPA/PIPA

That is the main reason for my post

I *will* be returning to this project. I am absent from this project not because I want to be

I will let everyone know as soon as I am able to resume this project. Meanwhile

Edit: To be clear

Edit: My new domain,,False,,t5_2r81y,1344312803.0,,True
1254142159.0,9os31,Lesson 18 : The basics of signed and unsigned numbers.,CarlH,201,98,11,"This lesson is intended to demonstrate the basics behind ""signed"" and ""unsigned"" numbers. This lesson is not specific to any programming language

----

We have already discussed that computers represent all data as binary. We also discussed that it is impossible to distinguish between one data type and another just by looking at it, a movie, or even a program.

For this lesson

    111

This is of course the number seven. If I asked you to store that inside of your computer

Alright, you need at least four because eight is represented as 1000 which requires four bits, or four binary digits. If you needed to store a number 16 or greater, you need at least five bits. Here we learn two important principles:

1. The number of bits determines the maximum size of any number.
2. Adding just one extra bit to any binary sequence doubles its capacity.

For example, you can store a total of sixteen values (zero through fifteen, including the zero). Each time you add a bit, you double the storage capacity.

I want to explore this a bit more so you can understand something about binary at a fundamental level. Lets look at a simple table of binary. We will start at zero

**0**000

**0**001

**0**010

**0**011

**0**100

**0**101

**0**110

**0**111

Now

**1**000

**1**001

**1**010

**1**011

**1**100

**1**101

**1**110

**1**111

And at fifteen we are done.

Did you notice that we simply repeated the first table of zero to seven a second time

We could also do something else here if we wanted to

We could choose to say that instead of an ""eights place""

Whenever you encode a number in binary in such a way that it can be either a positive or a negative number

**0**011 = positive three
**1**011 = negative three.

Whenever you define a bit as a flag for stating if a number is positive or negative

Now here you should notice something important. When using four bits, we can only now count half as much as before, but we can do so in two different directions. 

    0000 = 0
    0001 = +1
    0010 = +2
    0011 = +3
    0100 = +4
    0101 = +5
    0110 = +6
    0111 = +7
    1000 = +8 OR 0 (negative zero is zero)
    1001 = +9 OR -1
    1010 = +10 OR -2
    1011 = +11 OR -3
    1100 = +12 OR -4
    1101 = +13 OR -5
    1110 = +14 OR -6
    1111 = +15 OR -7

Remember

1. You can specify a number as being negative or positive with a ""sign bit"".
2. When you have a sign bit
3. The same exact binary can encode a signed number

----
Please feel free to ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9osdw/lesson_19_basics_of_numeric_overflow/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9os31/lesson_18_the_basics_of_signed_and_unsigned/
1254144208.0,9osdw,Lesson 19 : Basics of numeric overflow.,CarlH,195,96,20,"This lesson is not specific to any programming language

----

In the previous lesson we learned the basics for signed and unsigned numbers

Now

If I say that I have three bits available

    000
    001
    010
    011
    100
    101
    110
    111

Now

With three bits we can represent every value from zero through seven, we will get this result:

    110 = six
    111 = seven
    000 = Back to zero
    001 = one. 

Why did this happen? Well first remember that the rules of binary state that if all the columns are full, but here we have an issue. There is no column!

Whenever it happens that you use all the columns

Lets add four and six. Both of these values can in fact fit in 3 bits

       0100 
     + 0110
     ---------
       1010

(don't worry too much about adding in binary. We will get to that later.)

Now

Therefore, and is caused by the fact that we are performing a mathematical operation whose result requires more bits of storage space than we have available to use. 

Whenever this occurs

----
Please ask questions if you need to and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9ot5y/test_of_lessons_11_through_19/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9osdw/lesson_19_basics_of_numeric_overflow/
1254131156.0,9oqxp,Lesson 16 : Lets go over your first program.,CarlH,198,102,78,"Congratulations on writing your first program in any language. Everyone did a great job on this first program

    #include &lt;stdio.h&gt;

    int main(void) {
        printf(""Hello Reddit!"");
        return 0;
    }

I believe that from the lessons up until now

Here we had our first exposure to some of the syntax of a specific language

First, this is exactly how it is done - however I want to go over a bit more of this.

The idea when using an Include statement in general is that you are saying ""This file has something I want. I want to make the functions that are in this file available for use within my program."" Every programming language makes it possible for you to separate code into multiple files

When you say:

    #include &lt;stdio.h&gt;

You are basically saying, and we will go over them later. 

Now lets talk about the main() function. As I explained in previous lessons

When we talked about functions

Did you know that even programs you run operate in exactly this way? For example

    firefox.exe http://www.reddit.com

Well

Next

So from this explanation you should be able to understand that programs work in much the same way as any function works. 

Remember in an earlier lesson we talked about the importance of specifying data types whenever you work with data, or something else.

When you define a function you have to specify what data type you will be using for the return value. For example

The word ""number"" can mean several things. We will go over that

Integers are all whole numbers (but there are limits to this

    int

As you can see, a whole number. Therefore, we should specify this. We do so placing the keyword ""int"" in front of the function. 

    int main(void) {
        printf(""Hello Reddit"");
        return 0;
    }

Now we are saying ""our main function returns an integer when it is done.

Lastly

----
Please feel free to ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9or2s/lesson_17_run_your_first_program/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oqxp/lesson_16_lets_go_over_your_first_program/
1254053823.0,9oiuc,Test of Lessons 1 through 10.,CarlH,233,133,31,"This is designed to be a full course on programming

Take the time to complete this test even if the material seemed easy when you read it. it is important that before we proceed everyone has a solid understanding of the principles we have discussed so far.

Before you begin

**Please remember this for all lessons:**

This course is designed so that you can go as slow as you need to. Do not worry about falling behind, and that is fine. There is no need to rush to ""catch up"". *Take your time.*

If anything at all is unclear before you begin the test

----

Test of Lessons 1 through 10. 

**True or False**

1. 0101 is 3. 
2. The number 25 (twenty-five) is written in base ten.
3. Programmers have to keep track of the addresses in memory that data is stored.
4. An example of a binary number is: 1100 1001
5. In hexadecimal, two-hundred-fifty-six, five-hundred-twelve.
6. In binary, four, eight, sixteen.
7. 10 in any base will have the value of the base and this is true for all bases. (ex: 10 in base two would have the value of two
8. It is possible to look at binary data and determine whether it represents a number
9. When counting in hexadecimal
10. Hexadecimal digits include all numbers as well as the letters A through F.

**Fill in the blank**

1. Binary numbers are typically presented with spaces after every ___________ digits (ex: 1
2. In order to create advanced games and applications
3. An ___________ statement can be used to ""copy-paste"" programming source code from one file into the file you are working on.
4. Programming languages often enclose strings of text within ___________ (what character(s) on your keyboard?)
5. Data used by programs resides at specific addresses in ___________.
6. In addition to base ten
7. Everything inside a computer is stored as ___________.
8. 1101 1001 when converted from binary to decimal is: ___________.
9. Every sequence of ___________ binary digits (ex: 1
10. The value of 3C1A (hex) when converted to binary is: ___________.

----
When finished with the test

http://www.reddit.com/r/carlhprogramming/comments/9oizi/test_of_lessons_1_through_10_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oiuc/test_of_lessons_1_through_10/
1254132653.0,9or2s,Lesson 17 : Run your first program.,CarlH,203,106,169,"Writing a program is all well and good

To complete this lesson

**On Linux**

If you are on linux, then:

    gcc firstprogram.c -o firstprogram
    ./firstprogram

If gcc is not installed

    sudo apt-get install build-essential

**On Windows**

You need to obtain a compiler. There are many great free compilers out there for windows including: 

* **Recommended** : http://www.codeblocks.org/downloads/5 

Edit: get codeblocks-8.02mingw-setup.exe ]

----
**Having a problem which says ""Invalid compiler"" ? Try this**

I ran across this on Google for those having issues:

	
	
Re: uses an invalid compiler. Skipping...
 Reply #3 on: December 09
	
I encountered the same problem and solved it after a bit of tinkering...
steps would be:

1. goto ""Menu""-&gt;Settings -&gt;""Compiler and Debugger"" -&gt; [It will open a new Tab ]..... -&gt;
2. In this tab, Search subdirectories,......  next to that is ""&gt;"" button, click on the ""&gt;"" button 2-3 times, till you find ""Toolchain executables"" in same line.
3. In this window
4. For varification
   &lt;If this is done

----

Other good compilers for Windows are:


* http://www.microsoft.com/express/vc/Default.aspx
* http://www.delorie.com/djgpp/zip-picker.html


----

**Edit: Here are some details on getting started with codeblocks**

First

When you get to the screen after installing it, give it a filename, and a directory to store it in. 

I recommend you create a directory on your computer for your C programs. 

On the next screen ""Compiler configuration"" leave everything as is. Then

You will see that Codeblocks by default already has a ""Hello World"" program pre-typed for you. There are slight differences to the one we wrote

At the top there is a ""play"" button (a blue triangle icon) that when you mouse over says ""Run"". Click that button and it will ask you if you want to build the project

----


Once you have a compiler installed and working

**Mac**

* http://www.codeblocks.org/downloads/5

If you get an error similar to ""Nothing to be done""

OR:

To compile and run a program all you have to do is save the program as a file

    gcc firstprogram.c -o firstprogram
    ./firstprogram

**Alternative Methods**

Without downloading or installing any program

http://www.codepad.org

----
Please feel free to ask any questions. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9os31/lesson_18_the_basics_of_signed_and_unsigned/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9or2s/lesson_17_run_your_first_program/
1254055422.0,9oizi,Test of Lessons 1 through 10. [Answers],CarlH,223,125,102,"If you missed any

----

Test of Lessons 1 through 10. 

**True or False**

1. 0101 is 3. **False** (1+4 = 5)
2. The number 25 (twenty-five) is written in base ten. **True**
3. Programmers have to keep track of the addresses in memory that data is stored. **False** (This is kept track of by the programming language.)
4. An example of a binary number is: 1100 1001 **True**
5. In hexadecimal, two-hundred-fifty-six, five-hundred-twelve. **False** (Exercise for the reader if you got it wrong)
6. In binary, four, eight, sixteen. **True**
7. 10 in any base will have the value of the base and this is true for all bases. (ex: 10 in base two would have the value of two
8. It is possible to look at binary data and determine whether it represents a number, and you have no way to tell just by looking.)
9. When counting in hexadecimal
10. Hexadecimal digits include all numbers as well as the letters A through F. **True**

**Fill in the blank**

1. Binary numbers are typically presented with spaces after every ___________ digits (ex: 1
2. In order to create advanced games and applications
3. An ___________ statement can be used to ""copy-paste"" programming source code from one file into the file you are working on. **Include**
4. Programming languages often enclose strings of text within ___________ (what character(s) on your keyboard?) **Quotes (single and/or double)**
5. Data used by programs resides at specific addresses in ___________. **ram/memory**
6. In addition to base ten
7. Everything inside a computer is stored as ___________. **Binary**
8. 1101 1001 when converted from binary to decimal is: ___________.  **217**
9. Every sequence of ___________ binary digits (ex: 1
10. The value of 3C1A (hex) when converted to binary is: ___________. **0011 1100 0001 1010**

---- 
Feel free to ask any questions related to this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9ok6s/lesson_11_more_about_program_flow/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9oizi/test_of_lessons_1_through_10_answers/
1256638709.0,9y6os,Lesson 114 : Simple project management,CarlH,103,8,16,"Ok

Before I show you how to write a tic-tac-toe game

You may be surprised to know that programming takes up at the very maximum 40% of any work day for me. That means that *most* of the time I am working

You cannot just sit down and start writing a program. You must have a clear idea of what it is you are trying to do. This requires planning and research. Also

With this in mind

Now

    [ ] Tic-Tac-Toe Game
        [ ] ... Now we break it into parts ...

Notice how I use `[ ]` to indicate a part of a project that is not yet completed, and it is easy to keep track of your progress. You can also expand lines very easily. 

I do *not* use any kind of paper based project manager. The problem with paper is if you write out ten lines

So the rule is simple, you will find it starts abstract and slowly becomes closer to actual code you can write. Here is a simple example:

    [ ] Write first C program
        [ ] It needs to say ""Hello Reddit""
            [ ] printf(""Hello Reddit"");

This is a simple example, you end up simultaneously writing out *how* you will achieve it. That is the hallmark of a good project plan.

Now

    [ ] There exists a tic-tac-toe program.

Now

    [ ] There exists a tic-tac-toe program.
        [ ] There is a grid of nine squares 
            [ ] There is a function that will display this grid

Ok.. now what does it mean to ""draw the grid"" ?

                [ ] This function will clear the screen
                [ ] This function will draw out the first row of 3 squares
                [ ] This function will draw out the second row of 3 squares
                [ ] This function will draw out the third row of 3 squares

Ok

                [ ] This function will draw out the first row of 3 squares
                    [ ] For each of three squares :
                        [ ] Determine if it is an 'X'
                            [ ] If 'X' :
                                [ ] Draw an 'X'
                                    [ ] printf(""X"");

And already you can see how this is turning into programming code. You should also start to see, and we need a function to draw a row, and we need a function to draw the whole grid. 

I do not actually need to write out ""printf(X)"" in the above project plan. I did so only so you can see how the process evolves from simple statements, you should be able to see a well written project plan and simply envision the code that should make it happen. You do not write the code into the project plan. Rather, you write the code into the actual program, while simultaneously checking off the parts of the project that are then completed.

Notice that everything becomes clear as you simply write out the details of the project. When the project plan is done

Further

----

Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9zg1z/lesson_115_structures_contain_data_and/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9y6os/lesson_114_simple_project_management/
1254866004.0,9rh9y,Lesson 62 : The Basics of Algorithm Design Part Three,CarlH,99,2,16,"In the last several lessons I have shown you various ways to do the same task

These lessons are designed not only to show you how to create algorithms, starting at the final algorithm (similar to what you might actually encounter) and then showing you how to decipher it.

Please take your time through this and all lessons. I am proceeding through this subject slowly in order to avoid confusing anyone. This is complex material, you should take advantage of that to learn as much as possible.

Here is the algorithm we are going to work with. This is exactly the same as what we did in Lesson 59

----

        Figure (a) : Algorithm to convert YYYYMMDD to 3 strings.

        for (i = 0; i &lt; 4; i++) {
            if (i &lt; 2) {
                day[i]   = date[i+6];
                month[i] = date[i+4];
            }

            year[i] = date[i];
        }
----
This is the final algorithm. This is the type of thing you are likely to see when you read source code. It may look scary

Notice I did away with the pointer indexing. In reality I didn't

First let me explain why I took such an easy to read example in Lesson 59 and transformed it into what you see here. Remember that the code in Lesson 59 is not really the same as the code here even though it does the same task. They both achieve the same goal, and more efficiently. 

In general you will find that algorithms made to be fast and efficient will also tend to be difficult to understand at a glance. This is because we are writing instructions for a machine

Now let's begin the lesson.

First of all

You will find that no matter how intimidating it appears at first

If you just stare at any lesson in this course and try to see it all at once, and cryptic terms. When you see things like that, it can be intimidating. 

Now

Notice there is a for loop which says that the contents inside it are going to execute.. how many times? four. So the first step to expanding this algorithm will be to take the contents of the for loop and examine each iteration

Whenever you talk about a loop

Here is the first iteration of our loop

            i = 0;

            if (i &lt; 2) {                       // &lt;-- is i less than 2? Yes
                day[0]   = date[0+6];
                month[0] = date[0+4];
            }

            year[0] = date[0];

Notice all I really did here was to remove the for loop start and end

Do we really need an if statement here? No. We just need to remember that the contents of the if statement execute when i is less than two. In other words

So let's re-write our expansion of the first iteration:

                day[i]   = date[i+6];
                month[i] = date[i+4];
                year[i]  = date[i];

I took out the code for the if statement start and end. Why? Because i *is* less than 2. Therefore

Now

                day[0]   = date[0+6];          
                month[0] = date[0+4];
                year[0]  = date[0];

Now

                day[0]   = date[6];          
                month[0] = date[4];
                year[0]  = date[0];

Now we have readable code. This is the *first iteration* of our loop. Now we just have to figure out what this code means.

Observe `date` in memory:

    Y Y Y Y M M D D
    0 1 2 3 4 5 6 7

I labeled each character so this will make more sense. 

1. Set the first character of the string `day` to be character #6 of `date` (Remember
2. Set the first character of the string `month` to be character #4 of `date`
3. Set the first character of year to be the first character of `date`.

So what we have are really three simultaneous processes going on. The first digit of YEAR is set. The first digit of MONTH is set. The first digit of DAY is set. We know the first digit of YEAR is the first digit of the string in general. We know the first digit of MONTH is digit #4 (when starting at 0). We know the first digit of DAY is digit #6 (when starting at 0). 

Now

        Figure (a)

        for (i = 0; i &lt; 4; i++) {
            if (i &lt; 2) {
                day[i]   = date[i+6];
                month[i] = date[i+4];
            }

            year[i] = date[i];
        }

Now lets look again at just the first iteration:

                Figure (b) : First iteration

                day[0]   = date[6];          
                month[0] = date[4];
                year[0]  = date[0];


Make sure you can understand how the first iteration transforms from the loop to the simplified version in Figure (b). We will explore more of this in upcoming lessons. 

Why do you need to know how to understand an algorithm? Because you *will* encounter them
----
Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9ribz/lesson_63_the_basics_of_algorithm_design_part_four/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9rh9y/lesson_62_the_basics_of_algorithm_design_part/
1254854335.0,9rfee,Lesson 61 : The Basics of Algorithm Design Part Two,CarlH,96,2,24,"In our last lesson we ended up with a series of while loops which all had three things in common: 

1. They all had some initial state
2. They all had a conditional statement to know when the loop was done.
3. They all incremented the variables at the end.

It turns out that this three step process is used so much that programming languages have created a sort of ""short hand"" while loop called a *for* loop.

Here I will show you the while loop for `year` in our previous lesson

While loop:

    Figure (a)

    while (i &lt; 4) {
        year[i] = *(my_pointer + i);

        i++;
    }

For loop:

    for (i = 0; i &lt; 4; i++) {
        year[i] = *(my_pointer + i);
    }

We have combined the starting conditions

----
&gt; for (**i = 0**; i &lt; 10; i++) {

This is our starting condition. We are setting the variable i to 0. This is the same thing as the code above our while loop. This part in bold executes *before the loop begins*. This is very important to remember. It is not part of the loop

----
&gt; for (i = 0; **i &lt; 10**; i++) {

This is our conditional statement. This is exactly the same as what goes in the parentheses of the while loop. 

----
&gt; for (i = 0; i &lt; 10; **i++**) {

This is the final statement that will execute at the end of the loop. It is identical to putting the incrementing statement at the end of our while loop.

----
Now

    for (i = 0
        month[i] = *(my_pointer + j);
    }

    for (i = 0
        day[i] = *(my_pointer + j);
    }

Notice that we used commas to separate statements inside our loop expressions

For example

Now here is our final code again

Notice that we initialized our variables before any of the loops began. This is good practice as we are defining ahead of time which variables we intend to use for our loops. This also lets a programmer reading the source code understand that none of these loops will require more than two variables.


----

    // First we create and initialize the variables we will need for the loop.
    int i = 0;
    int j = 0;

    // First Year
    for (i = 0; i &lt; 4; i++) {
        year[i] = *(my_pointer + i);
    }

    // Now Month
    for (i = 0
        month[i] = *(my_pointer + j);
    }

    // Now Day
    for (i = 0
        day[i] = *(my_pointer + j);
    }

----
Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9rh9y/lesson_62_the_basics_of_algorithm_design_part/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9rfee/lesson_61_the_basics_of_algorithm_design_part_two/
1374853949.0,1j3pr1,"[CarlHProgramming] Updating website, and new lessons soon!",CarlH,107,13,http://www.reddit.com/r/carlhprogramming/comments/1j3pr1/carlhprogramming_updating_website_and_new_lessons/

I know that it has been a long wait

Optimistically

Thank you to everyone for your support.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1j3pr1/carlhprogramming_updating_website_and_new_lessons/
1261304537.0,agppk,Lesson 127 : The basics of Recursion : Part One,CarlH,101,10,29,"There are several concepts in computing which provide a more significant challenge than others. For example, I want to take this material slowly to ensure that everyone will understand it.

First

It is often the case that you have some function which calls another. For example

    void print_my_name() {
        printf(""My name is Carl.\n"");
    }

The function I just made is in fact calling a different function

    void print_my_name() {
        printf(""My name is Carl.\n"");

        print_my_name_again();
    }

    void print_my_name_again() {
        printf(""My name is Carl.\n"");
    }

From here you can see that I will execute the ""copy function"" and thus it will result in displaying ""My name is Carl"" two times

    void print_my_name() {
        printf(""My name is Carl.\n"");

        print_my_name_again();
    }

    void print_my_name_again() {
        printf(""My name is Carl.\n"");

        print_my_name();
    }

And here ask yourself the following question: How many times will ""My name is Carl."" display? Effectively, the process will never stop. 

If I had some desire to run the same function over and over again, why can't I just call the function from within itself? It turns out that you can, and this is the basis for recursion.

Imagine for example

    function print_my_name() {
        printf(""My name is Carl. \n"");
        
        print_my_name();
    }

As you can see here any time this function is called it will print ""My name is Carl."" However

The concept of a function calling itself may seem difficult

    PRINT_MY_NAME:
        printf(""My name is Carl. \n"");
        
        GOTO PRINT_MY_NAME:

This is not entirely accurate, but the basic concept is similar. There is a conceptual similarity between loops and recursion.

As I mentioned above, is yes.

This therefore brings us to an important concept which applies for recursion just as it does for loops. When you have a function that calls itself

For loops you do this typically by setting a ""counting variable"" and incrementing or decrementing it until the loop reaches some condition

It is useful to understand recursion in a somewhat similar way. For any potentially never-ending process you must have some condition which you can test for that is capable of causing the process to stop.

In this lesson I have introduced you to the concept of recursion by explaining that it refers to a function which calls itself. At this stage

All you need to know after this lesson is the following:

1. Recursion refers to the process of having a function call itself.
2. A function is said to be ""recursive"" if it calls itself.

----

Please ask questions in this thread if any of this material is unclear.",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/agppk/lesson_127_the_basics_of_recursion_part_one/
1254850993.0,9reqb,Lesson 60 : The Basics of Algorithm Design Part One,CarlH,97,4,29,"In the previous lesson I showed how you can take a string of text formatted as a date in YYYYMMDD format, and day. 

This was a simple example of something called an algorithm. An algorithm is a sequence of steps you take inside of a program to perform some complicated task. Usually algorithms involve loops as they need to repeat instructions numerous times. 

Algorithm design refers in part to taking some process you want to accomplish and turning it into a working system of loops which get the job done. In this lesson I am not just going to simply explain what an algorithm is. I am going to show you the thought processes behind it. 

Why do you need to do this? Because algorithms can often expand into more lines of code than you could write in a reasonable amount of time. For example

Properly being able to write and read complex algorithms is a critical skill that any serious programmer needs. At this stage in the course

Keep in mind from the previous lesson that we had something that looked like this:

    Figure (a)

    year[0] = *my_pointer;          // same as *(my_pointer + 0)
    year[1] = *(my_pointer + 1);
    year[2] = *(my_pointer + 2);
    year[3] = *(my_pointer + 3);

What you should notice about this is that there is ""a number"" that changes according to a set pattern. In this case

First ask yourself how many times will the loop need to execute? Four times. Why? Because there are four lines of code in Figure (a). Let's therefore construct the loop skeleton:

    int i = 0;
    while (i &lt; 4) {
        ... code goes here ...
        i = i + 1;
    }

Why is this the loop skeleton? Because it will execute whatever is inside it four times. Each time this loop executes

The next step is to take a candidate line of code from our working code

    year[0] = *my_pointer;

That is our first line of code. What is wrong with it? It only takes into account *one* changing value (the 0 in brackets) but it ignores the other changing value (the number after `my_pointer`). A much better candidate will take into account *both* changing values. 

I have picked one such candidate and pasted it into our loop:

    while (i &lt; 4) {
        ... code goes here ...
        year[2] = *(my_pointer + 2); &lt;--- I just cut and pasted this.
        i = i + 1;
    }

Notice I have not changed anything yet. I just pasted it as is.

Now

    while (i &lt; 4) {
        year[i] = *(my_pointer + i); &lt;--- I just changed the number to i
        i = i + 1;
    }

Why did I change the number to i? Because i is a variable that will change exactly the same way our number did in Figure (a). 

Now

        i = 0;
        year[i] = *(my_pointer + i);     i = i +1;
        year[i] = *(my_pointer + i);     i = i +1;
        year[i] = *(my_pointer + i);     i = i +1;
        year[i] = *(my_pointer + i);     i = i +1;

Here it will stop

Notice that I put the incrementing statements at the end of each line so that it is easier to read. These are ""reminders"" so I can see exactly how the loop is changing each time.

If you mentally follow that in your mind

        year[0] = *(my_pointer + 0);
        year[1] = *(my_pointer + 1);
        year[2] = *(my_pointer + 2);
        year[3] = *(my_pointer + 3);

If you do not see how this is

Now

Recall that month looks like this:

    month[0] = *(my_pointer + 4);
    month[1] = *(my_pointer + 5);

Now lets turn it into a loop. Notice there are *two different* incrementing values this time. You have a 0 and a 1, but we will get to that.)

Let's reset the variable i back to 0

Also

In general

    i = 0;         // We do not need to say int i = 0 because we already did that.
    int j = 4; 

    while (i &lt; 2 &amp;&amp; j &lt; 6) {
        month[i] = *(my_pointer + j);
        
        i++;
        j++;
    }

Let's expand it:

    i = 0; j = 4;
    month[i] = *(my_pointer + j);     i = i+1;     j = j+1;
    month[i] = *(my_pointer + j);     i = i+1;     j = j+1;

What will it expand into? To find out I am just going to plug in the values for i and j that I defined for *just* the *first line* of code:

    month[0] = *(my_pointer + 4); i = i+1; j = j+1;

I put in 0 for i

Now, I will do the same thing for the second line of code.

    month[1] = *(my_pointer + 5); i = i+1; j = j+1;

Now lets put both lines together

    month[0] = *(my_pointer + 4);
    month[1] = *(my_pointer + 5);

As you can see

Finally

    day[0] = *(my_pointer + 6);
    day[1] = *(my_pointer + 7);

Again

    i = 0; 
    j = 6;

    while (i &lt; 2 &amp;&amp; j &lt; 8) {
        day[i] = *(my_pointer + j);
        
        i++;
        j++;
    }
        
You should be able to see on your own that it expands to:

    day[0] = *(my_pointer + 6);
    day[1] = *(my_pointer + 7);

Let's look at the entire thing now

----

    // First Year
    int i = 0;
    while (i &lt; 4) {
        year[i] = *(my_pointer + i);

        i++;
    }

    // Now Month
    i = 0;
    int j = 4; 

    while (i &lt; 2 &amp;&amp; j &lt; 6) {
        month[i] = *(my_pointer + j);
        
        i++;
        j++;
    }

    // Now Day
    i = 0; 
    j = 6;

    while (i &lt; 2 &amp;&amp; j &lt; 8) {
        day[i] = *(my_pointer + j);
        
        i++;
        j++;
    }
----
Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9rfee/lesson_61_the_basics_of_algorithm_design_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9reqb/lesson_60_the_basics_of_algorithm_design_part_one/
1355655101.0,14xrzj,[CarlHProgramming] An Update,CarlH,105,16,13,"As many of you know

Around mid-October

Also, unwind, and then I can start again shortly after the new year. It made sense to spend the rest of this year catching up on work, and then to resume my programming lessons/courses shortly after the start of next year.

It now looks like my workload is starting to calm down. Therefore, watch for future updates on that.

I also have a HUGE backlog of questions on the website, just pm me your email address and I can forward to you links to questions.

I hope this brings everyone up to speed

",,t5_2r81y,1355665249.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/14xrzj/carlhprogramming_an_update/
1254935960.0,9rrha,Lesson 64 : Introducing Multi-Dimensional Arrays,CarlH,99,8,20,"There will not be many lessons today

----

The purpose of this lesson is to help you to understand multi-dimensional arrays, we need to do away with certain misconceptions. 

The first problem with this subject is that when you think of a two dimensional array, if I say ""a 3x3 array"" you would imagine a grid where there are three rows, and three columns.

In reality, and N dimensional arrays. The correct way to think of a two dimensional array (or N dimensional arrays in general) is to understand them as a *set of offsets* in a single linear stretch of memory.

What do I mean by this? Well, any two, or three, or N dimensional array can only be represented using a ""one dimensional"" coordinate (which is simply an offset). 

This lesson is going to explain how this works, or N dimensional array.

First, each starting one after the other.

    ""OneTwoThree""

Now

1. The first character (index 0) will be the first letter of the word ""One"".
2. The fourth character (index 3) will be the first letter of the word ""Two"".
3. The seventh character (index 6) will be the first letter of the word ""Three"".

You should notice there is a lot in common here with our earlier examples concerning a basic data structure. Indeed

When you see this string: ""OneTwoThree"", you can mentally transform this linear one-dimensional array into a two dimensional array.

So let's write out a description of how this can be understood:

    string [0] = ""One""
    string [1] = ""Two""
    string [2] = ""Three""

Do not consider the above as being C code. The above example is purely for illustrative purposes. I am just showing you an alternate way of understanding the text. As you can see

What would we mean if we wrote this:

    string[0][0] 

We would mean the first letter of the first word. What if we wrote this?

    string[2][4]

We would mean the fifth character ([4] - start at zero) of the third word. (which is string[2]). 

Remember that string[2] refers to the word ""Three"". So string[2][4] would mean character #4 of the word ""Three"". Since we start at 0

So here you can plainly see that a two dimensional array for us is really just *two offsets* of a one-dimensional array. In fact

    O  n  e  T  w  o  T  h  r  e  e
    0  1  2  3  4  5  6  7  8  9  10

Now, I could simply say: string[4]. 

However

Why 3? Because that is the array index where the word ""Two"" begins.

Why +1? Because +0 is the T, by just *adding* two offsets together, we are capable of reaching *any point* in our two-dimensional array construct.

This is an important point to understand. Any element of any N dimensional array is understood by adding *some offset* to the very start of the array. Indeed this is true for all data structures no matter their complexity.

So what you can see here is that a two dimensional array is actually a one dimensional array in disguise. This is true no matter how complex the array. Indeed

    array[32+10+3+2+1] 

What do we get when we add all those numbers together? A single number

    array[32][10][3][2][1]

Now

    char *string = ""RedditProgrammingClasses"";

1. The word ""Reddit"" starts at position 0. 
2. The word ""Programming"" starts at position 6.
3. The word ""Classes"" starts at position 17.

How can we get the a in Classes? 17+2

Notice that 17+2 is exactly the same thing as 19. There is no difference.

Remember, any system we devise for modeling an N dimensional array is just our own invention. The computer will still understand every location in an array as simply an offset from the starting address in memory where the array begins. 

Whether we say: ""Go over ten

Keep this in mind when working with arrays and data structures in general. 

It is worth pointing out that this lesson is only an introduction to the subject

In the next lessons we will examine how multi-dimensional arrays are actually created and used in C and other languages

----
Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9rtl9/lesson_65_creating_twodimensional_arrays_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9rrha/lesson_64_introducing_multidimensional_arrays/
1254165733.0,9ow85,"Lesson 22 : The ""char"" data type and the basics of ASCII.",CarlH,182,88,39,"In the previous lesson we learned about numeric data types. The next data type we need to learn is called ""char"". The word ""char"" is short for ""character"" and refers typically to characters of text. Characters of text usually occupy one byte per character. One byte is almost always 8 bits

Lets imagine I say this:

    printf(""a"");

We know that somehow ""a"" is being encoded in binary

One such table that many C/C++ compilers use is the ASCII table. The ASCII table is simply a table of many different characters which can be represented in a single byte. All the letters on your keyboard (Assuming a US layout keyboard) are ASCII characters. 

First, this is not 100% universal, and I encourage you to keep that in mind.

If we consider a byte as eight binary digits

Note that each of these tables will show the hexadecimal values within parenthesis.

First lets look at A through Z.

    0100 0001 (41) = 'A' 
    0100 0010 (42) = 'B'
    0100 0011 (43) = 'C'
    ....
    0101 1000 (58) = 'X'
    0101 1001 (59) = 'Y'
    0101 1010 (5A) = 'Z'

This is not hard to remember

1. Each ASCII letter has 8 bits (1 byte)
2. All CAPITAL letters will begin with: 010. (This means the first digit will be either a 4 or a 5 in hex
3. The last 5 bits start at 1 and work up to twenty-six. Note that the character 'Z' = 5A = 010**1 1010**

    1 1010 = 26 (16 + 8 + 2)

Keep in mind that you are starting at: 0100 0001 (41) and just working your way up through the 26 capital letters.

Now

    0110 0001 (61) = 'a' 
    0110 0010 (62) = 'b'
    0110 0011 (63) = 'c'
    ....
    0111 1000 (78) = 'x'
    0111 1001 (79) = 'y'
    0111 1010 (7A) = 'z'

Notice that while all capital letters begin with 010

&gt; 00**1**0 0000 

is a FLAG for denoting uppercase or lowercase letters. This means that if you have an uppercase letter

For now

----

Please remember that ASCII is only one way that you can encode characters. We will learn about others throughout this course. Also

----
Please ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9owj2/lesson_23_the_numbers_on_your_keyboard_as/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ow85/lesson_22_the_char_data_type_and_the_basics_of/
1254158570.0,9ouzt,Lesson 20 : Basics of fractional numbers in binary.,CarlH,184,95,29,"This lesson is designed to teach you about how fractional numbers are represented in binary in general. This lesson is not specific to any programming language

----

In earlier lessons we learned how we can represent any whole number as a binary number. We even developed as system that allows us to do this for negative numbers. Therefore

However

First, you cut the number into two parts. The left hand side of the number is an integer, then you put a period, then you put the fractional part. Lets look at this in detail:

    172.31 

Here we have the number one-hundred seventy-two

There is a 1 in the hundreds place, and a 1 in the hundredths place. 

Note that we consider the place values to the right of the decimal point as fractional parts based on powers of ten

    .1 = 1/10
    .03 = 3/100
    .002 = 2/1000

So we go tenths, etc. 

Now lets look at a totally different number

So in binary, we are using two. Therefore instead of 1/10, 1/100, 1/1000 we will be doing: 1/2, 1/4, 1/8, and so on. Now lets look at this in action.

    0110.1000

Remember that to the left of the decimal point (called a radix point by the way) we have the value of six. If you do not understand why

Suppose we had:

    0011.1100

Now we have three to the left of the radix point, the value here is: 3.75

Now what if we wanted to say: 8.1 - that is

    0.1 = 1/2 (too high)
    0.01 = 1/4 (too high)
    0.001 = 1/8 (too high
    0.0001 = 1/16 (too low)
    0.00011 = 1/16 + 1/32 = 3/32 = 0.09375 -- very close to .1

    Note that 3/30 would be exactly a tenth.

Note that the more digits we add, we will be unable to. This is known as the level of precision.  

Fortunately, understanding how this works will help you to understand upcoming lessons.

The last thing we need to address is a question you are sure to have: If we can only store 1s and 0s, and the number of bits to the left.

If you wanted to store the value 6.5 in the computer, and the last four digits to be part of the fractional number - to the right of the radix point. We will get into how this is done in a future lesson.

----
Please ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9ovi4/lesson_21_the_basics_of_numeric_data_types_in_c/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ouzt/lesson_20_basics_of_fractional_numbers_in_binary/
1343942583.0,xl2jx,"""Higher Computing for Everyone"" is now ""Computer Science for Everyone"", Also an update.",CarlH,97,7,http://www.reddit.com/r/carlhprogramming/comments/xl2jx/higher_computing_for_everyone_is_now_computer/

As some of you have probably noticed, etc).

I have been tweaking the way the points system and lesson tracking system works, as well as the most recent lesson ""completed"" (as determined by the highest quiz that has been taken).

The original plan was for quizzes to grant 10 points per quiz, most likely by asking 1-2 questions at the end of each lesson to earn 5 points.

I am going to start working on Unit 12 videos now

----
As I upload new lessons in Unit 12


**Unit 12**

#1. [Introducing GOTO and Loops in C](http://www.computerscienceforeveryone.com/Course_1/Unit_12/Lesson_1/)
#2. [More about blocks of code](http://www.computerscienceforeveryone.com/Course_1/Unit_12/Lesson_2/)
#3. [Introducing the While Loop](http://www.computerscienceforeveryone.com/Course_1/Unit_12/Lesson_3/)
#4. [Introducing Custom Functions](http://www.computerscienceforeveryone.com/Course_1/Unit_12/Lesson_4/)

(That's all for today)",,t5_2r81y,1343961356.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xl2jx/higher_computing_for_everyone_is_now_computer/
1254236064.0,9p61e,Lesson 25 : Minimum and Maximum values of Signed Integers.,CarlH,163,74,17,"This lesson is a bit more intense than most
----
In Lesson 24 we learned how to calculate the maximum values that can be stored in a set number of bits. For example

Here I want to expand on this knowledge a bit. Lets consider that we still have two bytes to work with

The purpose of this lesson is to learn how to calculate the minimum and maximum values for ""signed"" integers.

You should remember from a previous lesson that using a sign bit cuts in half the total numbers that can be represented

Lets examine the situation when we have four bits to work with

If we were to use one of those bits as a ""sign bit""

If you need any review on this concept

If you remember from that lesson, since we only need to represent ""zero"" in one way. Lets look at that table again:

    0000 = 0
    0001 = +1
    0010 = +2
    0011 = +3
    0100 = +4
    0101 = +5
    0110 = +6
    0111 = +7
    1000 = 0 &lt;--- this is extra. We do not need it.
    1001 = -1
    1010 = -2
    1011 = -3
    1100 = -4
    1101 = -5
    1110 = -6
    1111 = -7

If we choose to not use zero twice, this makes sense since for the extra value, the ""sign bit"" is already set to indicate this is a negative number. 

Of course

Notice from the above table that exactly half of the total possibilities have the sign bit set to ""positive""

Lets look at this in action. When we are considering two bytes, we get:

    65

If we allowed for a ""positive zero and a negative zero"", and exactly 32,768 numbers where the ""sign bit"" was set to ""negative"". 

Since in both cases we would start counting at zero
and our minimum negative value would be: -32

However, the final case is:

    Any value from -32

Make sure you understand that before proceeding. Now we can develop a simple formula for this for all signed integers:

The minimum value will be:

    negative ( (2 to the power of the number of bits) divided by two)
    or: 2^n / -2      where n = number of bits.

The maximum value 

    ( (2 to the power of the number of bits) divided by two ) minus one
    or: (2^n / 2) - 1      where n = number of bits.

Briefly

One thing I want you to realize is that no matter *how* it was done, and 32,768 values where the sign bit is set to negative. This example uses two bytes of course, but the same applies no matter how many bytes of storage are used. 
----
Please feel free to ask any questions and ensure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9p6me/lesson_26_introducing_variables/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9p61e/lesson_25_minimum_and_maximum_values_of_signed/
1254227865.0,9p4h2,Lesson 24 : About maximum values for unsigned integers.,CarlH,171,83,34,"So far

Fundamentally we learned that every number as well as every character of text is encoded in binary in a certain way and then stored in memory. We learned that you can specify exactly what type of format you wish to use with certain keywords such as ""signed""

We learned in a previous lesson that the number of bits you have available for a number determines how big of a number you can have. For example

Each data type has a set size in bits. This also means that each data type has a maximum number it can hold. If you are using a ""sign bit""

Figuring this out is actually quite simple. There are three possible cases to consider:

""unsigned""

In this lesson

If a data type is unsigned

For example

Why do you subtract one? Because you always start counting at zero. If I count: 0, 3, 4, 5, 6, 7: I have counted eight total numbers including zero, but the maximum value is still seven - not eight.

So because you always start counting from zero

Now

If you have a numeric data type which is contained in two bytes (16 bits)

    2^16 = 65

Now

    65

Keep in mind

    1111 1111   1111 1111 (FF FF in hex)

This is another way of saying that with 65

You may wonder why you need to know this

----

Remember that the maximum values as well as the size in bytes of each C data type may differ between C compilers. There are however certain requirements that all compilers must follow. We will explore that in greater detail later in the course.

----
Feel free to ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9p61e/lesson_25_minimum_and_maximum_values_of_signed/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9p4h2/lesson_24_about_maximum_values_for_unsigned/
1255310599.0,9t2r9,Lesson 85 : Tic-Tac-Toe With A.I. : Part 1,CarlH,102,11,43,"This lesson could also be titled: ""The Real Course Begins"".

We have finally reached the point in this course where you can start applying your knowledge to making ""real"" programs. We must start with simple programs and then we will work our way up. Of course

Rather than show you how to write a simple 2-player tic-tac-toe game, or lost, or drawn.

Also, and making sure you have all the tools you need to do it. I know that tic-tac-toe is probably not the most exciting project, but we have to start somewhere. We will get into bigger and better things soon enough.

The first thing I need to tell you is that to create a tic-tac-toe engine that is capable of calculating N moves ahead on a tic-tac-toe board

Why not an array? Well, you could have an int variable which tracks how many moves have been played. You could have another variable which tracks whether or not the position is winnable, and so on. Your data structure could contain additional ""meta data"" which is useful to the program.

Another major advantage to using a data structure is that once we have our data structure definition

Before we begin

Suppose you are writing a chess program that can calculate moves on a chess board. You need a way to evaluate each position

Here is another example. Suppose you are writing an artificial intelligence for an enemy in a computer game. You may desire a way to calculate the consequences of a specific action the character may take. You could create a unique data structure based on the expected result of a particular action and compare it to similar data structures created based on the expected result of a different action.

If you want to create the ability to undo some operation in a graphics program, you could save ""states"" of a drawing that can be worked on uniquely, such as in layering. 

If you are writing a web browser

As you can see

    tictactoe_board *new_board = malloc(sizeof(*new_board));

in this case

----



Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9tfn4/lesson_86_the_need_to_initialize_data/
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9t2r9/lesson_85_tictactoe_with_ai_part_1/
1254760816.0,9r12o,Lesson 59 : Introduction to data structures,CarlH,102,12,50,"Up until now we have only worked with simple data

In this lesson we are going to explore what this actually means. What do I mean when I say ""see"" data? Well

Here is a simple example:

    20091005 &lt;-- Today's date in YYYYMMDD format (year

This is a very basic data structure. Why is it a data structure? Because we are actually storing three different bits of information (data) together. It is a string of text, 2009. In other words, to be properly understood it must be broken into pieces, one unique piece for: month, day, and year. 

First

    char date[] = ""20091005"";

Lets suppose we want the following printf() statement:

    printf(""The year is ___ and the month is ___ and the day is ___ \n"");

Notice that you cannot do this using the string we just created. It is *too complex*. It is a data structure. What we want is a way to break the data structure down into pieces

We are using a date string as an example, which you have seen if you have worked with HTML:

    color = FF22AA

This is a data structure which defines a color. For those not familiar with this

However

Lets go back to our printf() statement. We want to print the year

First of all, like this one, are simple. 

In this case

The first four characters are the year. The next two characters are the month. The final two characters are the day.

We could also word it like this:

    &lt;year&gt;&lt;month&gt;&lt;day&gt;
    year = 4 bytes
    month = 2 bytes
    day = 2 bytes

To parse any data structure

A parsing algorithm is a ""small program"" designed to ""understand"" the data structure. In other words

Lets create a pointer to our string:

    char *my_pointer = string;

Why did I create a pointer? Remember, etc). The pointer is like your eyes scanning words on a page to understand the meaning of a sentence.

What will our pointer *do* ? It will scan through this data structure string

Since we know that the year will be four characters in size

    char year[5] = ""YYYY"";

Why 5 ? Because there will be FIVE elements in this array. The first four are the letters ""YYYY"". And the fifth will be the NUL character (all 0 byte) which terminates the string. Note that the proper term for this character of all 0 bytes is NUL with one L

As you just saw

This is important, we need an array with 9 elements. 

Notice that for the year array I set this to YYYY temporarily and we will replace those Ys with the actual numbers later. It is always good to initialize any variable

Now

    char month[3] = ""MM"";
    char day[3] = ""DD""; 

Notice again I put enough room for a \0 terminating character. Just to see how this works

    printf(""The Year is: %s and the Month is: %s and the Day is: %s \n"", day);

Output:

    The Year is: YYYY and the Month is: MM and the Day is: DD 

These arrays: year

1. We have a string of some data format which really contains 3 different bits of information.
2. We plan to ""understand"" those pieces. 
3. Therefore

Now

    year[0] = *my_pointer;         // first digit; same thing as *(my_pointer + 0)
    year[1] = *(my_pointer + 1);     // second digit of year
    year[2] = *(my_pointer + 2);     // third digit
    year[3] = *(my_pointer + 3);     // fourth digit

We do not need to write `year[4] = '\0'` because it has already been done. How was it done? When we wrote the string ""YYYY"" C automatically put a NUL at the end. Think of this process as simply replacing the four Ys with the 2009 in the date string. Make sure you understand the process of how we used the pointer to assign values to the individual characters in the array.

Notice that rather than actually move the pointer

saying `*(my_pointer + 3)` is just like saying ""Whatever is at the memory address in (`my_pointer + 3`). So if my_pointer was the memory address eight

Now

    month[0] = *(my_pointer + 4);
    month[1] = *(my_pointer + 5);

Finally

    day[0] = *(my_pointer + 6);
    day[1] = *(my_pointer + 7);

Notice that each array starts with ZERO in brackets. That is to say

1. When you define the array
2. When you use the array, we start at 0 and count from there.

And we are done. Now I have shown you the first example of how you can use a pointer to truly ""see"" data that is more complex than a simple text string.

Now

    printf(""The Year is: %s and the Month is: %s and the Day is: %s \n"", day);

Here is the completed program which illustrates this lesson:
----
    #include &lt;stdio.h&gt;

    int main() {

        char date[]   = ""20091005"";

        char year[5]  = ""YYYY"";
        char month[3] = ""MM"";
        char day[3]   = ""DD"";

        char *my_pointer = date;

        year[0] = *(my_pointer);
        year[1] = *(my_pointer + 1);
        year[2] = *(my_pointer + 2);
        year[3] = *(my_pointer + 3);

        month[0] = *(my_pointer + 4);
        month[1] = *(my_pointer + 5);

        day[0] = *(my_pointer + 6);
        day[1] = *(my_pointer + 7);

        printf(""The Year is: %s and the Month is: %s and the Day is: %s \n"", day);

        return 0;
    }

----
Please ask questions if any of this is unclear to you before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9r1y2/test_of_lessons_50_through_59/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9r12o/lesson_59_introduction_to_data_structures/
1254161471.0,9ovi4,Lesson 21 : The Basics of Numeric Data Types in C.,CarlH,183,95,96,"Even though this lesson concerns the C programming language

----

In previous lessons we have learned about many of the different ways you can represent a number as binary.

We have looked at integers, and we have some understanding of fractional numbers and how they are stored in binary. 

We also learned that to store a number in binary, we are limited to numbers no larger than fifteen. 

However

    -7 to +7

So when storing a number in your computer

1. How much space will the number occupy in memory?
2. What kind of number? 

For example, or a fractional number. All of these would be stored differently in binary as you have learned in previous lessons.

Every programming language has a way for you to specify the size in bits that a number will occupy

In C

* **int** : Just a normal integer
* **signed int** : Same as the above.
* **unsigned int** : Same as an integer
* **float** : Will support fractional values

[Edit: fixed signed/unsigned int definitions]

Now

You need to memorise these data types: **int, float** so that you will recognize and understand them when you encounter them later.

Even though we are talking about the C language

Every compiler is set to allocate a certain number of bits for each data type

By specifying the type of data (int, short, etc) you are able to specify the different kinds of numbers you might want to store. 

Now

    unsigned short int total = 5;

It won't be a mystery to you anymore. 

----
Please ask any questions and be sure to master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9ow85/lesson_22_the_char_data_type_and_the_basics_of/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ovi4/lesson_21_the_basics_of_numeric_data_types_in_c/
1254957759.0,9ruyf,Lesson 66: Creating Two-Dimensional Arrays Part Two,CarlH,91,5,44,"In the last lesson I explained the basic structure of arrays and how they are implemented in memory. In this lesson I am going to show you how to actually create and initialize them.

Lets suppose that we want an array that will contain ten words. Each word will be a maximum of 9 characters (including the string termination character

Here is how we would do this:

    char first_2d_array[10][9];

Now

Now

    first_2d_array[0] = ""One"";

But you cannot. C understands ""One"" to mean a string of text

There are effectively two ways to do this. The hard way

First

    first_2d_array[0][0] = 'O';
    first_2d_array[0][1] = 'n';
    first_2d_array[0][2] = 'e';
    first_2d_array[0][3] = '\0';

Thankfully

There is a function called strcpy() which is built into C

The syntax for strcpy() is fairly simple. It takes two parameters. The first parameter is where you are putting the string. The second parameter is the string itself.

So

    strcpy(first_2d_array[0]

And that is all I have to do. Can you do it without using the built in strcpy function? Sure. But this is much easier. If you really wanted to

    char *tempstring = ""One"";
    int i = 0;

    for (i = 0; i &lt; 4; i++) {
        first_2d_array[0][i] = *(tempstring + i);
    }

Just a quick review. Keep in mind we are creating a char pointer to a *string constant* ""One"". We are *not* storing the string ""One"" inside a pointer. Also, n, e, and \0. 

So it is *not* the case that you *must* use strcpy() to copy a string into an array. However

The first parameter is *where* you want to put the string. The second parameter is the string itself.

Now

Because part of this course is about showing you the thought processes that go into programming in general

First

    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]
    strcpy(first_2d_array[0]

Now

    strcpy(first_2d_array[0]
    strcpy(first_2d_array[1]
    strcpy(first_2d_array[2]
    strcpy(first_2d_array[3]
    strcpy(first_2d_array[4]
    strcpy(first_2d_array[5]
    strcpy(first_2d_array[6]
    strcpy(first_2d_array[7]
    strcpy(first_2d_array[8]
    strcpy(first_2d_array[9]

If this wasn't a Reddit text-box

Now remember that each of these strcpy() operations are going to be taking into account the NUL termination character. Why? Because we are giving it double quoted strings as a 2nd parameter. A double quoted string has a NUL termination character automatically at the end.

So now, but why not just have a for loop execute ten times?

    int i=0;
    for (; i &lt; 10; i++) {
        printf(""String #%d is %s \n""
    }

Here is the final program so you can experiment with it:
----
    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

    int main(void) {

        char first_2d_array[10][9];

        strcpy(first_2d_array[0]
        strcpy(first_2d_array[1]
        strcpy(first_2d_array[2]
        strcpy(first_2d_array[3]
        strcpy(first_2d_array[4]
        strcpy(first_2d_array[5]
        strcpy(first_2d_array[6]
        strcpy(first_2d_array[7]
        strcpy(first_2d_array[8]
        strcpy(first_2d_array[9]

        int i=0;
        for (; i &lt; 10; i++) {
            printf(""String # %d is %s \n""
        }

        return 0;
    }
----
Notice with the for loop I did not put anything in the initial state. I just put a single semicolon. This is because I already established the initial state above the for loop.

One more note. Just as we have to include stdio.h for printf() and related functions

----
Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9s7qd/lesson_67_review_of_pointers_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ruyf/lesson_66_creating_twodimensional_arrays_part_two/
1254328870.0,9pkde,Lesson 34 : Assigning a value to a pointer.,CarlH,172,88,34,"As we discussed

Lets suppose we want to create a pointer that will ""point"" to an `unsigned short int`. In other words

To do this you would write:

    unsigned short int *some_pointer;

This creates a pointer called ""some_pointer""

Right now of course

To make this possible

    unsigned short int height = 5;
    unsigned short int width = 10;

    unsigned short int *my_pointer;

Notice I did *not* assign a value to the variable ""`my_pointer`"". What you should understand at this stage is that ""`my_pointer`"" is a variable designed to hold the *memory address* of *any* `unsigned short int`. We have not given it a value yet.

Remember that a pointer is *useless* if it does not contain a memory address. 

Lets say that we want to give the pointer ""`my_pointer`"" the value of the memory address for the variable ""width"" in our above example. This means we need to have some way that we can write *this* line of code:

    my_pointer = ""address of"" width;

This is not actual code

In other words

Now

    my_pointer = &amp;width;

Believe it or not, you simply put this. Note that both of the below lines are exactly the same, white space doesn't matter:

    pointer = &amp;variable;
    pointer = &amp; variable;

This literally translates to:

    pointer = the memory address of ""variable"";



Why do we want to do this? Because now we can look at that memory address, but we can do that already without pointers."" 

Yes, not simply an `int` or a `char`. A large data structure could be music, or graphics, or something else. 

There is no data type built into C or any language for something so complex. Therefore

----
Please feel free to ask any questions before proceeding to: 

http://www.reddit.com/r/carlhprogramming/comments/9plo8/lesson_35_getting_the_value_that_was_stored_at_a/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pkde/lesson_34_assigning_a_value_to_a_pointer/
1255119607.0,9sjii,Lesson 77 : Introducing Memory Allocation using malloc(),CarlH,90,5,58,"In the last series of lessons I used an array in order to allocate space for something I needed. This is

There are a variety of problems with that approach. One of the biggest problems is that sometimes you do not know just how much space you have to allocate. Let's suppose you are writing an application and you need to allocate space to hold the document someone is working on. 

Whenever we refer to the process of allocating memory while a program is running

You should see that this is a rather fundamental capability that is needed for any programming language. Some do this behind the scenes

In C

malloc() will grab however many bytes we tell it to. So for example:

    malloc(24);  &lt;--- Reserves 24 bytes for us to do what we need to do.

We still do not have all that we need. Knowing that there are 24 bytes of memory available for our use is good

Somewhere in memory there are 24 bytes that we can use, what are we talking about? A pointer.

So you use malloc() with a pointer. It should make sense. I need to point some pointer at the 24 bytes in order to be able to use them. Doing so is very simple:

    char *my_pointer;

There we go. Now I have a pointer. Now where do I point it? I point it at the 24 bytes malloc() will set up

    char *my_pointer = malloc(24);

That is all there is to it. Now I have allocated 24 bytes of storage

I could put data into these 24 bytes in a variety of ways. One way is by just writing directly to the pointer offset I want. For example:

    *(my_pointer + 0) = 'O';
    *(my_pointer + 1) = 'n';
    *(my_pointer + 2) = 'e';
    *(my_pointer + 3) = '\0';

Are you starting to see the connection? 

These 24 bytes are just like any other. I have told C to reserve 24 bytes of memory for me to work with

It turns out that the example program in Lesson 76 will work just fine if you make two simple modifications:

    DELETE THIS LINE: char storage[] = ""12345678901234567890123"";

Then

    char *ptr = &amp;storage[0];

to:

    char *ptr = malloc(24);

One more note

    #include &lt;stdlib.h&gt;

If you do that

The last thing to know is that when you are done with the memory allocated

    free(ptr);

Remember that `ptr` is the pointer which points to our allocated memory.

Here is our final ""array simulation"" program

----

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

    int main() {

        // We need 24 bytes to hold a 4x6 array 
        char *ptr = malloc(24);

        // array[0] is the word ""One""   
        *(ptr + (6*0) + 0) = 'O';
        *(ptr + (6*0) + 1) = 'n';
        *(ptr + (6*0) + 2) = 'e';
        *(ptr + (6*0) + 3) = '\0';

        // array[1] is the word ""Two""   
        *(ptr + (6*1) + 0) = 'T';
        *(ptr + (6*1) + 1) = 'w';
        *(ptr + (6*1) + 2) = 'o';
        *(ptr + (6*1) + 3) = '\0';

        // array[2] is the word ""Three"" 
        *(ptr + (6*2) + 0) = 'T';
        *(ptr + (6*2) + 1) = 'h';
        *(ptr + (6*2) + 2) = 'r';
        *(ptr + (6*2) + 3) = 'e';
        *(ptr + (6*2) + 4) = 'e';
        *(ptr + (6*2) + 5) = '\0';

        // array[3] is the word ""Four""  
        *(ptr + (6*3) + 0) = 'F';
        *(ptr + (6*3) + 1) = 'o';
        *(ptr + (6*3) + 2) = 'u';
        *(ptr + (6*3) + 3) = 'r';
        *(ptr + (6*3) + 4) = '\0';

        // Print the four words
        printf(""The 1st string is: %s \n""
        printf(""The 2nd string is: %s \n""
        printf(""The 3rd string is: %s \n""
        printf(""The 4th string is: %s \n""

        // Free up our allocated memory
        free(ptr);

        return 0;
    }


----

Remember that malloc() doesn't actually set the bytes it allocates to 0 or anything

Also

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sua0/lesson_78_introduction_to_data_structures_in_c/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sjii/lesson_77_introducing_memory_allocation_using/
1254873946.0,9ribz,Lesson 63 : The Basics of Algorithm Design Part Four,CarlH,90,2,20,"In this concluding lesson of our four-part series on Algorithm Design

First
----
        Figure (a)

        for (i = 0; i &lt; 4; i++) {
            if (i &lt; 2) {
                day[i]   = date[i+6];
                month[i] = date[i+4];
            }

            year[i] = date[i];
        }

----

Now


                Figure (b) : First iteration

                day[0]   = date[6];          
                month[0] = date[4];
                year[0]  = date[0];

----

And here we are. Looking at the for loop itself

The first question to consider when advancing from one iteration to the next is this: What variables have changed, and it has increased by one.

The second question to consider is this: Are there any lines of code from the first iteration that will not execute this time? Also

In this case

Therefore

                Figure (c) : Second iteration

                day[1]   = date[7];          
                month[1] = date[5];
                year[1]  = date[1];

Do you see that all we really did was to increase the numbers by one? Recall how the string `date` looks in memory:

    Y Y Y Y M M D D
    0 1 2 3 4 5 6 7

So the second iteration reads like this:

After setting the first character for year, now we: 

1. Set character #1 of day to character #7 of date. 
2. Set character #1 of month to character #5 of date.
3. Set character #1 of year to character #1 of date.

Remember that when you are talking about an array index or a pointer offset

So now the second iteration should make sense. You should understand at this point that *two* iterations is all it takes to set both day *and* month. After this second iteration

Now

The answers are: The variable i increases by one. In this case

                year[2]  = date[2];

Now

                year[3]  = date[3];

Now we are done. We have officially processed all of the string YYYYMMDD. Now lets put it all together:
----
The fully expanded for loop:

    // First iteration (Processes 3 characters of YYYYMMDD)

    day[0]   = date[6];          
    month[0] = date[4];
    year[0]  = date[0];


    // Second iteration (Processes 3 more characters)
               
    day[1]   = date[7];          
    month[1] = date[5];
    year[1]  = date[1];


    // Final two iterations process remaining two characters

    year[2]  = date[2];
    year[3]  = date[3];

----

Notice that our for loop expands to only eight actual statements

Keep in mind that the purpose of these four lessons was to introduce you to algorithms in general. There are many ways to accomplish similar tasks

There are a wide variety of pre-built functions which will do this for you easily

----


Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9rrha/lesson_64_introducing_multidimensional_arrays/
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ribz/lesson_63_the_basics_of_algorithm_design_part_four/
1254948357.0,9rtl9,Lesson 65 : Creating Two-Dimensional Arrays Part One,CarlH,84,0,25,"Take your time through this lesson. Make sure you are here only if you have already mastered all previous lessons.
----
In the last lesson I gave you a general overview of multi-dimensional arrays and how they are implemented in memory. Each programming language implements arrays somewhat differently

Before we begin

To create a 2d array of these six words (meaning, I have to specify this. Here is how I do so :

    char first_array[6][6];

We will go over the details of how this works during this lesson

----

In the last lesson I showed you that you can start at the ""first letter"" of a given word

Let me illustrate this again:

    ""RedditProgrammingClasses""

Here are three unique strings in memory. Each of them starts at a different memory address. The first word starts at position 0. The second word starts at position 6

There is a problem with this approach. It works as long as you know exactly where in memory each word starts. However

1. The first word starts at position 0
2. The second word starts at position 28
3. The third word starts at position 40
4. The fourth word starts at position 44

There is nothing uniform about this. Because of that

    ""OneTwoSix""

Here we have three strings of text that are of uniform length. How many numbers do we have to keep track of to know the starting location of each one? Only one number. Watch:

1. The first word starts at position 0.
2. The second word starts at position 3. 
3. The third word starts at position 6.

Where would the fourth word start at if we kept our words of uniform length? It would start at position 9. And so on.

In other words, second, etc) and we get the correct offset.

1. The first word is at position 0 which is: 3*0
2. The second word is at position 1 which is: 3*1
3. The third word is at position 2 which is: 3*2
4. The Nth word is at position N which is: 3*N

So you can see that mathematically it is very convenient to keep each word in our array of uniform length. We call such ""words"" in general

This way we can find the start of any member element by simply multiplying the length of each element times the ""element number"". For example, it would start on byte #20. The first element would start at byte #0 and span until byte #9. The second element would start at byte #10 and span until byte #19. The third element would span from byte #20 until byte #29.

Now

    ""RedditProgrammingClasses"" will become:

    Redditxxxxx
    Programming
    Classesxxxx

    Which in memory will really be: RedditxxxxxProgrammingClassesxxxx

I added x's at the end of each word so that now it is proper length. Notice that this has the effect of lining up the words in a grid. This means that we can now quickly reach the start of any word in the array

So here you can see the first issue concerning arrays in general. Every member element of the array must be the same length. 

Now

1. The size of any element of the array (it should be uniform).
2. The total number of elements.

By just multiplying these together

First

    char string[] = ""Hello"";

Total number of elements? 6 (including the termination character). Total size of each element? 1. Total size of array = 1*6 = 6. Easy.

Now let's create a two dimensional array filled with ""Hello"" (or equally sized words). Let's suppose it has 3 elements. 

How many elements? 3. The total size of each element? 6 (We are using ""Hello"" sized words). Total size of our 2d array? 3*6 = 18. In other words

What about a 3d array with 2 elements? Well

Therefore

As I just explained

Now

First

    RedditxxxxxProgrammingClassesxxxx

That is a 2 dimensional array. A three dimensional array would be an array of these. For example:

    RedditxxxxxProgrammingClassesxxxx
    RedditxxxxxProgrammingClassesxxxx
    RedditxxxxxProgrammingClassesxxxx

I left the words the same so it is easier to understand. Here we have three elements of a three dimensional array. Why is it a 3 dimensional array? Because each element is a two dimensional array.

Now you should be able to see that if we lined them in memory as a single string: we will have one offset to reach the next 3-dimensional array member of our array

For example

    string[2][2][2]

Remember. We start counting array indexes at 0. 0 means first.

The first [2] means ""third element"" of our 3d array. In other words

    string[ ( 2*size_of_3d_element ) + ( 2*size_of_2d_element )  + 2]

How big is a 3d element? How many characters are in the sample 3 rows I gave above? Well

In other words

So you should realize something by now. To create *any* array you *must know the size* of each element of that array. If I want to store six words in an array:

    One
    Two
    Three
    Four
    Five
    Six

I *must* know the maximum size I will need. This will mean the size of the biggest element

Now, each one a word with up to six characters), I have to specify this. Here is how I do so :

    char first_array[6][6];

This creates a 6x6 array. Six elements. Each element six characters (max). What is the total size of the array? 36. 

In the next lesson we will explore this further

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9ruyf/lesson_66_creating_twodimensional_arrays_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9rtl9/lesson_65_creating_twodimensional_arrays_part_one/
1254742749.0,9qxxw,Lesson 58 : Using bit masking to change data,CarlH,98,17,28,"This is the logical continuation from the previous lesson. Just as you can use a bit mask to check if a certain bit (or bits) are set

For example

Let's imagine this byte:

    0000 0010 &lt;--- Number 2 (Our ""target"")

This is the number two. We know from our earlier lessons that the character two would have the third and fourth bit turned on

    0011 0010  &lt;--- Character '2'

There are a variety of ways to do this

First

    0011 0000

OR *will not* turn off any bits

Now lets apply the bit mask using OR:

    0000 0010 &lt;--- Number 2 (Our ""target"")
    0011 0000
    ---------
    0011 0010 &lt;--- after OR

In C

Do not confuse this with using || in a conditional statement. 

This is the same reasoning we saw in the last lesson using &amp; instead of &amp;&amp;.

Now lets see this in action.

    char my_number = 2;

    my_number = my_number | 0x30; // &lt;--- 0x30 is: 0011 0000

    printf(""We can now print this number as a character: %c""

If we wanted to print a '2' without actually changing the contents of the byte

    char my_number = 2;

    printf(""We can now print this number as a character without changing it: %c""

The above code works because printf() %c expects a character. (`my_number | 0x30`) *is* a character. 

Remember that this only works for numbers 0 through 9. 

What would have happened if we had started with a character 0 through 9 instead? Let's see:

    0011 0010 &lt;--- Character '2' (Our ""target"")
    0011 0000
    ---------
    0011 0010 &lt;--- after OR

We will get '2' as a result. In other words

Notice that you could *not* use OR in order to ""see"" a bit like we did with AND in the last example. Similarly

    0100 0001 &lt;--- 'A'
    0010 0000 &lt;--- bitmask to turn the capital letter to lowercase
    ---------
    0000 0000 &lt;--- Result using AND. All we get is ZERO

Now

    0100 0001 &lt;--- 'A'
    0010 0000 &lt;--- bitmask to check if it is capital or lowercase
    ---------
    0110 0001 &lt;--- Result using OR.

Using OR

In other words

with AND

OR is best suited to unconditionally turning bits ON (setting them to 1)

AND is best suited to unconditionally turning bits OFF (setting them to 0)

What if we want to alternate a bit from 1 to 0 or vice versa? For this

The idea of exclusive or is ""It can be one, except that 1 XOR 1 = 0. Everything else is the same. 

Compare these two truth tables between OR and XOR:

    0 OR 0 = 0     0 XOR 0 = 0
    0 OR 1 = 1     0 XOR 1 = 1
    1 OR 0 = 1     1 XOR 0 = 1
    1 OR 1 = 1     1 XOR 1 = 0 &lt;-- the only difference

This difference exists for a key reason. Observe what happens if we take our capital 'A' and apply our bit mask using XOR instead of OR.

    0100 0001  &lt;--- 'A'
    0010 0000  &lt;--- bitmask
    ---------
    0110 0001 &lt;--- 'a' is the result of XOR

Notice there is *no difference* between using XOR and using OR in the above example

    0110 0001  &lt;--- 'a'
    0010 0000  &lt;--- bitmask
    ---------
    0100 0001 &lt;--- 'A' is the result of XOR

We flipped it back to 'A'. In other words, since the 3rd bit was turned on, XOR toggled the third bit on and off.

Notice that because we get a different result when we start with 'A' vs 'a'

The only missing piece of the puzzle now is

1. &amp; is AND
2. | is OR (inclusive OR)
3. ^ is XOR (exclusive OR)

The final notes I would add are this: When you are looking at source code that you will encounter, vs OR, vs XOR. 

In summary, unset, and toggle any bit in any data you wish. 

----
Please ask questions if any of this material is unclear before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9r12o/lesson_59_introduction_to_data_structures/

 
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qxxw/lesson_58_using_bit_masking_to_change_data/
1254680090.0,9qr1h,Lesson 54 : Introducing loops,CarlH,103,19,38,"The last several lessons have explained how you can use conditional statements (like the if statement) to ""skip over"" code. We know that this works by trying to evaluate an expression as true or false. If it evaluates as true

For example:

    if (height == 5) {
        ... some code here ...

    } &lt;--- end of block of code

    ... rest of program here ...

Intuitively, otherwise, go to ... rest of program here ...

However, then you jump over the block of code. 

It is important to understand that *all* conditional statements have a built in goto statement that you cannot see. That goto statement will *jump over* the block of code when the conditional statement evaluates to false. If it evaluates as true

For example:

    int height = 5;

    if (height == 5) {
        printf(""Hello Reddit! \n"");
    }

If height is equal to 5

     ""We *might* want to jump over this printf() statement. do so
    if height is NOT equal to 5.""

Now

In our last example we saw a simple example of a loop. The example we looked at was an infinite loop where the last instruction simply said to start over. Now lets look at a more concrete example.

The most basic type of loop is the ""While"" loop. The way it works is very simple: You have a block of code and a conditional statement. The last line in the block of code is a JUMP back to the conditional statement.

Lets see this in action.

    int height = 5;

    while (height &lt; 10) {
        printf(""Hello Reddit! \n"");
        height = height + 1;
    }

The conditional statement here is ""height &lt; 10"". 

Now

    start_of_loop:
        compare height and 10
        if height is greater than or equal to 10: goto end_of_loop  &lt;--- yes! ""greater than or equal to""

        printf(""Hello Reddit! \n);
        increase height by one.

        goto start_of_loop

    end_of_loop:

Did I make a mistake? The original statement said ""height &lt; 10""

The default behavior of your CPU *is* to proceed. We use a conditional statement only to change that default behavior. To have a machine code instruction that says ""Go into the block of code if this is true"" is just a waste of resources

Therefore

The way you would intuitively read this code:

    while (height &lt; 10) {
        ...
    }

is: ""While the variable height is less than ten

    compare height to ten
    goto end_of_block if height &gt;= 10
    ... otherwise we will execute these instructions ...
    end_of_block:

With a while loop, then the default behavior is to execute the instructions inside the block of code again.

Now lets look again at this example:

    int height = 5;

    while (height &lt; 10) {
        printf(""Hello Reddit! \n"");
        height = height + 1;
    }

So here is what happens: 

    Lets check to see if we jump over the block of code. 
    Do we? No
    Therefore we proceed. Now we execute our printf() function. 
    Then we add one to height. 

Now what? 

Since we have reached the } which defines the end of the block of code, exactly as written, starting with the conditional statement. 

Once we have done this five times, the conditional statement will now evaluate like this: ""Height is now no longer less than 10. Therefore, *jump over* the block of code."" And thus ends our loop.

In this lesson I introduced you to the first and simplest kind of looping statement


----
Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9qrj2/lesson_55_introducing_custom_functions/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qr1h/lesson_54_introducing_loops/
1254167491.0,9owj2,Lesson 23 : The numbers on your keyboard as characters.,CarlH,165,85,24,"This is an important lesson for a number of reasons. First

It turns out that just as capital and lowercase letters are encoded in a special binary format, and the rules for this process:

As in the last table

    0011 0000 = 30 = '0'
    0011 0001 = 31 = '1'
    0011 0010 = 32 = '2'
    ...
    0011 0111 = 37 = '7'
    0011 1000 = 38 = '8'
    0011 1001 = 39 = '9'

Here you should already be able to see the structure of the number characters. All of them start with 0011 (3 in hex)

Lets review this in the context of capital and lowercase letters:

&gt; Capital letters: 

&gt; **010**0 0001 ('A') through **010**1 1010 ('Z')

&gt; Lowercase letters: 

&gt; **011**0 0001 ('a') through **011**1 1010 ('z')

&gt; Numbers: 

&gt; **0011** 0000 ('0') through **0011** 1001 ('9')

This is just about all the ASCII you will ever have to know. The most important thing to understand in this lesson by far is this:

**The character '4' is not at all the same thing as the number 4**

And this goes for all characters.

However

    0011 1000

Is the character for the number '8', 

    0011 1000 

would become simply: 

    0000 1000 

which is the actual number 8.

----

Please note that this lesson applies to ASCII. As I stated in the last lesson, and ASCII is one way this is done. We will explore this in greater detail later.

----
Please feel free to ask any questions and make sure you have mastered this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9p4h2/lesson_24_about_maximum_values_for_unsigned/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9owj2/lesson_23_the_numbers_on_your_keyboard_as/
1254239085.0,9p6me,Lesson 26 : Introducing variables.,CarlH,167,86,50,"We have learned previously that you can store all sorts of data in memory, etc.)

We have also learned that every programming language gives you the ability to give simple plain-English names to any data that you store in memory. Now we need to take this knowledge to the next level.

Whenever you create data and give it a simple name, and that I wish to assign it some value like 5. I have now created a variable.

Lets suppose I want to do exactly this:

First, and it is positive - so a ""short unsigned int"" makes perfect sense. Now, I have to give it a name. I will call it ""total"". 

Now I have to give it some value. Here is how I do all of these steps:

    short unsigned int total = 5;

Now

1. What is the variable's name? **total**
2. What is the data type for this variable? **unsigned short int**
3. Can negative numbers be stored in this variable? **No**

If you have been following all the lessons up until now well enough, that is sixteen bits. We know that the binary for 5 is 0101. If we assume that this variable would take up two bytes, then it would look like this in memory:

    0000 0000 0000 0101

Notice all the unused space. Because 2 bytes can hold up to 65

Since I have assigned this variable two-bytes,535 , then as we have seen in earlier lessons the result will be a *wrong answer* because no value that big can fit in 16 bits.

Always remember this: From the time you create a variable through to the end of a program

----

Please be aware that ""unsigned short int"" is not required to always take up exactly two bytes. This as well as the size of data types in general may differ among C compilers. In this lesson

---- 

Please feel free to ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9p71a/lesson_27_the_connection_between_function_return/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9p6me/lesson_26_introducing_variables/
1254765531.0,9r1yr,Test of Lessons 50 through 59 [Answers],CarlH,93,11,24,"----
**True or False**

1. If a conditional statement such as an if statement contains multiple expressions
2. Using a goto statement in C is good practice and should be encouraged whenever possible.**False**
3. The machine-code equivalent of a goto statement is built into the architecture of your CPU chip.**True**
4. All conditional statements have a built in ""goto"" statement that you cannot see. **True**
5. You can use the OR bitwise operation to test if a bit is turned on by using a bitmask where the bit you want to test is set to 1. **False**

**Fill in the blank**

1. In a conditional statement, I would write: `_____`. **if (height == 3 &amp;&amp; width == 4) {**
2. In a conditional statement, I would write: `_____`. **if (height == 3 || width == 4) {**
3. When you use a goto statement (JMP in assembly language)
4. An `_____` is used to describe a process which repeats the same instructions over and over forever. **Infinite Loop**
5. 0011 ^ 1110 is: `____`. **1101**
----
If you missed any questions or if anything is unclear

http://www.reddit.com/r/carlhprogramming/comments/9reqb/lesson_60_the_basics_of_algorithm_design_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9r1yr/test_of_lessons_50_through_59_answers/
1341730945.0,w7pqm,[CarlHProgramming] : New video lessons!,CarlH,91,13,12,"I have begun going through the existing lessons and adding audio/video (youtube) when possible. I have already completed several audio lessons and uploaded new video lessons. 

Rather than post each video as its own post

#1. [Lesson 2.1 : Introduction to binary](https://www.youtube.com/watch?v=0qjEkh3P9RE)

#2. [Lesson 2.3 : Introduction to hexadecimal](https://www.youtube.com/watch?v=m1JtWKuTLR0)
----
(The videos below are brand new and do not correspond to existing lessons)
&gt; #1. [Adding two binary numbers](http://www.youtube.com/watch?v=jB_sRh5yoZk)
&gt;
&gt; #2. [Subtracting two binary numbers](http://www.youtube.com/watch?v=S9LJknZTyos)
&gt; 
&gt; #3. [Multiplying two binary numbers](https://www.youtube.com/watch?v=QW0XNZPyWUk)
&gt;
&gt; #4. [Dividing two binary numbers](https://www.youtube.com/watch?v=SqIpxX14nUs)
----
In addition to video

(More coming soon)",,t5_2r81y,1341761190.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/w7pqm/carlhprogramming_new_video_lessons/
1254241184.0,9p71a,Lesson 27 : The connection between function return values and variables.,CarlH,162,81,151,"This is a very important lesson

If you have observed the lessons up until now, we gave it a data type just as if it was a variable. We wrote:

    int main(void) {

We learned that any function can return a value. While I have not officially addressed it in a lesson until now

Every function that returns a value always returns that value according to a specific data type. That means that the same data types available for creating variables such as short, etc. are also the same data types available for defining function return values.

Lets examine the following code:

    printf(""Hello Reddit!"");

We know that `printf()` returns a value, because the function `printf()` has a return value of type `int`. Remember also that ""`int`"" is actually ""`signed int`"".

Lets imagine I create a variable of type `signed int`:

    signed int total_characters = 0;

Now

In addition to this variable, it will return a ""`signed int`"" which will contain the number of characters that were printed.

What I want you to notice is this: The function `printf()` and the variable: `total_characters` are *compatible*. They *share the same data type*.

Whenever a variable is compatible with a function's return value

    total_characters

is defined as a ""`signed int`""

This is true for all variables and functions. If I create a variable like this:

    unsigned short int total = 5;

Then this variable

    char some_character = 'a';

Then this variable can store the return value of *any* function whose return type is ""`char`"". 

This is only half the story however. This next part is equally important:

Whenever a function returns some value of a certain data type

In other words

    int cool_trick = 0;
    cool_trick = 5 + printf(""Something"");

Now the integer ""`cool_trick`"" will contain the value of 14. That is because `printf()` returns a 9 since it prints 9 characters. The 5 and 9 are added to get 14. 

Notice also that ""Something"" still gets printed. This is because the `printf()` function still executes

I encourage you to experiment with this. Just take the first program you wrote

You can use printf() to print an integer like this:

    printf(""Some integer is: %d""

The %d gets automatically replaced by whatever `variable_name_here` is. For example:

    int total = 5;
    printf(""The total is: %d""

Remember

----

This lesson is for illustrative purposes. There are certain requirements as to what data types you can and should use as the return type for functions. For example

----
Please feel free to ask any questions

http://www.reddit.com/r/carlhprogramming/comments/9p7yd/lesson_28_about_terminating_strings_of_text_and/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9p71a/lesson_27_the_connection_between_function_return/
1276581072.0,cf3ns,"[New Lesson Published] Course 2, Unit 4, Lesson 14: Interpreting result codes",CarlH,82,5,False,
1254673769.0,9qqc8,"Lesson 53 : About ""blocks"" of code.",CarlH,106,26,12,"In the last lesson I explained that goto statements are done for you behind the scenes in most languages. Now I am going to explain how this is actually done.

First of all

    Figure (a)

    int height = 5;
    
    if (height == 5) {
        ... some code ...
    }

Every instruction in Figure (a) actually will have a memory address where that instruction lives. Therefore, and so on. 

The way this actually works in machine code is a bit more complex

What you may be wondering at this point

The answer is that these characters define memory addresses inside of the final machine code that will be your executable program. In other words

Consider this code:

    if (height == 5) 
    {
        ... some code ...
    }

Do not worry that I changed the way the curly braces are formatted. Instead

In other words

    if (height == 5)
        start_of_code:
            ... some code goes here ...
        end_of_code:

Notice I just replaced the braces with a label

    compare height to 5
    Check the zero flag.
    If the zero flag is set to 1 (that means height is equal to 5) then *goto* start_of_code.

    If the zero flag is set to 0 (that means height is not equal to 5) then *goto* end_of_code.

Now

We do not need both of these ""if"" statements. We only need one. We just need one that says *skip over*. 

Consider this same example again:

    if (height == 5)
        start_of_code:
            ... some code goes here ...
        end_of_code:

Which translates to:

    compare height to 5
    Check the zero flag.

    If the zero flag is set to 0 (that means height is not equal to 5) then *goto* end_of_code. 
        This means to skip over: ... some code goes here ...

I took out the instruction which went to `start_of_code`. Why? Because that is what would have happened anyways. In other words

Whenever you have a section of code that is defined within curly braces like { } we call that a block of code. A block of code is best understood as two labels one of which indicates the start of the block

Not all languages define blocks of code in this way. Some define blocks of code using simple indenting. Python is one such language. In Python

    Python Example:

    if height == 5: 
        ... this is a block of code that will execute ...
        ... only if height is equal to five ...

    ... the rest of the program goes here ...

Notice that we do not specify either a { or a }. We do not need to. Python is designed to understand blocks of code by simply indenting the block of code. This is a good idea since in C as well as most languages

Remember that *all* programming languages can only create machine code understandable by your CPU. No programming language can do something that another cannot. All are limited to the machine code instructions your CPU can execute. Once you learn how to program in C

Throughout this course we will look at the various ways that these same operations and concepts are implemented in a variety of languages. 

----
Please ask any questions if any of this is unclear to you. Be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9qr1h/lesson_54_introducing_loops/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qqc8/lesson_53_about_blocks_of_code/
1254669636.0,9qpv3,"Lesson 52 : Introducing the ""goto"" statement",CarlH,103,26,18,"What? You have probably heard that using ""goto"" is one of the worst practices in programming. This is largely true. Why therefore am I spending an entire lesson teaching this? Well

1. Although it is poor practice in most languages
2. It will help you to understand future lessons at a deeper level.
3. It will help you should you encounter this in some program someone else has written.

Now I want to add on a note to #3. You will *never* need to use a ""go to"" statement in C or most languages. You never should either. There are always better ways to achieve the same purpose. 

All of that said

Now that I have introduced conditional flow statements

Consider this code:

    int height = 1;

    if (height == 5) {
        printf(""This gets skipped!);
    }

    ... rest of program goes here ...

What is really happening here? At a machine code level, if the result is anything other than zero, what happens? It *jumps over* the code inside the if statement.

How can your CPU ""jump over"" instructions? 

Recall from the lesson ""Programs are data too"" that a program is data that is stored in memory

Each machine-code instruction of any program occupies a set number of bytes, etc. 

To make this lesson even clearer

    ...
    1000 : 1100 1101 &lt;--- instruction pointer is pointing here
    1001 : 0010 0001
    1010 : 1100 1101  &lt;--- start of next instruction
    1011 : 0010 0000 
    ...

Do not worry about how this works or what it does. The point is

What you should notice here is that machine code looks just like anything else. These bytes could be characters

Each instruction is located at its own address in memory. Each time your CPU is about to execute an instruction

In other words

Imagine for example that we start at position 1000 (eight) in memory and start executing instructions one at a time until we get to position 1110 (fourteen). Lets suppose at position fourteen the instruction reads: ""Change the instruction pointer so that it points back at 1000"". What will happen? Well

For this next example

    ...
    1000 : Instruction 1 &lt;---------------------.
    1001 : Instruction 2                       |
    1010 : Instruction 3                       |
    1011 : Instruction 4                       |
    1100 : Instruction 5                       |
    1101 : Instruction 6                       |
    1110 : Set Instruction Pointer to 1000  ---'

Follow this in your mind. You will execute each instruction from 1 through 6, you will start all over from instruction 1.

Now to make this slightly more abstract, we can effectively write the following:

    label: 
        ... the six instructions go here...

    goto label;

The machine code instruction for this process is known as JUMP (JMP in assembly language). 

Do not try this, go back to instruction one, then execute the six instructions again, forever.

This has a name. Whenever this happens that the same instructions are executed over and over forever we call it an ""infinite loop"". We will talk more about loops and infinite loops in other lessons.

Why then use it at all? Because you can control it. Without it, instead of setting it to run forever, you can set it to execute a set of instructions a certain number of times - like 3 times. We will talk more about that in upcoming lessons.

Fundamentally what you have learned in this lesson is that there are mechanisms that make it possible to ""jump around"" in a program, or a ""Go to"" statement. We have also learned that this functionality is built right into your CPU chip. And finally, I have explained that you will never need to directly use this statement in most programming languages because that work is done for you behind the scenes.

----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9qqc8/lesson_53_about_blocks_of_code/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qpv3/lesson_52_introducing_the_goto_statement/
1254604615.0,9qk90,Lesson 50 : More on conditional flow statements.,CarlH,117,37,26,"You know from the previous lesson that evaluations of any test or comparison can only result in true or false

Let me put this into concrete terms. Imagine the following if statement:

if (height == 5) {

The expression between the parenthesis *will* evaluate to something. Always. There will be some state of the ""zero flag"" once it evaluates. It will either evaluate to a 1 (true) or it will evaluate to a 0 (false). 

Notice that there is an interesting correlation between logical truth and the zero flag. If the zero flag is set to 1, such as a comparison statement. Recall that if two things are compared (using subtraction) then the result will be 0 if and only if they are equal. The zero flag is set to 1 in this case, meaning ""The result was zero"", and also meaning ""true"".

The above is a simple example because it involves only one expression, such as an if statement. For example, I could write code that in English means: ""If height is five, and width is three"" which would look like this:

if (height == 5 &amp;&amp; width == 3) {

Here I have introduced some new C syntax. The &amp;&amp; when present in an if statement simply means ""and"". You do *not* put just one &amp; character

Now

It helps to think of the &amp;&amp; as saying: ""A new expression to be evaluated follows

In other words, zero flag is set), then and only then the next expression of ""is width equal to 3"" is evaluated. In this way every chain of the if statement is evaluated from left to right. The entire if statement will have the result of the *last* expression that was evaluated. 

As this gets evaluated

1. if (height == 5 &amp;&amp; width == 3) {
2. if (1 &amp;&amp; width == 3) {
3. if (1 &amp;&amp; 1) {
4. if (1) {
5. Final result = 1 = true.

It might sound like I am picking at straws

This is actually *very* important. Every extra expression in a conditional statement takes computing resources. Some such expressions will involve running functions

    Figure (a)

    int height = 5;
    int width = 3;

    if (height == 5 &amp;&amp; width == 3 &amp;&amp; printf(""1234"") == 4) {
        printf(""\nTest Finished"");
    }

Output:

    1234
    Test Finished

What you need to fundamentally understand here is that if you change any of the the three expressions in Figure (a) the if statement will fail. For example if you change height == 5 to height == 1, if statement will fail. Notice that if you change the text in the printf() in the if statement, that printf() will still execute, but not the one that says ""Test Finished"".

Keep in mind that when an if statement fails, at least *one* expression has been evaluated. If it fails on the first expression, the evaluation still took place. If it fails on the third expression being evaluated, that still means the first, second, and third evaluation took place. However, the fourth expression (if there is one) will not execute.

If for example

    int height = 5;
    int width = 3;

    if (height == 5 &amp;&amp; width == 1 &amp;&amp; printf(""1234"") == 4) {
        printf(""\nTest Finished"");
    }

What happens? Neither printf() statement will execute. Why? Here is what happens:

First, comparing the variable width and the value 1. Here the if statement fails. This means no further expressions will be evaluated. Once it has failed on *any* of its expressions, the entire if statement has failed and the final result will be ""false"". Because of this, the printf() statement inside the if() statement will not execute. This is extremely important, and you can use it to your advantage.

Whenever you have a series of comparisons to make, it will fail with the least cost of computing resources. 

I encourage anyone reading this lesson to experiment with the code in Figure (a) to see these concepts working for yourselves. 

This knowledge will enable you to make programs that are faster

----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9qoze/lesson_51_introducing_or_for_conditional_flow/


",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qk90/lesson_50_more_on_conditional_flow_statements/
1254148905.0,9ot7r,Test of Lessons 11 through 19 [Answers],CarlH,167,88,49,"If you missed any of these
----
**True or False**

1. Once a programming instruction is executed
2. As a programmer
3. (**C**) If I call the function printf() like this: printf(""Hello""); then the return value for the printf() function is the text ""Hello"". **False**
4. (**C**) In C
5. A ""sign bit"" can be set to 1 or 0 to indicate if a number is positive or negative. **True**

**Fill in the blank**

1. An ____________ is used by your CPU to keep track of the next programming instruction to be execute. **Instruction Pointer**
2. When you send extra information to a function
3. When two programming languages do the same thing in a slightly different way
4. A ____________ number is a number that can be positive or negative. **Signed**
5. If you count past the maximum value that can be held in a set number of bits


----
When you have fully reviewed and understood any questions you missed

http://www.reddit.com/r/carlhprogramming/comments/9ouzt/lesson_20_basics_of_fractional_numbers_in_binary/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ot7r/test_of_lessons_11_through_19_answers/
1282535710.0,d49uj,[CarlHProgramming] : Quick Update,CarlH,88,9,27,"First

Second, if anyone here knows otherwise, please let me know.

Meanwhile, that is quite a bit of work. 

Alternatively

Anyone else have any ideas?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/d49uj/carlhprogramming_quick_update/
1255229703.0,9sv62,Lesson 83 : Sample program illustrating data structures,CarlH,83,4,49,"First you will see the program itself

----

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;

    int main(void) {

        struct first_description {
            char first_word[7];
            char second_word[12];
            char third_word[8];
        };

        struct first_description *our_pointer = malloc( sizeof(*our_pointer) );

        char *charptr = (char*) our_pointer;

        strcpy(our_pointer-&gt;first_word
        strcpy(our_pointer-&gt;second_word
        strcpy(our_pointer-&gt;third_word

        printf(""The first word is: %s \n""
        printf(""The second word is: %s \n""
        printf(""The third word is: %s \n""

        printf(""\n"");

        printf(""Our data structure looks like this in memory: "");

        int i=0;
        for (; i &lt; 27; i++) {
                if ( *(charptr + i) == 0) {
                    *(charptr + i) = '$';
                }

                printf(""%c""
        }

        printf(""\n"");

        free(our_pointer);

        return 0;
    }

----

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;

These include files give us printf()

    int main(void) {

        struct first_description {
            char first_word[7];
            char second_word[12];
            char third_word[8];
        };

Above: Here is our structure description. We are not actually creating any data structure here

        struct first_description *our_pointer = malloc( sizeof(*our_pointer) );

We are allocating 27 bytes of memory using this malloc() statement. Then we are creating a special pointer called `our_pointer` which C understands points to *this kind* of data structure. After this line of code

        char *charptr = (char*) our_pointer;

I plan to scan our data structure to display the final memory contents at the end of this program. To do that

        strcpy(our_pointer-&gt;first_word
        strcpy(our_pointer-&gt;second_word
        strcpy(our_pointer-&gt;third_word

Here I am simply assigning the strings into the character arrays that are part of our data structure.

        printf(""The first word is: %s \n""
        printf(""The second word is: %s \n""
        printf(""The third word is: %s \n""

I am displaying the three words

        printf(""\n"");

        printf(""Our data structure looks like this in memory: "");

        int i=0;
        for (; i &lt; 27; i++) {
                if ( *(charptr + i) == 0) {
                    *(charptr + i) = '$';
                }

                printf(""%c""
        }

Now I have a for loop which will go through all 27 bytes and display the character represented. If it is a NUL character

        printf(""\n"");

Now I need to free the memory I allocated using malloc()

        free(our_pointer);

        return 0;
    }

----
Output:

    The first word is: Reddit 
    The second word is: Programming 
    The third word is: Classes 

    Our data structure looks like this in memory: Reddit$Programming$Classes$

----
Ask questions if you need to. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9svba/lesson_84_you_can_make_your_own_data_type_using/
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sv62/lesson_83_sample_program_illustrating_data/
1253887163.0,9o0yp,About Me,CarlH,434,357,42,"About Carl Herold

One question that everyone has (or that everyone should have) if they plan on taking this course is

**Who am I and what is my programming experience?**

I have been programming for over 15 years

I have written games and applications for a variety of operating systems including: DOS, and ""Web Applications"". 

Also, then in hexadecimal, and then in 1s and 0s simply because I was fascinated by it. For example INT 20, or CD20 (hex) is 1100110100100000 [Edited: Bah! INT 21.. INT 20.. what's the difference? :) ] - and this is the machine code that effectively means ""end the program"". There was a time I could write ""hello world"" in machine code, but I have since forgotten how (it involves a bunch of INT 21 calls going through the individual ascii for the letters).

The concept that 1s and 0s actually ""make things happen"" fascinated me

I have programmed in many languages and I will not list them all, Pascal, Assembly, TCL/TK, C, C++, PHP, JavaScript, and Python. About 5 years ago I made my own programming language

I have worked professionally as a programmer for at least 10 years, and building and maintaining my own projects. I have started several businesses in the last 10 years based on programs I have written. I am entirely self taught, as I never had an opportunity to go to college. 

**Why programming?**

I enjoy programming because of the freedom to solve problems and to create pretty much anything you want. I believe that it is impossible to obtain the full benefit from your computer if you do not know programming. A non programmer is limited to only the software they can find or buy

If you know how to program, and you are free to do whatever you want. There is also a great sense of satisfaction associated with successfully building something, and solving difficult problems. 

Please feel free to ask me any questions related to any of this.",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9o0yp/about_me/
1255408284.0,9tgdg,Lesson 88 : Introducing Pass by Reference and Pass by Value,CarlH,86,10,45,"

In the last example I showed you a function which received a pointer to a data structure

Well

    int height = 5;
    int *ptr = &amp;height;

    *ptr = 2;

What is height now? Height is set to 2. It is no longer set to 5. Why? Because by changing the actual data stored at the memory address

Therefore

There are two ways you can send something to a function. The first is called Pass by Reference. 

Consider the following program:

----

    #include &lt;stdio.h&gt;

    int main(void) {

        int height = 5;
        printf(""Height is: %d \n""

        change_height(&amp;height); // Pass by reference

        printf(""Height is now: %d \n""

        return 0;
    }

    int change_height(int *ptr) {
        *ptr = 2;
    }

Output:

    Height is: 5
    Height is now: 2

----

Notice therefore that the main() function (or any function) can simply send the memory address of any variable, etc. to a function. The function can then change the data in place at that memory address. This is because by sending the actual memory address where the data is located, any changes to that data become universal to anything else looking at that same memory address.

At the same time

    int some_function(int height
        return height*width;
    }

In this case, I am sending a *copy of them*. C will actually create a copy of these variables when they are sent to the function. These copies will of course reside at different memory addresses than the originals.

Now this is easy to remember:

1. If you send the memory address aka a pointer to a function
2. If you send the name of a variable to a function

We refer to #1 as ""Pass by Reference"". This means you ""pass"" an argument to a function by sending it the memory address. 

We refer to #2 as ""Pass by Value"". This means you ""pass"" an argument to a function by creating a copy of it.

Here is a program illustrating pass by value:

----

    #include &lt;stdio.h&gt;

    int main(void) {

        int height = 5;
        printf(""Height is: %d \n""

        wont_change_height(height);  // Pass by value

        printf(""Back in main() it is: %d \n""

        return 0;
    }

    int wont_change_height(int some_integer) {
        some_integer = 2;
        printf(""Inside the function height is now: %d \n""
    }


----

Notice that inside a function you can call a variable whatever you want. I can call it `height` before I send it

----

It is worth pointing out that in C, think of passing a pointer as a form of ""pass by reference"". However, remember that the truth is you are not actually passing anything by reference, you are just passing a pointer by value.

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9tqbg/lesson_89_introducing_the_stack/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tgdg/lesson_88_introducing_pass_by_reference_and_pass/
1254693827.0,9qsh5,Lesson 57 : Introducing bit masking,CarlH,101,25,71,"In this lesson I am going to show you why Boolean operations are so important. Earlier I have shown you that for ASCII characters

    0100 0001 : 'A'
    0100 0010 : 'B'
    ...

    0110 0001 : 'a'
    0110 0010 : 'b'
    ...

The third bit defines if this is an uppercase or lowercase letter. How can we see that bit? The answer is by using Boolean operations. The technical term for what I am about to show you is called ""bit masking"".

The way you can see (or change) information about a single bit is by constructing a bit mask. Now I am going to illustrate this concept for you.

Imagine that I have the following byte

    0100 0001

I need to see the THIRD bit only. I do not care about the rest. I need to have some way of determining if the third bit is turned on, and a different result if the third bit is turned off. 

First of all

    0010 0000

Why is that the bit mask? 

Think of it like having eight windows in a row. You are only interested in what is behind the third window. Therefore

Lets put our byte for 'A' and our bitmask together.

    0100 0001 &lt;-- 'A'
    0010 0000 &lt;-- Bitmask

Now lets use the AND Boolean operator on each bit. Remember

    0100 0001 &lt;-- 'A'
    0010 0000 &lt;-- Bitmask
    ---------
    0000 0000 &lt;--- After ANDing 'A' with the bitmask

What is the result? We get all zeroes. What if this had been a lowercase letter?

    0110 0001 &lt;-- 'a'
    0010 0000 &lt;-- Bitmask
    ---------
    0010 0000 &lt;--- After ANDing 'a' with the bitmask

Now here we can see the benefit of a Boolean operation. We now have a way to test a single bit in our byte to determine conclusively if it is uppercase

Given any character that we know is either uppercase or lowercase, we know it is uppercase if the result is 0. We know it is lowercase if the result is 0x20. There are no other possible outcomes.

Why are there no other possible outcomes? Because our bitmask has only one bit turned on. When using AND

Lets see this in action with a real function:

    int is_lowercase(char test_character) {
        if (test_character &amp; 0x20) {
            return 1;
        }

        return 0;
    }

That is it. That is all you have to do in order to check if a letter is lowercase or uppercase. Now you can see why Booleans are important.

Notice that I used one &amp; character. That is because one &amp; character means ""Boolean AND"". That is *NOT* the same as the &amp;&amp; characters which mean there will be another expression evaluated. 

1. &amp; means ""apply the boolean AND operation""
2. &amp;&amp; means ""Another expression follows""


Let's walk through this function.

    int is_lowercase(char test_character) {

Here we are saying that this function will return an integer. We are giving it the name `is_lowercase`

From now on inside this function

        if (test_character &amp; 0x20) {
            return 1;
        }

This is a single expression: `test_character &amp; 0x20` 

(As stated above

This just means we are taking whatever character was sent to the function

    0110 0001 &lt;-- 'a' (could be any character
    0010 0000 &lt;-- Bitmask (this is 0x20)
    ---------
    0010 0000 &lt;--- After ANDing 'a' with the bitmask (this is the result)

This expression will result in one of two possibilities. It will be 0x20 if `test_character` turns out to be lower case. It will be 0 otherwise. If it is zero

If however it is not zero

Now

    if (is_lowercase('a')) {
        printf(""It is lowercase \n"");
    }

If the letter really is lower case

[Edit: Quick note. The operations in this lesson

Here is a complete program that you can experiment with which illustrates this concept:

----
    #include &lt;stdio.h&gt;

    int is_lowercase(char);

    int main(void) {

        char my_char = 'a';

        if (is_lowercase(my_char)) {
            printf(""It is lower case!"");
        }

        return 0;
    }

    int is_lowercase(char test_character) {
        if (test_character &amp; 0x20) {
            return 1;
        }

        return 0;
    }
----
Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9qxxw/lesson_58_using_bit_masking_to_change_data/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qsh5/lesson_57_introducing_bit_masking/
1254684530.0,9qrj2,Lesson 55 : Introducing Custom Functions,CarlH,97,20,46,"In general

On a machine code level, it is CALL. There are certain differences between ""JUMP"" and ""CALL"" but we will not need to get into this as part of this lesson. For the sake of this lesson, the explanation I gave you above is enough. We will expand on this definition as we proceed. 

Lets look at an example of a function in a real program:

    #include &lt;stdio.h&gt;

    int my_function(void);

    int main(void) {
  
        printf(""Calling our function... \n"");
    
        my_function();
        // &lt;--- function returns here when finished.

        return 0;
    } 

    int my_function(void) 
    {                                                  // &lt;--- start_of_function
        printf(""Inside the function! \n"");

        return 1;                                      // &lt;--- return to main program
    }

Output:

    Calling our function... 
    Inside the function! 

Now lets talk about this. First of all

    my_function();

This effectively means to jump to the line I marked as ""`start_of_function`"". We have defined this function as (void) which means that we are not sending it any parameters. If we wanted to

One thing which may seem puzzling to you is that I have seemingly created the function twice. I have one line of code above main() which seems to create the same function as the code under main(). Why is that?

The top code with `my_function` tells C that we plan to have a function called `my_function()`. We are also telling C that we intend this function will return an integer

If we did not do that, yourself, and anyone who reads your code know what functions you have made.

The above paragraph is only partially true. In truth

You can call one function from another function. For example

    int my_function(void) {
        printf(""Inside my_function \n"");

        my_other_function();

        return 1;
    }

    int my_other_function() {
        printf(""Inside my_other_function \n"");

        return 1;
    }

Keep in mind for the above example we should have defined both `my_function` and `my_other_function` like this:

    int my_function(void);
    int my_other_function(void);

Such definitions should always go at the top of your source-code as I illustrated in my sample program.

Very soon we will get into some powerful uses of functions

----
Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9qs1f/lesson_56_introducing_boolean_logic/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qrj2/lesson_55_introducing_custom_functions/
1254660184.0,9qoze,"Lesson 51 : Introducing ""OR"" for conditional flow statements.",CarlH,104,25,28,"Every lesson in this course is designed to give you another tool that makes it possible for you to create more and more powerful programs. I imagine many of you are anxious to start writing more than just simple printf() statements

In the last lesson we talked about using ""AND"" in a conditional flow statement

However

In a conditional flow statement

Also

In English we might say ""If height is equal to five OR width is equal to three"". With OR we can write:

    if (height == 5 || width == 3) {

Lets look at this in practice:

    Figure (a)

    int height = 5;
    int width = 0;

    if (height == 5 || width == printf(""123"") ) {
        printf(""\n If statement evaluated as true"");
    }

Output:

    If statement evaluated as true.

Why didn't printf(""123"") execute? Because the if statement already met enough criteria to be evaluated as true. 

Imagine in the middle of a clear day I say ""If the sky is blue OR ...""

It doesn't matter what I say next. Why even read it? Since I used the word ""OR""

    If the sky is blue OR pink unicorns are flying around the sun : then do this :

Well

Whenever you use a conditional flow statement with OR

You can think of OR as saying ""Evaluate the next expression only if the last one was FALSE"". That is because if the last expression was TRUE

Just as it is true with AND, you should *always* whenever possible order the expressions from least-computing-power to most-computing-power, just as with an AND statement. 

Also

----
Please ask any questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9qpv3/lesson_52_introducing_the_goto_statement/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qoze/lesson_51_introducing_or_for_conditional_flow/
1254148676.0,9ot5y,Test of Lessons 11 through 19.,CarlH,168,88,6,"**Please remember this for all lessons:**

This course is designed so that you can go as slow as you need to. Do not worry about falling behind, and that is fine. There is no need to rush to ""catch up"". *Take your time.*

If you have not fully mastered the material all the way through lesson 19 - *you should not be here*. Go back, and only proceed when you are ready.
----
This test is smaller than the last one. Be sure to review the lessons before beginning. If anything is unclear

Do not scroll down and read comments here until you are done as others may have posted their answers to the test.

----

Because the course is at this point a mixture of lessons about a specific programming language ""C"", then it is a general question and is not specific to the C programming language.

----
**True or False**

1. Once a programming instruction is executed
2. As a programmer
3. (**C**) If I call the function printf() like this: printf(""Hello""); then the return value for the printf() function is the text ""Hello"".
4. (**C**) In C
5. A ""sign bit"" can be set to 1 or 0 to indicate if a number is positive or negative.

**Fill in the blank**

1. An ____________ is used by your CPU to keep track of the next programming instruction to be execute. 
2. When you send extra information to a function
3. When two programming languages do the same thing in a slightly different way
4. A ____________ number is a number that can be positive or negative.
5. If you count past the maximum value that can be held in a set number of bits

----
When finished

http://www.reddit.com/r/carlhprogramming/comments/9ot7r/test_of_lessons_11_through_19_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ot5y/test_of_lessons_11_through_19/
1346833686.0,zduy5,"[CarlHProgramming] All videos for Unit 13 are now published, and also I have an update.",CarlH,87,11,http://www.reddit.com/r/carlhprogramming/comments/zduy5/carlhprogramming_all_videos_for_unit_13_are_now/

This morning I finished uploading the last video (Video #9) for Unit 13. 

Unit 13 is going to be split into two units

Also

I will be taking the following steps:

1. Split Unit 13 into Units 13 and Unit 14
2. Rewrite all text lessons for each unit
3. Create a quiz for each unit

This will probably take a few days. I will keep everyone posted. 

[Links to all completed videos can be found here.](http://www.reddit.com/r/carlhprogramming/comments/ympb1/carlhprogramming_course_1_unit_13_new_video/)",,t5_2r81y,1346839881.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/zduy5/carlhprogramming_all_videos_for_unit_13_are_now/
1255834673.0,9v4zx,Lesson 100 : Arrays of Pointers Continued : Part One,CarlH,86,11,8,"This is a complex topic

----


In this lesson we are going to continue the project we started earlier

Recall that our ten bytes look like this:

    B0 B1 B2 B3 B4 B5 B6 B7 B8 B9

We allocate our ten bytes like this:

    char *main_pointer = malloc(10);

That gives us ten bytes to work with

Now

Remember

Now

    int *int_pointer1 = (int *) main_pointer;

Based on the last lesson

Now let's create a second pointer

    int *int_pointer2 = (int *) (main_pointer + 6);

Remember that `main_pointer + 6` is just a different memory address. We are doing the same thing as before

So far so good.

----

Now there is just one problem. These pointer names are not good. It is poor practice to name two related items as `int_pointer1` and `int_pointer2`. Why not just use an array of int pointers? In this lesson I am going to show you how.

First of all

How much space do we need? Well

    Horizontal View:
         [Integer Pointer #1][Integer Pointer #2]...

    Vertical View:
         B0 : [Integer Pointer #1]
         B4 : [Integer Pointer #2]

If we assume that any pointer is 4 bytes in size

    malloc(8);

Except, it happens to be that 8 bytes is correct. That is not guaranteed to be the case all the time. Therefore, we write this instead:

    malloc(2 * sizeof( int* ) )

This will give us the same result. This just means we are allocating 8 bytes of storage space for our array of two pointers. Any time we use malloc() we need a pointer to point at the space we allocated. Well

To answer that

What will our pointer *point to* ? It will point to `one star ints`. Why? Because we are creating an array that will consist of `(int *)` pointers. 

What do you call a pointer which points to `one star ints` ? A `two star int`. Similarly

Here is how we create our `two_star_int` which will point at our array of `int *` (one star int) pointers.

    int **two_star_pointer = malloc(2 * sizeof( int * ) );

If you are confused, you need a pointer that can ""point to"" elements of that array. In this case, each element of the array will be a `one star int`. We need something that can point to a `one star int`. That means, we need a `two star int`. 

If all you have gotten out of this lesson is that we need a `two star int` to point at our array of `one star ints`

Now consider the following:

1. `two_star_int` is the actual memory address of Byte #0. This will be the start of our eight byte working space.

2. `*two_star_int` is ""what is at"" that memory address. What is at that memory address? A `one star int`. 

... Continued on the next lesson ...

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v573/lesson_101_arrays_of_pointers_continued_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v4zx/lesson_100_arrays_of_pointers_continued_part_one/
1255481892.0,9trl6,Lesson 90 : Introducing PUSH and POP,CarlH,86,6,24,"In the last lesson you learned that there is a range of memory known as the stack. You also learned that this range of memory serves as a data storage and retrieval bin that functions use in order to communicate to each other.

In this lesson I am going to explain some of the basics concerning the mechanics of how the stack works. 

The first thing to understand about the stack is that there are two machine code instructions built into your CPU chip which are used to write data to the stack

    PUSH and POP 

PUSH means: ""store data"" to the stack.

POP means: ""retrieve data"" from the stack.

Now that you know what each of these instructions is designed to do

We have already learned that any programming language provides a mechanism to store data in memory at a specific memory address. Similarly

The key point to this process is that in order to store or retrieve data you must specify the memory address where you are either putting the data

On a machine level

When you call a function in C or any language

The stack is different from other ranges of memory because every time you store something onto the stack using the PUSH instruction, etc.) on top of the rest of the items already on the stack. Whenever you use the POP instruction to retrieve something from the stack, you only retrieve the item which is on top of the stack. Therefore, neither PUSH nor POP require you to specify a memory address.

Here is an example of a stack. This stack is half full. 

        0000 0000   &lt;-- empty
        0000 0000   &lt;-- empty
        0000 0000   &lt;-- empty
        1010 0101
        0010 1001
        1011 0101

If I use PUSH to store something onto the stack. It will *always* go to the first ""unused"" spot located at the top of the stack

        0000 0000   &lt;-- empty
        0000 0000   &lt;-- empty
        1111 1111   &lt;-- I just stored this. 
        1010 0101
        0010 1001
        1011 0101

So each time you use the PUSH instruction the data will go ""onto"" the stack. Meaning

Now

Just as PUSH stores data at the top of the stack

        0000 0000   &lt;-- empty
        0000 0000   &lt;-- empty
        1111 1111   
        1010 0101
        0010 1001
        1011 0101

If I use POP

If I use POP again

If I use POP again and again, First out"". It is called this because the last item stored onto the stack will be the first item retrieved from it. 

Each time you use PUSH, retrieving the data.

The only question that should remain then is this: How does PUSH and POP know what memory address is the top of the stack? Well

This is the purpose of the Stack Pointer. The Stack Pointer contains the memory address of the top of the stack. 

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9ts9i/lesson_91_how_a_function_call_works/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9trl6/lesson_90_introducing_push_and_pop/
1254765403.0,9r1y2,Test of Lessons 50 through 59,CarlH,86,8,2,"**Please do not post answers in this thread. Please do not scroll down just in case someone has.**
----
**True or False**

1. If a conditional statement such as an if statement contains multiple expressions
2. Using a goto statement in C is good practice and should be encouraged whenever possible.
3. The machine-code equivalent of a goto statement is built into the architecture of your CPU chip.
4. All conditional statements have a built in ""goto"" statement that you cannot see.
5. You can use the OR bitwise operation to test if a bit is turned on by using a bitmask where the bit you want to test is set to 1.

**Fill in the blank**

1. In a conditional statement, I would write: `_____`.
2. In a conditional statement, I would write: `_____`.
3. When you use a goto statement (JMP in assembly language)
4. An `_____` is used to describe a process which repeats the same instructions over and over forever.
5. 0011 ^ 1110 is: `____`.

----

When ready

http://www.reddit.com/r/carlhprogramming/comments/9r1yr/test_of_lessons_50_through_59_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9r1y2/test_of_lessons_50_through_59/
1254258812.0,9pa83,Lesson 29 : More about printf() and introduction to place holders.,CarlH,159,84,90,"In an earlier lesson you learned how to do this:

    printf(""Hello Reddit!"");

You learned that you send a string of text to the printf() function as a parameter

Now we are going to learn that printf() is actually much more powerful than what we have learned up until now. It is possible to use printf() to display not just set strings of text

In an earlier lesson I explained that you can do this:

    int i = 5;
    printf(""The variable i is set to: %d""

And the result will be:

    The variable i is set to: 5

Lets talk about how this works. First

Remember that we said before that matching data types is very important. Any time any function is going to operate on some data, and how it is formatted. Why? Because as we have learned in previous lessons *the same binary can mean multiple things*. A sequence of eight 1s and 0s might be an int or it might be a char, or anything at all. 

printf() allows you to specify different place holders depending on the type of data of what you want to print. You must *always* match the correct data type to the correct place holder. We learned that %d means ""integer""

    %d or %i : signed integer 
    %u : unsigned integer
    %c : single character 
    %s : A string of text like ""Hello""

We will learn more later
----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9peox/test_of_lessons_20_through_29/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pa83/lesson_29_more_about_printf_and_introduction_to/
1255486591.0,9ts9i,Lesson 91 : How a function call works,CarlH,77,2,27,"Go through this lesson slowly. It is more intense than most. Take your time. Let me know if any part of this is unclear.

Remember

----

In the last two lessons I have explained that the purpose of the stack is in part a way for functions to receive parameters. In this lesson I want to explain more about the mechanics of this process.

One thing you should already realize is that a function call has to know where to return when it is done. This may sound simple

How therefore does a function know where to return? Well

I am going to write out a small part of a C program using ""line numbers""

       Figure (a)

    	void main(void) {
    1		int height = 5;
    2		int width = 2;
    3
    4		calculate_area(height
    5
    	}
    
    	int calculate_area(height
    7
    8		return height*width;
    9 
    	}	

Do not be concerned with the numbers I chose. I just needed a unique way to label each line that is important to this lesson.

When we start executing the `main()` function, and 3. At this point, C understands that we want to CALL a function. What happens at this point?

Keep in mind that we need to achieve 3 things:

1. We need to save the location of the memory address we will return to when the function is done. This means we need to save the Instruction Pointer.
2. We need to store the variables height
3. We need to ""goto"" the function itself.

There is more that happens as part of this process

Now at line #3

    push width       ; Store width onto the stack using PUSH
    push height      ; Store height onto the stack using PUSH
  
    push eip         ; Store the Instruction Pointer (called eip) onto the stack. This is done as part of ""call"" below.
    call calculate_area    ; Call the actual function

This is assembly language

[Edit: One note about the above code, you would have to push them manually. ]

Now you should understand that our stack will now look like this with respect to the function parameters:

    ... top of stack where new elements can go ...
    height
    width

Notice that height is at the *top* of the stack even though `width` was pushed first. Also

Now you can see how exactly parameters are sent to a function. Whether a pointer, such as `main()`, places the parameters onto the stack. Then the function reads them off of the stack in reverse order to how they were stored.

Now you should be able to clearly see why you must specify how many parameters a function will take as well as their data types. A function needs to know how many items to read from the stack and how big each item is.

Were this to be done incorrectly

Now

How return values work is the subject of the next lesson.

----

If you have any questions on any of this material

http://www.reddit.com/r/carlhprogramming/comments/9tt3r/lesson_92_how_function_return_values_work/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ts9i/lesson_91_how_a_function_call_works/
1254335810.0,9plo8,Lesson 35 : Getting the value that was stored at a memory address.,CarlH,148,71,83,"In the last two lessons we learned how to create a pointer

Lets examine the following code:

    int total = 5;
    int *ptr = &amp;total;

You should know from the previous lessons exactly what is happening here, and assigning it the value 5. Secondly we are creating a pointer called ""ptr"" and giving it a value of... the memory address of ""total"".

Because the value of `total` is 5

    printf(""The total is: %d""

We would see this output:

    The total is: 5

Now

Recall that C has an ""address of"" operator

Now

    printf(""The total is: %d""

Recall that ""ptr"" is our pointer

    The total is: 5

So how do we achieve this goal? In the last lesson we learned that you can use the &amp; character to mean ""address of"". It turns out you can use the `*` (asterisk) character to mean ""what is at the address of"". In other words

What memory address? The memory address that is stored inside of ptr. In this case

Therefore

    printf(""The total is: %d""

In this case `*ptr` means this:

ptr is a pointer to an integer. ptr has some value, the value of `*ptr` is also 5.

The technical term for the `*` operator in this case is the ""Dereference operator"". The term ""dereference"" means to look not at the memory address

Now

    int total = 5;
    int *ptr = &amp;total;
    
The `*` character in this code does *not* mean ""what is at the address of"". There is a difference between when you create the pointer variable (which we are doing above) and when we *use* the pointer variable. 

When you create the pointer variable, but what is stored there. This is an example of using the same operator, a * in this case, for two different purposes.

Lets consider this code:

    int total = 5;
    int *ptr = &amp;total;

Only now that the ptr variable has been created can you use `*ptr` meaning: ""The value stored at the memory address."" Here is a summary of the different possible ways you can use the &amp; and * operators when it comes to `total` and `ptr` in the above example. 

1. `ptr` = This is the variable itself
2. `*ptr` = This refers to the actual data stored at the memory address that ptr holds. 
3. `&amp;total` = This is the memory address of the variable `total`.
4. `total` = This is the variable itself

Earlier we pointed out that any function which returned a return value of a given data type could be used in place of that data type - anywhere in the program. For example

The same concept holds true for pointers. If `ptr` is set to point at an integer (set to hold the memory address for an integer) for example

Why? Because `*ptr` actually *is*  an integer in every sense of the word. It is the actual binary sequence - the actual integer - that was stored at that location. It has the correct size

`*ptr` is not just ""like""


----
Please feel free to ask any questions if you need to before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pn3c/lesson_36_use_what_you_have_learned/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9plo8/lesson_35_getting_the_value_that_was_stored_at_a/
1254298079.0,9pfgk,Lesson 30 : Introducing arrays and pointers part one.,CarlH,156,78,31,"This function assumes that all text strings are encoded as ASCII. Another assumption being made is that the ""unsigned short int"" data type is two bytes in size. This is not always the case

----

In an earlier lesson we learned that we can use the `printf()` function to display text. 

Lets briefly look at this text: ""abc123""

Recall that it is encoded in memory like this:

    0110 0001 : 0110 0010 : 0110 0011 : 0011 0001 : 0011 0010 : 0011 0011 : 0000 0000
       ""a""    :     ""b""   :     ""c""   :     ""1""   :     ""2""   :     ""3""   : &lt;null&gt;

We store text in memory by creating a ""train"" of ASCII characters

This entire ""train"" is stored in memory exactly as I showed above. Every character immediately follows the character before it. In computing

A ""string"" is one of the simplest forms of something called an ""array"". An array is a collection of data elements where each data element has the same data type. For example

Arrays are incredibly useful in programming

Remember from an earlier lesson that you never have to worry about the actual address in memory where a variable is stored

Lets consider this code:

    unsigned short int total = 5;

What is ""total"" ? It is both a way to refer to the address in memory where the value 5 is stored

Every variable has some address in memory. This address in memory is **not** the value of the variable. Theoretically

    some address in memory : 0000 0000  0000 0101  &lt;--- This is our two-byte ""unsigned short int total"" 

Now, you now only have 16 BYTES of ram. Lets examine how this would look. 

On the left

Each address will be 4 bits in size (which gives us sixteen possible addresses in memory). At each address

    0000 : 0000 0000
    0001 : 0000 0000
    0010 : 0000 0000
    0011 : 0000 0000
    0100 : 0000 0000
    0101 : 0000 0000
    0110 : 0000 0000
    0111 : 0000 0000
    1000 : 0000 0000
    1001 : 0000 0000
    1010 : 0000 0000
    1011 : 0000 0000
    1100 : 0000 0000
    1101 : 0000 0000
    1110 : 0000 0000
    1111 : 0000 0000

Now, instead of two. Lets re-consider the following code:

    unsigned short int total = 5;

Now

Lets imagine that the variable ""total"" gets put in the memory address ""eight"" in our sixteen bytes of ram. Here is the new ram table with this modification:

    ...
    0101 : 0000 0000
    0110 : 0000 0000
    0111 : 0000 0000
    1000 : 0000 0101 &lt;---- here is where we stored the variable ""total""
    1001 : 0000 0000
    1010 : 0000 0000
    1011 : 0000 0000
    ...

We can see therefore that the variable ""total"" actually refers to two different values. Five

Lets go back to this statement:

&gt; What is ""total""? It is both a way to refer to the address in memory where the value 5 is stored

This should make more sense to you now. We will talk more about this in the next lesson.
----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pfuj/lesson_31_introducing_arrays_and_pointers_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pfgk/lesson_30_introducing_arrays_and_pointers_part_one/
1254245990.0,9p7yd,Lesson 28 : About terminating strings of text and other data.,CarlH,165,89,41,"
This lesson pertains to strings of text that are encoded as ASCII. There are other ways to encode text which are not covered in this lesson. However

----

Earlier we learned about ASCII

First

Recall that capital letters always begin with 010, we learned that numbers begin with 0011 and the final four bits will give you the actual number. 

You should have enough information then to understand that the text: ""123"" would be encoded thus:

    0011 0001 : 0011 0010 : 0011 0011

I used the : character to separate bytes to make them easier to read. 

Imagine now that I have some function that can print ASCII characters

Think about this for a moment. When I put the sequence of three bytes into memory corresponding to the characters ""123""

    0011 0001 : 0011 0010 : 0011 0011 
    (our three bytes -- this is ""123"" encoded in ascii. 0011 0001 = ""1""

    0011 0001 : 0011 0010 : 0011 0011 :: 0101 1111 : 1001 0101
    (our three bytes in memory -- the first three bytes are our ""123"")

You are probably asking what is this second set of two bytes after the :: in the above example. It is whatever just happens to be in ram following the three bytes we defined as ""123"". It could be left over data from some program that ran earlier. It could be absolutely anything. Always assume there is *something* in ram following any data you store.

Whenever you store some data in ram

I presented the three bytes of ""123"" next to this mess of binary using a :: separator

    0011 0001 : 0011 0010 : 0011 0011 : 0101 1111 : 1001 0101

Can you tell that our ""123"" sequence is different from the two bytes that immediately follow it? No. That was the subject of an earlier lesson

If I pointed a function like printf() at these five bytes

Have you ever seen a lot of strange characters get printed to your screen as a giant mess of weird letters? This happened because your computer started printing binary sequences it thought was ASCII

*Any* sequence of eight bits can be rendered as *some* ASCII character

I am presenting this lesson in the context of text strings

For example, which turns out to be something entirely different. The result of course would be some strange music.

So here we learn an important concept: You must *always* define a *stopping point* for any data. Always. 

There are two ways you can do this:

1. Pre-define a set length. In our earlier example with the string of text ""123""
2. Define a character at the end of the text string that means ""stop"". Typically this is done using the binary sequence: 

    0000 0000

Effectively what this means is that we can have a string of text *as long as we want*

So

    0011 0001 : 0011 0010 : 0011 0011 : 0000 0000 : &lt;anything further is ignored..

----
Please feel free to ask any questions concerning this lesson before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pa83/lesson_29_more_about_printf_and_introduction_to/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9p7yd/lesson_28_about_terminating_strings_of_text_and/
1253988926.0,9odca,From raldi (Reddit Admin) regarding the very strange vote totals in this subreddit.,CarlH,330,256,23,"&gt; We've got a bug with restricted reddits. If you mark it public

&gt; A fix is in the works.

So it turns out downvote bots are not at work here. Good to know.
",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/9odca/from_raldi_reddit_admin_regarding_the_very/
1255558458.0,9u47k,Lesson 95 : Using Casts with Pointers Part One,CarlH,84,10,63,"In the last lesson I showed you that any range of memory can be used for any purpose that can fit inside that memory. In this next series of lessons I want to illustrate this by actually re-using the same ten bytes of memory in this way. I believe that doing this will give you a greater understanding for how casts

In this lesson I am going to show you how to write a program which allocates 10 bytes of space and then uses that ten bytes of space as:

1. ten characters
2. two integers (which leaves unused space)
3. A 2x5 array of text
4. A data structure having two strings of text

First

    char *main_pointer = malloc(10);

There. Now `main_pointer` is a pointer which is looking at the first byte of a ten-byte memory space that we have allocated.

First

I am going to use a mixture of methods here. They are all doing exactly what we want.

    *(main_pointer + 0) = 'A';
    *(main_pointer + 1) = 'B';

    main_pointer[2] = 'C';
    main_pointer[3] = 'D';

    strcpy( (main_pointer + 4)

Our final string will look like this: ""ABCDEFGHI"" (with a NUL) at the end.

Notice that using array indexing or pointer indexing makes no difference. Notice that when I use my pointer as an array

Let's print it:

    printf(""Our ten bytes of memory contain the string: %s \n""

Output:

    Our ten bytes of memory contain the string: ABCDEFGHI

Now, an integer is 4 bytes.

I can only fit two 4-byte integers in a 10-byte space. So lets consider how this will work:

    B0 B1 B2 B3 B4 B5 B6 B7 B8 B9   &lt;-- ten bytes

Before we can choose to use these bytes for integers

    B0 B1 B2 B3    and     B6 B7 B8 B9

There is only one rule I *must* remember. I cannot mix the order of the bytes. For example

Now

What I really need to know is the starting point of each integer. In this case byte #0 and byte #6. I know that there is room to store my integers correctly.

Now, let's see what they already are. How can we do that?

First

    printf(""The integer at byte #0 is set to: %d \n""
    printf(""The integer at byte #6 is set to: %d \n""

Output:

    The integer at byte #0 is set to: 65
    The integer at byte #6 is set to: 71

Notice that 65 is 'A' (decimal, we are telling printf() to treat that character as if it were an integer. 

However

You see

Let's create it:

    int *int_pointer;

I haven't given it a memory address yet. What memory address do we want to give it? We want to give it the memory address of our ten bytes that we have already allocated. What is that memory address? It is: `main_pointer`. Remember we already have a pointer that contains the right memory address. Therefore

    int *int_pointer = main_pointer;

One small problem. an `int *` pointer expects to look at memory in int-sized chunks. A `char *` pointer expects to look at memory in char-sized chunks. We cannot assign the memory address of a `char *` pointer that easily without our compiler complaining. 

Our compiler is concerned that we do not really know what we are doing

    int *int_pointer = (int *) main_pointer;

By simply putting `(int *)` we have stated that we are assigning the new pointer `int_pointer` the same memory address as `main_pointer`

What have we just done? We have created a second pointer which points to our ten byte memory space. Our first pointer is already pointing to this same exact spot in memory. How are the two pointers different? They are different in mainly two ways: 

1. How they understand dereferencing
2. How they understand pointer arithmetic

Remember that dereferencing means that you put a `*` character in front of a pointer to get ""what is at"" the memory address contained in the pointer. As you saw in our printf() example

Therefore

    *main_pointer          &lt;-- one byte
    main_pointer[6]        &lt;-- one byte
    *(main_pointer + 4)    &lt;-- one byte

No matter what location in memory I dereference with this pointer

The second way the two pointers are different concerns pointer arithmetic. If I say: `main_pointer + 1`: It means to change the memory address by only one byte. Why one byte? Because that is how big a `char` is. However with our new pointer if I were to say the same thing: `int_pointer + 1` The memory address will be four bytes different than it was. If I added 2 then our `int_pointer` would point 8 bytes away (4 `*` 2).

What you should understand from the above text is that in order to have a true four-byte integer out of our 10-byte data

Now consider this:

    int *int_pointer = (int *) main_pointer;    // &lt;-- create the pointer int_pointer using the same memory address

Now let's set values using this pointer:

    *(int_pointer + 0) = 53200;
    *(int_pointer + 1) = 32000; 

Remember of course that `int_pointer + 0` is the same as `int_pointer`. However

    printf(""The first integer is set to: %d \n""
    printf(""The second integer is set to: %d \n""

Output:

    The first integer is set to: 53200
    The second integer is set to: 32000

This proves we are using more than just one byte of our allocated memory. Notice that we could not do this with a `char *` pointer

Notice we did not have to use any type cast in our printf() statement. Because `int_pointer` is already set to point at the data type `int`

What bytes am I using in the printf() statement? Let's consider this. I have 10 total bytes. I pointed `int_pointer` at the first byte. I stored the integer value ""53,000"" into those four bytes. Therefore:

    &lt;  B0 B1 B2 B3  &gt;    &lt; B4 B5 B6 B7 &gt;       &lt;--- Here are my two integers in the above printf()

Now keep something in mind, that will cause it to point at byte #4. 

If adding to an int pointer can only be done in increments of four

That is the subject of the next lesson.

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9ulj6/lesson_96_using_casts_with_pointers_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9u47k/lesson_95_using_casts_with_pointers_part_one/
1255050943.0,9s8ru,Lesson 70 : Review of Pointers Part Four,CarlH,79,5,9,"Now

Let's consider this code:

    char my_string[] = ""Hello Reddit"";

    char *my_pointer;

Ok

Most likely

This is the first example we will look at, there are two ways to do this.

First

    my_pointer = my_string;

Why? because `my_string` is already understood by C to be a memory address. Any array name is seen as a memory address. More specifically

Another way we can achieve the exact same goal

    my_pointer = &amp;my_string[0];

This is saying

It makes sense right? If we wanted to set my_pointer to be equal to the second character

These two examples are the same. We can set a pointer to contain the memory address of the first element of an array which means exactly the same thing as setting the pointer to contain the memory address to the start of the array itself. Why? Because the start of the array *is* the first element.

So both of these lines of code achieve the same goal:

    my_pointer = my_string;
    my_pointer = &amp;my_string[0];

Ok

    my_pointer = &amp;my_string;

This is the exception to the rule. This does *not* mean the same thing as the other two. Why? Well

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9s8wg/lesson_71_review_of_pointers_part_five/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9s8ru/lesson_70_review_of_pointers_part_four/
1254689423.0,9qs1f,Lesson 56 : Introducing Boolean Logic,CarlH,100,27,23,"In lessons 3 and 6 I showed you how to count like a computer. In this lesson I am going to teach you the basics of how to think like one. You will find that the two are very closely related.

To begin this lesson I have to introduce you to a new term. The Boolean.

A Boolean is simply a fancy name for a ""bit""

&gt; In Binary: **1**000 = 8. 

The highlighted ""bit"" can be considered as a Boolean. Why? Because it can be a 1

If I give you a Boolean

I give you a Boolean (a 1 or a 0). Now I say, you give me back a 1. If I gave you a 0, you give me back a 0. This is an example of being given a Boolean, applying some instructions to it, and getting a new Boolean.

Now suppose I said

Now if I gave you a 1

    NOT 1 = 0
    NOT 0 = 1

Seems pretty simple. This reads as ""If I give you a 1

One major concept to understand is that when you are working with a Boolean

Suppose that I said ""I am going to give you two Booleans.""

Now, you must *always* give me back only one Boolean.

Let's look at some other operations involving Booleans. 

It turns out we have briefly explored two Boolean operations already. AND

We can rewrite this as follows:

    1 AND 1 = 1. 
    Any other possibility = 0.

Let's go ahead and expand this statement:

    0 AND 0 = 0
    0 AND 1 = 0
    1 AND 0 = 0
    1 AND 1 = 1

Now we have covered all the possibilities. For example

What I have just showed you is a simple example of something called a ""truth table"". Whenever you have some operation involving Booleans

Here is the truth table for OR:

    0 OR 0 = 0
    0 OR 1 = 1
    1 OR 0 = 1
    1 OR 1 = 1

Keep in mind the following:

1. Each Boolean operator takes a set number of inputs. In the case of AND
2. Every Boolean operator will have a truth table. The truth table will show all possible results for that operator. The number of rows for such a truth table will always be two to the power of the number of inputs required.
3. No matter how complex the operator

Now

Well

    0 OR 0 = 0
    0 OR 1 = 1
    1 OR 0 = 1
    1 OR 1 = 1

Now

    0 OR 0 = 0; NOT 0 = 1
    0 OR 1 = 1; NOT 1 = 0
    1 OR 0 = 1; NOT 1 = 0
    1 OR 1 = 1; NOT 1 = 0

Now we can construct the final truth table:

    0 NOR 0 = 1
    0 NOR 1 = 0
    1 NOR 0 = 0
    1 NOR 1 = 0

Notice I gave a better name to ""NOT OR"". I chose to call it NOR.

This lesson

You have two incoming wires and one outgoing wire. The outgoing wire will have an active current only if both incoming wires had an active current. Think of the two incoming wires as the Boolean inputs. Think of ""active current"" as a 1. If both ""wires"" (incoming Booleans) are active (1) then the result is a wire with active current (1). In other words

Why am I teaching you this? Because C as well as many programming languages give you the ability to work with Booleans on this fundamental level

Remember that underneath it all
----
Please feel free to ask any questions if any of this material is unclear to you. When ready

http://www.reddit.com/r/carlhprogramming/comments/9qsh5/lesson_57_introducing_bit_masking/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qs1f/lesson_56_introducing_boolean_logic/
1254434113.0,9q01u,Lesson 42 : Introducing the char* pointer.,CarlH,147,75,135,"As I mentioned before

Now I am going to explain some of the mechanics of how this actually works. In other words

First I want to give you a small sneak peek at the future of this course. In C (or in any language really) the complexity of data follows this hierarchy:

1. single element of a given data type (char
2. text string (a type of simple array)
3. single dimensional arrays 
4. multi-dimensional arrays
5. structures
6. And so on.

The more complex the data you can work with

In the very first lesson I commented about the difference between learning a language

Now we are going to advance our understanding past single data elements of a given data type

Examine this code:

    char my_character = 'a';

This makes sense because we are saying ""Create a new variable called `my_character` and store the value 'a' there."" This will be one byte in size.

What about this:

    char my_text = ""Hello Reddit!"";

Think about what this is saying. It is saying store the entire string ""Hello Reddit!"" which is more than ten bytes into a single character -- which is one byte.

You cannot do that. So what data type makes it possible to create a string of text? The answer is - none. There is no 'string of text' data type. 

This is very important. No variable will ever hold a string of text. There is simply no way to do this. Even a pointer cannot hold a string of text. A pointer can only hold a memory address.

Here is the key: a pointer cannot hold the string itself

Consider this code:

    char *my_pointer;

Here we have created a pointer called `my_pointer` which can be used to contain a memory address. 

Before I continue, just like a variable, has some address in memory where it resides. To be clear, *anything* that is ever stored in ram has a memory address.

Now consider this code:

        char *my_pointer;
        my_pointer = ""Hello Reddit!"";

        printf(""The string is: %s \n""

Keep in mind that a pointer can only contain a memory address. Yet this works. This means that `my_pointer` must be assigned to a memory address. That means that ""Hello Reddit!"" must be a memory address. 

This is exactly the case. When you write that line of code

1. Create the string of text ""Hello Reddit!"" and store in memory at some memory address.
2. Create a pointer called `my_pointer` and point it to the memory address where the string ""Hello Reddit!"" is stored.

Now you know how to cause a pointer to point to a string of text. Here is a sample program for you:

    #include &lt;stdio.h&gt;

    int main() {
        char *string;
        string = ""Hello Reddit!"";

        printf(""The string is: %s \n""
    }


----
Please ask questions if any of this is unclear to you and be sure you master this and all earlier material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9q0mg/lesson_43_introducing_the_constant/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9q01u/lesson_42_introducing_the_char_pointer/
1343856219.0,xj01g,[CarlHProgramming] I added lesson tracking and an achievement points system. Please tell me what you think.,CarlH,84,11,18,"Hello everyone

Yesterday after many of you asked for it

Please take a look

The way it works is that you start with 10 points

[Higher Computing for Everyone](http://www.highercomputingforeveryone.com)",,t5_2r81y,1343873726.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xj01g/carlhprogramming_i_added_lesson_tracking_and_an/
1257851744.0,a2tdb,Lesson 126 : A snapshot of current progress: Part One,CarlH,76,3,19,"Before we go into the next lesson

----

    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

	int find_winning_move(char *
	int display_board(char *);
    int is_winning_position(char *
    void show_win_details(int
   
    int main(void) {
        int retval = 0;
        char raw_data[]         = ""X  X XO  "";
		char player = 'X';

		printf(""We are examining this board: \n"");
        display_board(raw_data);

        find_winning_move(raw_data

		return 0;
    }

    int find_winning_move(char *raw_data

        char test_position[10];
        int i

        for (i = 0; i &lt; 9; i++) {
            if (raw_data[i] == ' ') {
                strcpy(test_position
                test_position[i] = player;
                win_result = is_winning_position(test_position
                printf(""The result of playing %c at position %d is: %d \n"", win_result);

				display_board(test_position);
            }
        }

        return 0;
    }

    int display_board(char *raw_data) {
        char display_model[]     = ""[ ][ ][ ]\n[ ][ ][ ]\n[ ][ ][ ]\n"";
    
        int i
    
        for (i = 0; i &lt;= 2; i++) {
            for (j = 1; j &lt;= 7; j+=3) {
                display_model[ (i * 10) + j ] = raw_data[k++];
            }
        }
    
        printf(""%s\n""
    }

    int is_winning_position(char *raw_data

        int i;

        // Test for horizontal win
        for (i = 0; i &lt;= 6; i+=3) {
            if (raw_data[i] == player &amp;&amp; raw_data[i+1] == player &amp;&amp; raw_data[i+2] == player) {
                return 10 + i;
            }
        }

        // Test for vertical win
        for (i = 0; i &lt;= 2; i++) {
            if (raw_data[i] == player &amp;&amp; raw_data[i+3] == player &amp;&amp; raw_data[i+6] == player) {
                 return 20 + i;
            }
        }

        // Test for diagonal win
        if (raw_data[4] == player) {
            if (raw_data[0] == player &amp;&amp; raw_data[8] == player) {
                return 31;
            }
            if (raw_data[2] == player &amp;&amp; raw_data[6] == player) {
                return 32;
            }
        }

        return 0;

    }

    void show_win_details(int win_value

        switch (win_value) {

            // Horizontal
            case 10 : 
                printf(""Horizontal win on first row for Player: %c \n""
            break;
            case 13 : 
                printf(""Horizontal win on second row for Player: %c \n""
            break;
            case 16 : 
                printf(""Horizontal win on third row for Player: %c \n""
            break;

            // Vertical
            case 20 : 
                printf(""Vertical win on first column for Player: %c \n""
            break;
            case 21 : 
                printf(""Vertical win on second column for Player: %c \n""
            break;
            case 22 : 
                printf(""Vertical win on third column for Player: %c \n""
            break;

            // Diagonal
            case 31 : 
                printf(""Diagonal win upper left to lower right for Player: %c \n""
            break;
            case 32 : 
                printf(""Diagonal win lower left to upper right for Player: %c \n""
            break;

            default: printf(""Some error occurred. \n""); break;

        }
    }

----

Sample Output:

    We are examining this board:
    [X][ ][ ]
    [X][ ][X]
    [O][ ][ ]
    
    The result of playing X at position 1 is: 0
    [X][X][ ]
    [X][ ][X]
    [O][ ][ ]
    
    The result of playing X at position 2 is: 0
    [X][ ][X]
    [X][ ][X]
    [O][ ][ ]
    
    The result of playing X at position 4 is: 13
    [X][ ][ ]
    [X][X][X]
    [O][ ][ ]
    
    The result of playing X at position 7 is: 0
    [X][ ][ ]
    [X][ ][X]
    [O][X][ ]
    
    The result of playing X at position 8 is: 0
    [X][ ][ ]
    [X][ ][X]
    [O][ ][X]
    
----

Notice therefore that this program takes any given tic-tac-toe position

Please ask any questions that you need to before proceeding.",,t5_2r81y,1343089948.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/a2tdb/lesson_126_a_snapshot_of_current_progress_part_one/
1255535971.0,9tzzt,Lesson 94 : A new way to understand memory and data types,CarlH,83,12,6,"In the last lesson I explained that using type casting it is possible to cause data which was created as one data type to be considered as though it were another data type.

In this lesson I want to change slightly how you look at variables, and pointers.

Whenever you create something of any data type

Let's imagine that we have a chunk of memory that looks like this:

    Figure (a) : Before

    ...
    0110 0011
    1111 0111
    1001 1100
    0011 0000
    0001 0000
    ...

Imagine that this represents the total memory that is free for use for the program we are writing. If I create a variable

    char my_char;

C is going to find some spot of that available memory

If I write this:

    int height;

Similarly

    Figure (b) : After

    ...
    0110 0011
    1111 0111
    1001 1100
    0011 0000
    0001 0000
    ...

The act of creating a variable is only the act of reserving some chunk of memory for a data type, structure, etc. Anything you create without initializing it *will have* whatever value was already at those bytes. 

Now suppose you want to create an array of ten characters. In order to do this

In other words

    char *my_characters = malloc(10);

I just created an array of 10 characters. Why? Because 10 bytes *is* ten characters

If I want to create an array of five integers

    int *my_integers = malloc(5 * sizeof(int) );

Most likely 20

What you need to understand from this lesson is that having the correct sized chunk of memory for your data type is *the same thing* as having the data type itself. The data type just describes how you intend to understand the memory you have allocated for it.

Suppose I want a 3x3x3 array of characters. I can simply allocate 27 bytes

    char *my_array = malloc(27);

This gives me a 3x3x3 array. What if I want an array that is 3x9 ? How about 9x3 ? Same thing. The above line of code will generate any possible data type that is designed to be 27 bytes in size. 

After this lesson


----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9u47k/lesson_95_using_casts_with_pointers_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tzzt/lesson_94_a_new_way_to_understand_memory_and_data/
1255472475.0,9tqbg,Lesson 89 : Introducing the Stack,CarlH,81,7,5,"In the last lesson we covered the different methods you can use to send variables to a function. However

Right now

To explain this

The `stack` is a special range of memory in your computer which is used to store and retrieve data in a unique way. 

Recall from earlier lessons that a CPU chip has a built in register called the ""Instruction Pointer"". The ""Instruction Pointer"" contains the memory address of the next instruction to execute. It turns out that the Instruction Pointer is not the only register on your CPU chip that stores memory addresses.

There is an additional register on your CPU chip known as the ""Stack Pointer""

[Note: However

Different ranges of memory have different purposes. The ""Stack Pointer"" register contains memory addresses in much the same way as the ""Instruction Pointer"" register does

To properly understand the stack

Why is that? When you CALL a function

This is where the stack comes in. Before a function CALLs another function

Then inside the function the stack can be read in order to see what data was sent to the function. The stack is a type of ""middle man"" for communicating between functions. All functions can read from and write to the stack. Therefore, other functions can communicate in this way. 

There is more to the stack than just this

In summary

How this works is the topic of the next lesson.

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9trl6/lesson_90_introducing_push_and_pop/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tqbg/lesson_89_introducing_the_stack/
1255103802.0,9sgmy,Lesson 73 : Understanding Array Indexing as Pointer Offsets Part One,CarlH,74,1,3,"This is the first lesson on a series designed to increase your understanding of arrays and pointers

Before we begin

This is not the case with Arrays. Arrays are therefore a construct of programming languages such as C

Let's examine a simple array of text characters:

    char my_string[] = ""Hello Reddit"";

At this point, then the 'e', and so on. Each character resides in memory immediately after the character preceding it. All of the characters are stored in memory one immediately after the other, each character having a memory address that is exactly one greater than the memory address before it.

C has unique syntax for dealing with arrays. For example, and most languages have similar constructs for dealing with arrays.

In this lesson we are going to implement a two-dimensional array of text strings using only pointers

Here is the goal:

I intend to create an array of four strings of text

Here are the four strings of text:

    [0] : ""One""
    [1] : ""Two""
    [2] : ""Three""
    [3] : ""Four""

Why did I choose a maximum size of six characters?  The longest word is ""Three""

Whenever you perform an action that is designed to ""give you space to work in""

When I write this line of code:

    char my_string[4][6]; 

I am allocating 4x6 = 24 bytes to use for the array `my_string`. In this lesson

There are various ways I can allocate 24 bytes of storage. However

    char storage[] = ""12345678901234567890123"";

Why did I choose the characters I did? It makes it easier to count. In this way you can start at 1, 23 characters. The last character is of course invisible, the NUL string termination character. That makes 24 total characters. This has no bearing outside of this lesson, but I thought I should clarify why I chose the characters I did to avoid any confusion.

Ah, but we will do this without any arrays before we are done.

So what you should know at this point is that I have created a string of text

Now I have achieved step one

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sh4l/lesson_74_understanding_array_indexing_as_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sgmy/lesson_73_understanding_array_indexing_as_pointer/
1254498261.0,9q80s,Lesson 47 : Introducing the character string as an array.,CarlH,149,78,67,"In a previous lesson we learned how to make a string constant using a char* pointer

    char *string = ""Hello Reddit"";

We created a pointer of type `char` and we assigned it the memory address of the string ""Hello Reddit""; 

In an earlier lesson

With a string of text, each residing one after the other in memory. To create an array we basically need to follow these steps:

1. We choose a data type. Each element of the array *must* be the same data type. 
2. We choose a size. In reality
3. We store data into the array.

Remember that I said that a character string is an array. Lets look at our ""abc123"" from the previous example:

    Figure (a)
    1000 : ['a']['b']['c']['1']['2']['3']['\0'] ...

We have already seen how to create it as a constant. How do we create it in such a way we can modify it? The answer is

Here is the code:

    char string[7] = ""abc123"";

Here is what I am saying: Create a variable called `string`. Keep in mind that `string` is not really one single data element, but I stated seven to take into account the NULL byte at the end.

So here comes a question. What exactly *is* `string`? Is it a constant? Is it somehow encoded differently in memory to `Figure (a)` above? The answer for both questions is no.

It is not a constant first of all because we have specifically told C that we want an *array of variables* of type `char`. A variable can be modified

Is it encoded any differently? No

Try this code:

    char string[7] = ""abc123"";
    printf(""The string is: %s""

Now

    char string[] = ""abc123"";
    printf(""The string is: %s""

Here you will get the same result.

Now, you do not need to worry about this. As I stated in an earlier lesson, any time you are working with any type of data more complex than a single variable of a given data type, you *are* working with a pointer. 

Programming languages, which is what these lessons are largely about.

----

Please feel free to ask any questions and be sure you master this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9qask/lesson_48_using_pointers_to_manipulate_character/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9q80s/lesson_47_introducing_the_character_string_as_an/
1345513734.0,yk2jh,Thank you Carl H. for this amazing resource!,Kingfoot,88,13,13,"This is exactly what I've been looking for to learn programming. Structure

Your explanations are amazing

A couple questions:

1. Will we be taking us through (though it seems far from now) creating visual elements and essentially a groundwork for 2d or 3d games? My goal for programming is to create sprite based games in 3d environments (isometric

2. Do you let discussions here alter your curriculum or guide it in directions?

3. What is/are your ultimate goal(s) in providing lessons in this open-source way?

4. Being the Guru you are

5. If my goal is to create games

6. And the final question; will you be going more deeply into design?

Again,False,,t5_2r81y,False,,,t3_yk2jh
1255502284.0,9tuh3,Lesson 93 : Introducing Casts,CarlH,78,6,12,"In this lesson I am going to introduce you to a concept called type casting. This refers to the process of treating some data of one data type as though it were another data type. 

To understand this process, then an array of ten characters would be 10 bytes in size.

Now that covers how big it is. What does it *look* like? The answer: Whatever happens to be in those ten bytes. Any possible sequence of 1s and 0s is fine. It doesn't matter. An array of ten characters has *absolutely no requirement* concerning how the 1s and 0s inside those 10 bytes look. 

This is important to understand. Any memory range that is 10 bytes long can be understood as being 10 characters *regardless* of what is actually contained in the memory. Similarly

A data type is *only a description* of how to understand a range of memory. The same 9 bytes of memory that can be a tic tac toe board in our earlier lesson could be nine ASCII characters. The same 90 bytes of memory that can be ten tic-tac-toe boards could just as easily be 90 bytes of some sound file.

Below I am demonstrating how an unsigned short int (assume 2 bytes) and an array of characters 2 bytes long sees the same data:

      Figure (a) 

      
      unsigned short int = 16
      ___________/\_____________
    /                           \
    0100 0001     :     0100 0010
    \_______/           \_______/
    char[0] = 'A'        char[1] = 'B'

It is the *same memory*: 0100000101000010 

This same sequence of 1s and 0s can mean 'AB' or it can mean 16

If I create an array of two characters in C

If you look at that statement another way: Whatever was there before

If I create an unsigned short int in C

With this in mind, why can I not take some integer value and convert it to several characters?

The answer is. You can. 

Whenever you tell C or any programming language to treat a value of one data type as though it was a value of a different data type

You could do this as many times as you want. You can even have the same data in memory being used in your programs in multiple ways simultaneously. You could have a printf() statement which says `AB: 16706` using the same sequence of memory for both the character interpretation

[Note: The way this actually works is slightly different

There are many powerful uses of this which we will go over in future lessons. You saw one example of this in an earlier lesson when I created a char `*` pointer by casting it from a data structure pointer in order to go byte-by-byte through my data structure to show that it looked like this in memory:

    Reddit$Programming$Classes$

In the following lessons there are two kinds of casts we will look at: value casts

A value cast refers to when we cast an actual sequence of 1s and 0s

A pointer cast refers to when we take a pointer of one data type and we tell it to continue to point where it is pointing

Think of a data type in general as a pair of colored glasses. If you put on red tinted glasses, you are *still looking at the same data*, but now it has turned green. 

Casting can be thought of as switching glasses from one color tint to another. You will still be looking at exactly the same data


To wrap up this lesson: Any sequence of bytes can be understood as anything you want

----

That is all for tonight. I will do more tomorrow. I didn't have very much time to get to questions but tomorrow I expect to catch up.

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9tzzt/lesson_94_a_new_way_to_understand_memory_and_data/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tuh3/lesson_93_introducing_casts/
1255405355.0,9tfzh,Lesson 87 : Introducing the constructor function,CarlH,83,10,39,"In the last lesson I went into detail about the need for any program to initialize a data structure to a known initial working state. 

A function whose job is to allocate memory for data structures, before anything else. It will ""pave the road"" for future functions. In our example we will want a constructor function which can initialize a ""tic tac toe board"" to some starting point.

First

    _ _ _
    _ _ _
    _ _ _

So

It looks to me that the easiest way is to create a structure similar to this:

    typedef struct tictactoe_board_description {
        char square[3][3];
    } tictactoe_board;

Here I created an array of characters called `square` which will be a 3x3 grid. We will decide that each square can have either an underscore (initial or default state)

Now

    int init_board(tictactoe_board *board) { 
        
        int i = 0;
        int j = 0; // used for for loop

        for (i = 0; i &lt; 3; i++) {
            for (j = 0; j &lt; 3; j++) {
                board-&gt;square[i][j] = '_';  // Set each square to _
            }
        }

        return 1;
    }

The word `init` in our function name is short for initialize. This function is different than any we have done up until now. Let's evaluate it a bit. First of all

Notice how much the typedef keyword helps us. I can create a function that receives a tic tac toe board as an argument. However

    (tictactoe_board *board)

Why the `*`? Because I am *not* sending a tic tac toe board to the function. I am sending a *pointer* to the tic tac toe board. All I am sending the function is the memory address along with the understanding that this memory address is the start of a range of memory (the size of our structure) that can be used as the data structure described earlier as a tic tac toe board.

Keep in mind we have only created a description of that data structure, provided of course that the memory range is the correct size in bytes. 

Most likely

A pointer to a data structure means ""Here is some memory that can be used for this purpose."" The struct description tells C how we *intend* to use that memory. Now let me show you a visualization of this:

    1000 : 0110 1111 : 0011 1110 : 0001 0000 : 0000 0000 : 0100 0011 : 0011 1111 &lt;--- a range of memory with 1s/0s left over.

Imagine we just told C that we plan to use this memory at position 1000 (eight) for our data structure of a 3x3 grid of characters. 

All C gives us is the address ""1000"". That address does NOT ""have our data structure"". It is just a sequence of 1s and 0s left over in memory, in this case six bytes.

So when our constructor function receives the pointer to some memory like this

Now

We also gave our parameter a name

Every time you create a parameter for a function, or even if it is also called ""board"". 

When you create a function, the function expects a parameter called ""board"" which is a pointer of the data type ""tic-tac-toe board"".

Now from that line onward to the end of the function:

1. `board` refers to the memory address.
2. `*board` refers to what is at that memory address

Therefore

Therefore

    board-&gt;square[0][0] = '_';

I would be setting the first row and first column square to an underscore. By doing this for all 3 rows, setting each one to an underscore.

Finally

----

Please ask questions if you need to. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9tgdg/lesson_88_introducing_pass_by_reference_and_pass/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tfzh/lesson_87_introducing_the_constructor_function/
1261303126.0,agpkp,Questions Thread Lessons 1 Through 126,CarlH,81,6,42,"I am nearly prepared to publish new lessons. It will take a bit of time to work back up to a posting schedule similar to what I had before. First

There are many unanswered questions from the period of time that I was not able to be active here. However

If you still have a question which is not answered either by me or someone else on the forum

This will also put all of the questions for non-current lessons in a location where everyone from moderators to users can see them and answer them. If you see a question on this thread you can answer

I am working on the next lessons to be published

",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/agpkp/questions_thread_lessons_1_through_126/
1256232922.0,9wqec,Lesson 112 : The Practical Use of Functions : Part Three,CarlH,74,2,12,"In the last lesson we created our `demonstrate_array()` function

What is scope? Scope is a term that refers to the visibility of information within certain boundaries. Do not worry if this is confusing. It will be clear soon enough.

In most programming languages

The first thing you must know is that variables you create in one function

That means that even though I created `our_pointer` in main()

&gt; `void demonstrate_array(void) {`

&gt; `    strcpy(( ` **our_pointer** `  + (B_Size * 0))

The problem is that `our_pointer` does not exist in this function. For our function to work properly

At this point

Imagine a program with hundreds of functions. If this were the case

Worse still

This one reason should be enough to convince you that letting all functions see all variables is a bad idea. You will learn more reasons later in the course.

Now that I have established that `our_pointer` doesn't exist in the function `demonstrate_array()`

Any time therefore that you create a function by copy-pasting code from somewhere else in your program

This then leads us to a problem: How do we get the variable to be visible to the function? This brings us to step two of our five step process.

    2. Determine what arguments you will need for the function.

Remember that an argument is the term for information that you send to a function. In this case

There are *two* variables which were created outside of the scope of our `demonstrate_array()` function that I need to be concerned about.

1. `our_pointer`
2. `B_Size`

Both of these variables were created in our main function. 

    our_pointer is of the data type: char *
    B_Size is of the data type: int 

Whenever you determine arguments for a function that was created by copy-pasting code from somewhere else

Step one

    void demonstrate_array(char *

Step two

    void demonstrate_array(char *our_pointer

And already

When you become experienced in writing programs, and you change the arguments of the function. 

Usually you know ahead of time what those arguments are

You will notice that there is a step 3 in our five steps

    3. Convert the code in the function to use those arguments.

Notice that by naming the arguments according to the variables used within the function. I have completed steps 2 and 3 together with a single act. 

Now that we have a working function

    int main() {
        ... some code ...
        demonstrate_array(our_pointer
    }

In this way we are now sending `our_pointer` as well as `B_Size` to the function. This will now cause the function to work exactly as we expect.

Have we forgotten anything? In a previous lesson I explained that any time you create a function

Here then is a complete sample program demonstrating what we just did:

----

    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;stdlib.h&gt;

    // Function Definitions
    void demonstrate_array(char *

    int main(void) {

      char *our_pointer = malloc(10);

      int B_Size = 5;

      demonstrate_array(our_pointer

      free(our_pointer);

      return 0;
    }

    void demonstrate_array(char *our_pointer

      strcpy((our_pointer + (B_Size * 0))
      printf(""array[0] string is: %s \n""

    }


----

Please ask questions if any of this is unclear. When you are finished

http://www.reddit.com/r/carlhprogramming/comments/9ww0j/test_of_lessons_99_through_112/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9wqec/lesson_112_the_practical_use_of_functions_part/
1255231258.0,9svba,Lesson 84 : You can make your own data type using struct,CarlH,79,6,25,"We have learned about different data types: int

1. length
2. format

Format of course meaning ""how it is understood"". You will notice that structures are very similar in this respect

It turns out you can create your own data type using a structure definition you made. Once you make this data type, or any other data type.

To do this

        struct first_description {
            char first_word[7];
            char second_word[12];
            char third_word[8];
        };

You do this:

        typedef struct first_description {
            char first_word[7];
            char second_word[12];
            char third_word[8];
        } reddit_type;

I just created a new data type called ""`reddit_type`"". I can call it anything I want. In this case, or anything else.

Instead of writing this:

        struct first_description *our_pointer = malloc( sizeof(*our_pointer) );

I can write this:

        reddit_type *our_pointer = malloc( sizeof(*our_pointer) );

What I am literally saying here is: ""Make a pointer of data type `reddit_type` and allocate 27 bytes for it.""

*nothing else changes*. If you make just those changes to example 83 you will see the program works identical.

This is extremely important because you can create functions that have a return type of `reddit_type`

You will run into this a lot in C. You will be reading source code and see a function definition that looks like this:

    circle some_function(

This means that some_function returns.. a circle? Yep

----

Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9t2r9/lesson_85_tictactoe_with_ai_part_1/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9svba/lesson_84_you_can_make_your_own_data_type_using/
1254557143.0,9qfha,Lesson 49 : Introducing Conditional Flow Statements.,CarlH,107,37,24,"This is a very important lesson. Without the understanding contained here you can never write a worthwhile program in *any* language. Indeed

Let's begin.

Up until now we have only written code which follows this structure:

    Statement 1;
    Statement 2;
    ...
    Statement N;

Basically, but it is still forced to follow a set path.

Now we are going to advance past this understanding. One of the most important capabilities of any computer is the ability to test something

It may surprise you to know that one of the ways your computer compares two things to see if they are equal is by using subtraction. There is a single-bit binary flag built onto your CPU-chip called the ""zero flag"". It is set to either 1 or 0. In fact

This explanation is a bit ironic, the result of the last comparison was zero"". False (0) means, ""The result of the last comparison was anything other than zero."" 

If this is unclear to you, then 5 is in fact equal to 3.

In the context of comparing two values

Do not worry about using the zero-flag in your actual programs. You will never need to (unless you learn assembly language). I am presenting this to you mainly to show you some of the finer details of what goes on behind the scenes inside of your computer. 

Imagine this code:

    int height = 5;

Now

First

    Figure (a)

    if (height == 5) {
        printf(""The value is five!\n"");
    } 

This printf() statement will only execute if height is in fact equal to five. You will notice that there are two equal signs in that statement. Pronounce the two equal signs as: ""is equal to"". Why two equal signs? Because we have already defined what one equal sign means.

If I write: `int height = 5;` I am using one equal sign, we need a different operator to test if something *is equal*. Therefore, two equal signs (*not* one) are used to determine equality.

This is very important

    if (height = 5) { &lt;--- Very bad
         ...
    }

Why? Because you are actually setting height to be equal to 5 as part of the statement. You are *not* testing whether height is equal to 5. Whenever you assign a value like this, and you compile and run the program, it will appear to work perfectly. 

I was not sure if I would show you what I am about to. This is actually a very simple process

In machine code (slightly translated)

    SUBTRACT 5 from whatever is in the variable height (however
    (now a zero flag gets set to either 1 or 0)
    IF Zero Flag (ZF) is set to 1 (meaning height is equal to 5)

Believe it or not

So in this lesson you have learned that C or any language has the functionality to allow you to test equality between two different things
----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9qh89/test_of_lessons_40_through_49/

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qfha/lesson_49_introducing_conditional_flow_statements/
1254513690.0,9qask,Lesson 48 : Using pointers to manipulate character arrays.,CarlH,137,67,45,"In an earlier lesson we talked about setting a pointer so that it contains the memory address of a string constant. I pointed out that with a string constant you are able to read the characters of the string but you are not able to change them. Now we are going to look at a way to change a string character by character. 

The concept we are going to look at is that of being able to start at the beginning of some data and change it by moving byte-by-byte through the data changing it as you go. This is a critical concept and we will be doing a great deal of this later. 

First lets start with this code:

    char string[] = ""Hello Reddit"";
    char *my_pointer = string;

    printf(""The first character of the string is: %c""

The output will be:

    The first character of the string is: H

This should make sense to everyone at this point. `*my_pointer` refers to ""what is at"" the memory address stored in the pointer `my_pointer`. Because `my_pointer` is looking at the *start* of our array

Notice that we do not need to put &amp;string. This is because string

Because our string is part of an array of variables of type `char`

    *my_pointer = 'h';

What we have done now is to change ""what is at"" the memory address which used to contain an 'H'. Now it contains an 'h'. This should be pretty simple to understand. Recall that we could not do this when we created the string using a char* pointer

Now

This is perfectly valid:

    char string[] = ""Hello Reddit"";
    char *ptr = string;

    *ptr = 'H';

    ptr = ptr + 1;
    *ptr = 'E';

    ptr = ptr + 1;
    *ptr = 'L';

    ptr = ptr + 1;
    *ptr = 'L';

    ptr = ptr + 1;
    *ptr = 'O';

This works fine because C will store your array of characters exactly the right way in memory

Now notice that what we have done is very simple. We started at the first character of the array, but now for the first time we are actually able to do this in a real program. 

If at the end of this

    printf(""The string is: %s \n""

We will get this output:

    The string is: HELLO Reddit

Notice that it is perfectly ok that we ""changed"" the 'H' to an 'H'. When you assign a value to data at a location in memory
----
Ok guys

I may not be able to get to some questions until tomorrow. If any of you can help out those with questions in earlier lessons that you know how to answer - it would be great :)

----
Please ask any questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9qfha/lesson_49_introducing_conditional_flow_statements/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qask/lesson_48_using_pointers_to_manipulate_character/
1254421579.0,9py2s,Lesson 40 : Pointers have memory addresses too!,CarlH,140,67,24,"Up until now we have learned a lot about pointers. In the previous examples I have used 16-byte ram to make it easy to understand how variables are stored in memory. 

I have also showed how pointers can be used to point at variables inside memory.

Now we need to consider something else about pointers. Pointers have to exist somewhere inside of your memory also. That means whenever you create a pointer

Lets consider the following code:

    unsigned short int height = 10;
    unsigned short int *ptr = &amp;height;

Only for the sake of this lesson

1. The data type `unsigned short int` is only one byte in size.
2. You only need one byte to store a memory address (eight bits).
3. Our pointer `ptr` will reside in only a single byte of memory.
4. the variable `height` will reside at position 1000 in memory.
5. The pointer `ptr` will reside at position 0100 in memory.

Now

    ...
    0011 : 
    0100 : 0000 1000 &lt;--- ptr lives here. The value of ptr is 1000 (the memory address of height)
    0101 : 
    0110 :
    0111 : 
    1000 : 0000 1010 &lt;--- height is here. The value of height is 1010 (ten)
    1001 : 
    ...

Notice that ptr is really no different than any variable. It has a memory address

In an earlier lesson we saw that variables are plain English names that correspond to values stored at specific memory addresses. For example

When you create a pointer

Your programming language keeps track of the address in memory of a pointer the same way as it does a variable. A pointer and a variable are much the same thing in this sense. 

So lets consider the following code:

    int height = 5;
    int *my_pointer = &amp;height;

Now

1. If we write `my_pointer` we are referring to the value stored in `my_pointer`
2. If we write `*my_pointer` we are referring to ""what is at"" the memory address stored in `my_pointer`. In other words

What does `&amp;my_pointer` refer to? 

Well, not what is stored there. In our above 16-byte ram example, `&amp;my_pointer` would refer to 0100 -- the address where `my_pointer` resides.

In summary: A pointer has to reside in memory somewhere
----
Please ask questions if any of this is unclear. Be sure you master this and all earlier material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pyom/lesson_41_why_do_i_need_to_know_pointers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9py2s/lesson_40_pointers_have_memory_addresses_too/
1342902575.0,wxqnn,"[CarlHProgramming] An update for everyone, and plans for the future.",CarlH,84,17,http://www.reddit.com/r/carlhprogramming/comments/wxqnn/carlhprogramming_an_update_for_everyone_and_plans/

I am still in the process of converting the existing lessons to video

After that, then I am going to do two things:

1. I am going to start where I left off

2. I am going to start a new course on LAMP (Linux Apache MySQL and PHP)

I will be running the ""C"" course and the ""LAMP"" course concurrently. The  idea is that I will be simultaneously teaching how to build *real* applications, including some frameworks like extjs, jquery, and prototype.

Thoughts and suggestions are welcome.
",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/wxqnn/carlhprogramming_an_update_for_everyone_and_plans/
1255763514.0,9uy0a,Lesson 98 : Introducing Arrays of Pointers Part Two,CarlH,79,8,5,"Before I continue the last lesson

It is possible in C to have

When you look at a string of text like this:

    ""Hello Reddit""

Do you try to understand the individual ASCII of each letter? No

Pointers are the same way. Any pointer at all no matter how complex

A pointer is just a variable of the data type `memory address`.

It is an exercise in futility to try and understand every detail about a chain of complex pointers. Further, pointer, and data element that is in the program. 

That is simply impossible for anyone to do.

I am going to present ""pointers to pointers"" as data types below. First I am going to do it *wrong*. Then I am going to do it *right*.

The *wrong way* to understand pointer data types:

    int * = a pointer to an integer.
    int ** = a pointer to a pointer to an integer.
    int *** = a pointer to a pointer to a pointer to an integer.

Confused yet? Good! It means you are human.

Now

    int * = a pointer to an integer.

So far so good... What about `int **` ? 

Do not think of it as `int **`. Think of it as ""two star int"". A `two star int` is a pointer to a `one star int`.

What about `int ***` ? Well

The idea that there is a ""two star int"" data type is massively easier to understand than that there is some ""(int **)"" data type.

Don't worry if you are a bit confused. It will all be crystal clear in a minute. 

Now

    int ******some_pointer = ?

If you start by saying ""Well it is a pointer to a poi..."" you are doing it wrong. Count the `*` characters. There are six. This is therefore a `six star int`. Subtract one. That is the data type we are pointing to. In other words

What is a ""five star int""? It doesn't matter. It is enough to see this and realize that it is some level of pointers. More than that is utterly unnecessary. Just realize that this *is* some data type. That our pointer can therefore point to variables of this data type

Yes

With this in mind

    int height = 5;

    int *one_star_int = &amp;height;

    int **two_star_int = &amp;one_star_int;

    int ***three_star_int = &amp;two_star_int;

    int ****four_star_int = &amp;three_star_int;

    printf(""The actual value of height is: %d \n""

Was that hard? Notice something interesting. When we de-reference the final pointer, we would have used three stars. 

Here are printf() for each level of int pointer we did:

    printf(""The actual value of height is: %d \n""
    printf(""The actual value of height is: %d \n""
    printf(""The actual value of height is: %d \n""
    printf(""The actual value of height is: %d \n""

How do we know that each of these are going to give us the *original value* ? Because the number of `*` characters corresponds to how many levels deep the pointer is. It is as simple as that.

It would be a great idea if you took the material in this lesson and experimented with it so that you can better understand multiple levels of pointers. 

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v2lo/test_of_lessons_85_through_98/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9uy0a/lesson_98_introducing_arrays_of_pointers_part_two/
1255228978.0,9sv3g,Lesson 82 : Using a data structure,CarlH,74,6,11,"Now you know how to describe and allocate memory for a data structure. Let's review the code we have already written:

    struct first_description {
        char first_word[7];
        char second_word[12];
        char third_word[8];
    };

    struct first_description *our_pointer = malloc( sizeof(*our_pointer) );

Now we have a chunk of 27 bytes somewhere in memory that C understands we plan to use for our data structure. What is in those 27 bytes is anyone's guess

Now we need the ability to store data into the elements of our structure. This is not difficult at all. We treat our data elements exactly as you would expect. For example

Let's go ahead and set up our data structure.

Before I show you the actual syntax

    strcpy(first_word
    strcpy(second_word
    strcpy(third_word

Here you understand exactly what we are trying to do. However, third_word`) do not actually exist as unique variables. They are part of a data structure we created.

The question is

    data_structure.element_name

This is the syntax which makes it possible to *use* elements in a data structure. Remember that ""data_structure"" is *not at all* the same as ""description name"". Rather

We created our data structure using a pointer. We gave the pointer a name of: `our_pointer`. Now

1. `our_pointer` is the *memory address* where the structure begins. All pointers contain a memory address. 
2. `*our_pointer` is ""what is at"" that memory address. In other words... `*our_pointer` is the *actual data structure*. 

Do not get these mixed up. `our_pointer` is the memory address. `*our_pointer` is the actual data structure. Now

We need to say:

    strcpy( (*our_pointer).first_word
    strcpy( (*our_pointer).second_word
    strcpy( (*our_pointer).third_word

This is *entirely valid syntax*. 

`(*our_pointer)` is the data structure itself. We put a period and then the element name. Now

    printf(""One string is %s \n""

Output:

    Reddit

You can probably guess from this lesson that structures must be used a lot

Instead of having to write this:

    (*our_pointer).first_word

You can write *this* instead:

    our_pointer-&gt;first_word

They are identical. The second is just a short-cut method of doing this.

Now

This program is Lesson 83

----

Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sv62/lesson_83_sample_program_illustrating_data/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sv3g/lesson_82_using_a_data_structure/
1255226084.0,9sutx,Lesson 81 : Allocating memory for a data structure.,CarlH,77,7,27,"The first step in being able to create a data structure is describing it and giving that description a name. However

So it is in the case of a data structure. Recall our struct definition looks like this:

    struct first_description {
        char first_word[7];
        char second_word[12];
        char third_word[8];
    };

How much memory do we need? Well, no. 

C has a built in function called sizeof() which will tell you the size in bytes of virtually anything. We can get the total size in bytes that we need for any data structure using the sizeof() function.

We know that we are going to be allocating 27 bytes of memory for our data structure. That should tell you that we will be using the malloc() function. The malloc() function returns a *pointer* to the memory that is allocated. 

How did we use malloc() last time? Like this:

    char *some_pointer = malloc(100);

100 is the number of bytes

    ""Allocate 100 bytes of memory and store the memory address in some_pointer""

With a structure, and who knows what else. 

Remember that the whole reason you specify a data type for a pointer is so that the pointer knows how big and of what format the data will be. We therefore need to create a pointer that knows that we are using a data structure

Why? Because we will be *using* this pointer to *look at* chunks of memory that we have allocated. How else will we see what is inside our data structure? Our pointer will not know when we are looking at an integer

That may sound like a difficult thing to do

A pointer to the data structure itself.

Let me expand on that a bit. We are not going to say ""Create a pointer to data type char"" or ""Create a pointer to an array"". We are going to say: 

""Create a pointer specifically to a data structure which has three elements, and the last element having 8 bytes.""

In other words, or anything at all. 

Watch this syntax carefully:

    struct first_description *our_pointer = malloc(27);

First notice the struct keyword. Then you see the name of the *description* we created earlier. This tells C exactly what kind of data structure we plan to work with. Next you see that we put a `*` character. This tells C that we are creating a pointer. Then the pointer name - whatever we want. Finally

That is all there is to it. There is however an issue. The issue is

    struct first_description *our_pointer = malloc( sizeof(*our_pointer) );

Notice I put: `sizeof( *pointer_name )`. Notice I do this in the same line that I created the pointer. C can determine the size we need by just looking at the data structure description we made earlier

These two lines are *identical* in function:

    struct first_description *our_pointer = malloc( sizeof(*our_pointer) );
    struct first_description *our_pointer = malloc( 27 );

Both are saying that we are allocating 27 bytes. One lets C do the math for us

The purpose of this lesson was to learn how to actually allocate enough memory to work with a data structure definition you have made. In our case

    struct description_name *pointer_name = malloc(size);

and size should be: sizeof( *pointer_name )

----

Please ask any questions before proceeding to the next lesson.  When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sv3g/lesson_82_using_a_data_structure/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sutx/lesson_81_allocating_memory_for_a_data_structure/
1255051748.0,9s8wg,Lesson 71 : Review of Pointers Part Five,CarlH,76,3,20,"Recall from earlier lessons that I stated you have to give a pointer a data type so that C knows what you will be pointing to. For example

Why was that? Because if I told you ""Give me what is at memory address 1000"" you would not know *how many bits* to give me. In other words

Recall our code from the last example:

    char my_string[] = ""Hello Reddit"";

    char *my_pointer = &amp;my_string;    &lt;--- This is different

When you say `&amp;my_string`

How is that possible? The whole array doesn't have a memory address. That is exactly right. However

What happens when you tell C to create a pointer to an integer? Well

In other words, we will not be asking for eight bits - but however large the array itself is. 

In our example, I plan to use it to *see* 13 bytes at once.""

This is the key difference. C is a unique and powerful language in large part because of the way you can use slightly different syntaxes to mean different processes and operations. This can also serve to make C more confusing than other languages.

Keep in mind that setting the pointer equal to `&amp;my_string` is *incorrect*. Why? Because we did not define our pointer as a pointer to a data type of *multiple* array elements

Whenever you use just the name of an array

However, you are saying instead: ""I have a pointer which will point to N bytes, each byte being of data type char"".

Now

    int height = 5;
    int *my_pointer = &amp;height;

Assume int is 4 bytes. What are we saying here? We are saying that we want a pointer that will point to the single memory address where ""height"" begins

Now this:

    char my_string[] = ""Hello"";
    char *my_pointer = &amp;my_string;

""I want a pointer called `my_pointer` that will contain the memory address where the array `my_string` begins in memory. However

Now

1. `my_pointer = my_string` Means: Assign the memory address of `my_string` into `my_pointer`
2. `my_pointer = &amp;my_string[0]` Means: Assign the memory address of the first element of `my_string` into `my_pointer`
3. `my_pointer = &amp;my_string` Means: Assign the memory address of `my_string` into `my_pointer`

Therefore

----

At this stage


When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9s8wp/lesson_72_using_pointers_with_offsets/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9s8wg/lesson_71_review_of_pointers_part_five/
1254424972.0,9pyom,Lesson 41 : Why do I need to know pointers?,CarlH,148,82,49,"A lot of you have asked or have wondered why this material is worth knowing. This is a great question

It has been said in many books and by many students that pointers are one of the most difficult subjects in programming. For this reason I have taken the subject very slowly and I hope that everyone has been able to understand the material. Please let me know if that is not the case.

You may be wondering though why I am spending any time on it at all. Why do you need to see what is at some memory address of a variable that is already at that address? In other words

First of all

Think of it like this. I had to teach you binary before I could teach you about how data is encoded

It is the same with pointers. If you know pointers, and applications that you simply would not be able make if you didn't know pointers. There is an enormous chasm of programmer skill between programmers who know pointers, and programmers who do not.

Now I want to show you just how fundamental pointers really are.

You are reading this text on a web browser, exactly like the pointers we have talked about, is scanning through your video memory, and replacing it with new data. This is in fact what makes your screen change. Every application that ever draws, writes, or otherwise makes any change to what is displayed on your screen uses pointers to do it.

If you have ever used a graphics program which had an ""eye dropper"" tool where you can select a color just by clicking on it, erasing, or anything else you do in an art program uses pointers to do it. 

Program that play sound or music files work by having a pointer look at the start of the sound in memory

Every program you have ever used, requires pointers to read and manipulate memory continually. Pointers are the *only* way you can see and understand any data that is greater than a few bytes in size. This is the fundamental point I want you to understand:

Pointers make it possible to read and manipulate data in memory which is larger and more complex than a data type (int, you can do hardly anything.

In other words

This course has barely started
----
Feel free to ask any questions about this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9q01u/lesson_42_introducing_the_char_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pyom/lesson_41_why_do_i_need_to_know_pointers/
1349567708.0,112cd2,"When this post is 1 hour old, the live streaming session for ""How to build a web application framework from scratch"" will begin.",CarlH,72,6,http://www.reddit.com/r/carlhprogramming/comments/112cd2/when_this_post_is_1_hour_old_the_live_streaming/, sorry about that.
",,t5_2r81y,1349588864.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/112cd2/when_this_post_is_1_hour_old_the_live_streaming/
1256273728.0,9wweg,"Lesson 113 : Introducing ""Finish Criteria""",CarlH,77,8,5,"Back on Lesson 85 when I first introduced that we would be doing a tic-tac-toe program

This will also give me an opportunity to show you some of the methods and thinking processes which go into designing a program in general. As much as it is possible

However

The first step to writing any program

Your program, or a series of desired features. It is a list of statements of fact.

To those considering a career in programming

The reason I refer to this as ""finish criteria"" is because it leaves no doubt in anyone's mind that once these statements are true, and there is nothing left to debate. 

Always remember the following:

1. You should not write your first line of code or even agree to do any project until the finish criteria is *written* and *agreed upon* by you and whoever it is who has hired you to write the program, how could you agree to do it? 

2. Once the finish criteria is in place, then great: finish the project, then work on adding the new features. 

3. Sometimes #2 is not possible, and re-write the new finish criteria. Make sure it is agreed upon by everyone. Remember that any finish criteria should have a ""back out"" option for you if that criteria changes. If the finish criteria changes, you should be the one who is able to agree or disagree on being able to finish the newly defined project.

Now

1. Your finish criteria will double as documentation once the project is finished. Very little if any editing will be needed to describe the final product. This will also help you and others who may work on the project later. Everyone will know exactly what was expected and therefore managing and maintaining the project will be much easier. Important features are less likely to be accidentally discarded because someone didn't know that feature was supposed to be there.

2. Doing this will protect you against what anyone who has freelanced knows as the ""expanding horizon"". This is when whoever has hired you expects you to keep working for them

3. Doing this will help you to better understand the project. Writing out the finish criteria will double as a project plan. It is a simple process to convert a statement of fact into a statement of what needs to be done in order to make that fact true. By clearly writing out the finish criteria you will find that it is easy to break it down into easier and easier tasks. If you do this a few levels deep

4. You *will* finish projects faster. You will understand what is required clearly and you will not find yourself in a situation where you do not know what to do in order to finish the project. You will enjoy your work more because it will require less stress. Also

Hopefully in this lesson I have stressed the importance of properly defining the finish criteria of any programming task before you start it. In the next lesson

----

Please ask any questions before proceeding. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9y6os/lesson_114_simple_project_management/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9wweg/lesson_113_introducing_finish_criteria/
1255989375.0,9vnxw,Lesson 106 : Understanding Multi-Dimensional Arrays Better : Part One,CarlH,74,4,11,"As you recall from earlier lessons

We stated that we were going to use our ten bytes in the following four interesting ways:

1. As ten characters
2. As two integers
3. As a 2x5 text array
4. As a data structure

We are now half way through this series. The next goal is to show you how to use these 10 bytes as a 2x5 text array.

Let's discuss the structure behind a multi-dimensional array.

If we start with the basics

The simplest kind of array is a one dimensional array. Here is an example of a one dimensional array:

    char simple_array[] = ""abcdef"";

In this example

If it is a one dimensional array

    Figure (a)

    array[23]

Each of these examples are easy to understand. You just consider the number that is in brackets and you know exactly what item of the array I am referring to. For example, Element #1, Element #2... All the way to Element #10.)

Consider how much this changes when I switch to a two-dimensional array such as in the following examples:

    array[3][2]

These three examples are not nearly as simple as those found in Figure (a).

Remember from earlier lessons that memory is linear inside a computer. Therefore any multi-dimensional array is actually just a one dimensional array in disguise. It may then seem that you can determine just by looking at the above examples where exactly I am referring to within a two dimensional array.

Let's start with this example: `array[3][2]`. Where am I referring to here? 

You might try some creative math to answer this question. Are you trying to add 3 and 2 together? How about multiply them together?

You can try all the creative math you want

Remember this: Before you can calculate any array index of a multi-dimensional array

So if I am considering the element at: array[3][2] in some two dimensional array

Notice that for a one dimensional array this is not important. If it is a one dimensional array

Therefore to answer the question posed earlier, the array index we are considering.

Here is an example of a two dimensional array being created. The numbers within the brackets define the maximum dimensions of the array. These numbers are necessary in order to calculate any index of this array.

    char array_2d[10][5];    // &lt;--- This creates a two dimensional 10x5 array

Now that we know how the array was created

From this lesson

In the next lesson

----

Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9vvfg/lesson_107_understanding_multidimensional_arrays/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9vnxw/lesson_106_understanding_multidimensional_arrays/
1255402684.0,9tfn4,Lesson 86 : The need to initialize data,CarlH,77,11,13,"Don't let the title fool you. We are still working on our Tic-Tac-Toe project

The purpose of this project is to write a tic-tac-toe game which can be played with one or two players

As I said in the last lesson

The data component is where all information related to our tic-tac-toe board will be stored. The rest of the program will use this data component in order to do all of the processing which will make our program work.

This processing is achieved through a range of functions designed for different tasks related to reading from and writing to the data. Some categories of such functions include:

1. Data Initialization
2. Data Manipulation Operations
3. Evaluation and Analysis
4. Rendering and Display

These are the four categories we will start with. Keep in mind that these topics are unlikely to be taught in any tutorial/book whose purpose is to teach a programming language in general. These have nothing to do with a particular programming language

We are going to start with the ""Data Initialization"" category.

Initializing data simply means setting it to *something* before you begin working with it. More specifically

Any real program requires this. For a web application, this might be a blank scenery with no mountains/enemies/other objects. For a graphics program, a blank drawing, and so on. 

Now

There are many reasons why you must create a base state. The most important reason is that *every function* you write should expect a certain kind of data. If the data is not exactly the way a function expects

Therefore, it must be able to recognize and react when it is not given what was expected. Do not forget this.

By knowing exactly what kind of data a function expects

This leads to many problems. Imagine you have ten functions where function #1 does something, the end user), something may have gone horribly wrong. Finding what went wrong and troubleshooting it will prove to be a nightmare as any function along the way could have been the culprit. Worse still is that fixing such a problem is almost guaranteed to create new problems.

Therefore

----



Please ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9tfzh/lesson_87_introducing_the_constructor_function/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tfn4/lesson_86_the_need_to_initialize_data/
1255219926.0,9sua0,Lesson 78 : Introduction to Data Structures in C,CarlH,79,12,3,"Please be sure you have fully mastered all lessons through Lesson 77 before proceeding. 

----

Having just finished arrays

We have covered a lot of material in the course up to this point

This lesson is meant to answer two questions before we delve into this complex topic: What exactly is a data structure

A data structure is a collection of data elements. In this sense

1. An array requires that all elements be of the same data type. A true data structure has no such requirement. For example, and anything else you can imagine. 
2. An array requires that all elements be of the same length. A true data structure has no such requirement. You can have some elements 10 bytes long

Now

For starters

Here are some examples:

In a word processing application, color, background color, whether or not it is bold, and more. 

In a game, maybe the strength of a shot and various other details. Similarly, you would likely have a data structure to keep track of each enemy. Information contained in the data structure may include the location of the enemy on the map, the type of enemy, the speed it can travel, direction it faces, etc. 

There is not a single major application or game I can think of which does not use data structures heavily. You simply must learn this.

Also

We have a lot of material to cover

----

Please ask questions if you need to. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sugb/lesson_79_the_need_to_describe_a_data_structure/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sua0/lesson_78_introduction_to_data_structures_in_c/
1255043463.0,9s7qd,Lesson 67 : Review of Pointers Part One,CarlH,76,9,11,"Upcoming lessons are going to rely heavily on you having mastered pointers. Before we begin these advanced lessons

Let's begin.

A pointer is a variable that can hold a memory address. More specifically, is a memory address.

Now, followed by the name of the variable. Why do you need to specify a data type? Because besides holding a memory address, a pointer needs to know how *big* something is that it will be looking at, as well as what format the data will be in. This is because pointers are used to ""look at"" the contents of memory at a given memory address.

Here is how to create a pointer:

    char *my_pointer;

You can optionally assign the pointer a value.. a what? A memory address. 

To assign a pointer a value at the same time as you create it

    char *string = ""Hello Reddit"";

It *sounds* like I am saying: Make `string` a pointer *equal to* the string ""Hello Reddit"". This is false. Where is the confusion in this situation? It is in our understanding of an equal sign. Now

A single equal sign is an assignment operator. That's all. When you see an equal sign, let's re-think this statement:

    char *string = ""Hello Reddit"";

Instead of seeing this as: Set `*string` equal to the string ""Hello Reddit""

`string` is a pointer. It requires a memory address. It cannot be set ""equal"" to ""Hello Reddit"" because that is not a memory address, it *has* a memory address. 

Therefore

    char *string = ""Hello Reddit"";
    char *string (assignment operation involving) ""Hello Reddit"";

So if you think of the equal sign from now on as an operation that is intended to assign a value to something on the left

One note of caution: The above method works great if you are looking at valid C syntax involving pointers that you cannot understand

We will cover this more in the next lessons.

----
Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9s7qm/lesson_68_review_of_pointers_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9s7qd/lesson_67_review_of_pointers_part_one/
1254484631.0,9q5t9,Lesson 45 : More about strings and constants.,CarlH,143,71,45,"In the last lesson I explained that in addition to variables

First of all, this string of text *must* be stored somewhere in your memory. Lets go through the steps C (or any language) must go through in order to do this.

1. Find some location in memory to store the string of text.
2. At that location in memory
3. Exactly after the 'H'
4. Continue through this process until all characters of the string have been stored.
5. Add a NULL byte (all zeroes) at the end.

Keep in mind that this means that if your string of text is five characters long

Now consider this code:

    char *string;
    string = ""Hello Reddit"";

`string` is a pointer. Every pointer contains a memory address. `string` therefore contains the memory address to where this string begins. In other words

What if we now want to change this string to something else? Could we write for example:

    string = ""A new string"";

The truth is, `string` is a pointer. Pointers can only contain memory addresses. Not strings.

What happened to our old string of ""Hello Reddit"" ? It is still there

    string = ""Hello Reddit"";
    string = ""A new string"";
    string = ""Hello Reddit"";

With the third line of code

[Edit: It is true that many modern compilers will be smart and figure, you are not *changing* the text, you are creating a new string of text and pointing your string pointer at that new string of text.]

The next thing I need to address is that there are different ""kinds"" of memory. Now, your compiler as well as your operating system have *rules* about which memory you can use for various purposes. These kinds of memory exist as ""ranges"" within your available memory. 

It works similarly to this: 

    &lt;-------- Read Only -----------&gt;&lt;--------- Read/Write ---------&gt;

This small diagram is purely for illustrative purposes. The real details of how this works are more complex

Variables are placed into the ""Read/Write"" portion. Constants are placed into the ""Read Only"" portion. I hear you asking: ""What? There is a read only range of memory?"" And the answer is

Why is there a read only range of memory? Because as a programmer, never. 

When you as a programmer want to make sure that a constant doesn't change, then you intend that it does *not* change. Now, as any programmer reading this will attest, C's idea of *your benefit* and your idea of *your benefit* can differ. But it is the thought that counts.

At this stage you should understand: 

1. What is a constant? 
2. Why do constants exist?
3. Where and how are constants stored?

You are still probably wondering *why* did ""Hello Reddit"" get stored as a constant. The answer has to do with C syntax. If you write this code:

    char *string = ""Hello"";

OR this code (they are both identical)

    char *string;
    string = ""Hello"";

Then C knows that you want ""Hello"" to be a constant. We will talk soon about other ways to define strings in such a way they are not a constant

You are probably wondering

Not in this case. It is implicitly understood by C that because we are creating a char* pointer

You have used other examples of implicit keywords. For example: 

    int height=5;

Really means:

    signed int height = 5;

----
Please ask any questions if any of this material is unclear to you. Be sure you understand this before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9q7fs/lesson_46_a_new_way_to_visualize_memory/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9q5t9/lesson_45_more_about_strings_and_constants/
1254477648.0,9q543,Lesson 44 : Important Review and Clarification of Lessons 1 through 43,CarlH,139,70,23,"I have had a chance to go through and read hundreds of questions and replies from everyone. Before we proceed to the next lesson

Some of these involve possible misunderstandings that may have come about from the way I explained a particular topic. Others involve questions and replies in the comment threads.  

----

**Lesson 7 : Include Statements**

In this lesson I explained that you use include statements to ""copy and paste"" the contents of some programming source code into your existing program. With C and some languages

It is *extremely* bad programming practice to do things this way. You do not put code in a file

What you are really saying with an include statement is that you want to *use* the contents of the included file within your program. In other words

Think of this line:

    #include &lt;stdio.h&gt;

As meaning this: 

    I plan to use to use functions found in the stdio.h file in my program. 

----

**Lesson 19 : Basics of numeric overflow.**

When we speak of numeric overflow in the context of this lesson, that result will not fit in our four bits and thus we have a numeric overflow.

While there are similarities

----

**Lesson 20 : Basics of fractional numbers in binary.**

I have explained that the radix point is the term used for the equivalent of a ""decimal point"" in binary. I need to be extra clear on three points:

1. The radix point is not actually encoded in binary. Rather
2. The number to the left of the radix point is known as the ""integer part"".
3. The number to the right of the radix point is known as the ""fractional part"".

----

**Lesson 21 : The Basics of Numeric Data Types in C.**

I have not covered *all* numeric data types in that lesson

Also

Similarly

This does not matter if your goal is to write an executable program that you then deliver to systems running the same architecture and operating system as you. You will never need to worry about this in that case. That program *will run* on any computer that uses it if they have the same operating system and the same architecture (Example: 32 bit windows). 

If however you are writing code that will be open-source, you should let people know that as well as any other compiler unique optimizations and/or options you are using.

----

**Lesson 22 : The ""char"" data type and the basics of ASCII.**

Here and in general I showed you the following rules concerning how text and numbers are encoded in binary:

010 &lt;-- All capital letters start with this.
011 &lt;-- All lowercase letters start with this.
0011 &lt;-- All numbers start with this.

Keep in mind that this is *NOT* reversible. This means that you cannot say that *anything* which starts with 010 is a capital letter for example. There are many ASCII characters that are not numbers or letters

----

**Lesson 26 : Introducing variables.**

Here I showed how to create variables

    int height = 10;

The question was raised

    int height;

This is legal

That means whatever binary sequence just happens to be at that memory address will be the value of the variable. This is not a good thing. 

That is why as a programmer you should *always* initialize a variable to a value when you create it. Common practice is to assign a 0 to a variable until it is used if the value is not known at the time it is created.

----

**Lesson 28 : About terminating strings of text and other data.**

I am just going to quote zahlman here regarding the consequences of NOT terminating a string/other data properly:

&gt; The program might not print garbage; it might also crash, and will put a stop to things.

&gt; Technically, it is a common joke to refer to accidental firing of nuclear missiles as a result. Your computer is almost certainly not actually capable of firing nuclear missiles, but it gets the point across.

----

**Lesson 34 : Assigning a value to a pointer.**

One thing I did not cover at the time I made the lesson, and when you do not put spaces. 

For example:

    int          height = 1;
    int height       = 1        ;

Are both valid

Similarly

    int *ptr = &amp;height;
    int * ptr = &amp; height;
    int* ptr =        &amp;height  ;

etc.

----

**Lesson 39 : About pointers concerning multi-byte variables.**

Here I showed you the following code:

    int height = 5;
    int width = 10;

    int *some_pointer = &amp;height;

    *some_pointer = 8;
    some_pointer = some_pointer + 1;

    *some_pointer = 4;

Then I explained, and then changing `width` to 4. This *would* be correct if height and width reside in memory one right after the other. This is one of the assumptions being made about our 16-byte ram used in these types of lessons.

Do not ever write code like this in a real program. Your compiler chooses where to put variables you create and you have no way to know if they will be stored in ram the way this example assumes they are. The code above from this lesson is for instructive purposes only

----

**Some clarifications about printf**

It has not been addressed directly in a lesson

    int height = 10;
    int width = 5;

    printf(""Height is %d and Width is %d \n""

This will have the output:

    Height is 10 and Width is 5

Next

There are special ASCII characters which have meaning other than what you see on your keyboard. These characters are useful for tabs, for those who are curious, looks like this:

    0000 1010

In other words

The final clarification I want to make concerning printf() is that many of you have used printf() with the %p option to print the addresses of pointers

    printf(""The address is: %p""

What will be printed is the address *IN* `some_pointer`

    int height = 10;
    int *some_pointer = &amp;height;

    printf(""The address is: %p""

Do not do this. Remember that `*some_pointer` translates to: ""Whatever is at the memory address stored in the pointer"". It does **not** translate to: ""The address of the pointer"". It also does **not** translate to: ""The address stored in the pointer"".

Using `*some_pointer` in the above example results in: 10

----
Please fully review this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9q5t9/lesson_45_more_about_strings_and_constants/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9q543/lesson_44_important_review_and_clarification_of/
1254307941.0,9pgmv,Lesson 32 : Introducing the pointer data type.,CarlH,149,77,30,"For the purpose of this lesson

----

Lets examine the following code:

    char my_char = 'a';

Here I have stated that I am creating a new variable called `my_char`. I have stated to use the data type `char` for this variable. Now the variable `my_char` can hold any single-byte ASCII character I desire. In this case

    address of my_char : 0110 0001 &lt;--- ""a""

We do not know what the address is

Lets suppose that the variable ""my_char"" sits at position 1000 (eight) in our 16-byte RAM from the previous example:

    ...
    0111 : 0000 0000
    1000 : 0110 0001 &lt;--- ""a""; Here is my_char at position eight (1000)
    1001 : 0000 0000
    ...

Notice that `my_char` has a value as well as an address. The value is 'a'. The address is 1000 (eight). Any time you create any variable

Notice that the *memory address* of an ASCII character 'a' is *not* an ASCII character - it is a memory address. The data type of your variable is *not* the data type of the memory address where it is stored. A memory address does not care what kind of data is stored in it. I want to illustrate this using our 16-byte RAM example:

I am going to add some data before and after the 'a' to illustrate this.

    0111 : 0000 0101 &lt;--- This is the actual number 5
    1000 : 0110 0001 &lt;--- ""a""; Here is my_char at position eight (1000)
    1001 : 1100 0100 &lt;--- This is actually the start of some unrelated data.

There are three totally different kinds of data above. However

If I asked you, ""Please show me the binary sequence that is stored at position 0111"", or any other location in our 16-byte RAM example.

Notice that while you can give me the eight bits of data stored at that location, or something else - as we have learned in previous lessons.

Remember that we have learned that *any* binary sequence cannot be understood until we give it a ""data type"". A memory address is a binary sequence, or chars, or any other kind of data that might exist.

In computing


----
Please feel free to ask any questions before proceeding to: 

http://www.reddit.com/r/carlhprogramming/comments/9pimr/lesson_33_how_to_create_a_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pgmv/lesson_32_introducing_the_pointer_data_type/
1253886473.0,9o0ur,Questions about /r/carlhprogramming,CarlH,407,338,64,I am sure many of you will have questions about this course. Please feel free to ask your questions here. ,t5_2r81y,True
1335437460.0,stdom,"All Lessons, PDF ( made from 3-15, added previously made Unit 1&amp;2 ), Enjoy.",Sinnermario,10,,False
1256068448.0,9w07x,Lesson 108 : Understanding Multi-Dimensional Arrays Better Part Three,CarlH,72,3,12,"This used to be part of Lesson 107. I split this into two halves and added some material to make it easier to grasp. 

----

In the last lesson I showed you that our base ten counting system is itself a form of a multi-dimensional array. This is how we represent tens, and so on.

Now

First

1. It means that we have ten array elements

2. It means that we have ten 5x10 grids.

3. It means that we have ten elements where each element is a set of five words and each word can consist of up to 10 characters.

4. It is a ""half cube"" with a width of ten

Any of these methods of visualizing should help you understand this better.

We want to convert the array index [4][2][5] to a pointer offset. Remember that our array dimensions were defined as: [10][5][10]. Here is what now happens:

We have 10x5x10 (500) elements. First, we take 5 steps each one unit in size. 

In this way we have done: [4] large jumps

Now let's consider: [20][40][10] as our starting array dimensions. In this case

Don't worry if you are confused. It will be clear in a minute.

At this point all you really need to know is this: Any multi-dimensional array can be visualized by imagining that you have a pointer offset in memory which starts at 0. That offset will ""jump"" by the largest amount for the first set of brackets. Then it will jump by a smaller amount for the next set

All that is left now is to convert this to a mathematical formula. Before we do that

Consider an array created like this: 

    char five_d_array[10][10][10][10][10]

Even though this is a five dimensional array

Now, nine-hundred and twenty-one. Let's now convert that into a mathematical formula.

    ( 3 * 10

Remember that if you were standing on a zero, large jump over a hundred units nine times, two large steps over ten units, and then one small step to reach your destination.

Now the only thing that remains is understanding how we got our numbers for this formula. First
    
    [ E][ D][ C][ B][ A]
    [10][10][10][10][10]

Now

    [e][d][c][b][a]
    [3][2][9][2][1] = 32

For the array index I used lower case letters that correspond to the upper case letters. The upper case letters refer to the maximum dimensions of the array based on how it was created. The lower case letters refer to the actual index we are considering.

Before we can construct our formula

    char multi_dimensional_array[10][10][10][10][10];
    or...
    char multi_dimensional_array[ E][ D][ C][ B][ A];

    E_Size = (DCBA) = 10 * 10 * 10 * 10 = 10
    D_Size = (CBA)  = 10 * 10 * 10      = 1
    C_Size = (BA)   = 10 * 10           = 100
    B_Size = A                          = 10
    A_Size = 1                          = 1

Notice that `A_Size` is *always* equal to one unit. Notice that `B_Size` is always equal to `A`.
 
If that is confusing

Now

    [3][2][9][2][1]

Now we can calculate this offset very easily:

    ( 3 * E_Size) + (2 * D_Size) + (9 * C_Size) + (2 * B_Size) + 1

    (3 * 10
    30
    32
   
Now consider an array created like this:

    char three_d_array[5][3][9] &lt;-- dimensions of the array when it was created

In this case: 

    9 = A
    3 = B
    5 = C

The size of C is simply (BA) or 3*9. The size of B is simply (A) which is 9. 

How would we then identify the offset for: 3d_array[2][2][1] based on the above dimensions? Like this:

    ( 2 * C_Size ) + (2 * B_Size) + 1

    (2 * 27) + (2 * 9) + 1
    54 + 18 + 1
    73

And that is the answer. [2][2][1] in that array corresponds to element #73.

One more example: 

Consider an array created like this: [12][6][4][8]

    Largest Jump: 6*4*8 = 192
    Next Largest: 4*8 = 32
    Next Largest: 8

so

    (4 * 192) + (2 * 32) + (3 * 8) + 1
    768 + 64 + 24 + 1

Therefore

You should now be able to take any multi-dimensional array and convert it to a pointer offset. 

----

Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9webw/lesson_109_demonstrating_a_2x5_array_with_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9w07x/lesson_108_understanding_multidimensional_arrays/
1255848716.0,9v68b,"Lesson 105 : On the ""address of"" operator and pointers.",CarlH,80,10,6,"Up until now

You have understood that a pointer means ""something that contains the memory address of a variable (or pointer)"". Whereas

Now I want to help you to take this understanding to the next level.

Consider this code:

    int height = 5;
    int *int_pointer = &amp;height;

Here is what you may not realize: `&amp;height` is a pointer! 

Why is that? Because `&amp;height` is itself the memory address where `height` is stored

Therefore

From now on when you see operations involving the `&amp;` operator

Consider the following:

    int ***three_star_int = &amp;two_star_int;

Now

What is `&amp;two_star_int` ? It is also a pointer. What does it point to? It points to a `two_star_int`. Consider that the '&amp;' character can be considered as ""pointer to"" just as easily as it can be considered as ""address of"". The same terms mean the same thing. Containing the address of something is the same thing as pointing to it.

In fact

Consider this code:

    int height = 5;
    char my_char = 'a';

    int *int_pointer = &amp;my_char;

We get a compiler warning. What does it say?

     Warning: initialization from incompatible pointer type

What does this mean? It means that C is understanding `&amp;my_char` to be a *pointer* of one data type

Now consider the following:

    int height = 5;
    int *my_pointer = &amp;height;

'&amp;height' is a pointer of type int. `my_pointer` is also a pointer of type int. Therefore

If you are still not convinced

    char my_char = 'a';

    char *char_pointer = &amp;my_char; 
    int *int_pointer = char_pointer;  &lt;-- this line creates the warning message

We will get the *exact same* warning message: `Warning: initialization from incompatible pointer type`

So let's recap this short lesson: When C sees the '&amp;' operator

----


Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9vnxw/lesson_106_understanding_multidimensional_arrays/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v68b/lesson_105_on_the_address_of_operator_and_pointers/
1255839302.0,9v5ed,Lesson 102 : Arrays of Pointers Continued : Part Three,CarlH,80,12,1,"In the last lesson I showed you how to create an array of `one star` pointers. I showed you that you do so by creating a `two star` pointer that can point to these array elements. The only thing I didn't show you is how to do this using array indexing

It is not that different.

Here is the sample program we looked at in the last lesson:

    int height = 5;
    int width = 10;

    int **two_star_int = malloc(2 * sizeof(int *) );

    *(two_star_int + 0) = &amp;height;
    *(two_star_int + 1) = &amp;width;

    printf(""The values are: %d and %d \n""

----

Here is this same program

    int height = 5;
    int width = 10;

    int **two_star_int = malloc(2 * sizeof(int *) );

    two_star_int[0] = &amp;height;
    two_star_int[1] = &amp;width;

    printf(""The values are: %d and %d \n""

----

It is exactly the same thing. Remember that array indexing is just another way of using pointer offsets.

    two_star_int[0] is the same thing as: *(two_star_int + 0)
    two_star_int[1] is the same thing as: *(two_star_int + 1)

Similarly:

    *two_star_int[0] is the same thing as: **(two_star_int + 0)
    *two_star_int[1] is the same thing as: **(two_star_int + 1)

Now that we have this out of the way

Remember that our goal through all of these lessons is simply to create an integer pointer at B0

    &lt; B0 B1 B2 B3 &gt; B4 B5 &lt; B6 B7 B8 B9 &gt;

The &lt; &gt; shows where we want our integers to be.

B4 and B5 will be ""unused space"". Now

First

    char *main_pointer = malloc(10);

Now

    int **int_pointer_array = malloc(2 * sizeof( int * ) );

The above creates our array of two integer pointers. One will be at byte #0

We have a ten-byte working space and we have an eight byte working space. 

Now

    int_pointer_array[0] = (int *) main_pointer;

Remember that the above line is the same thing as:

    *(int_pointer_array + 0) = (int * ) main_pointer;

This is no different than when we wrote: `int_pointer1 = (int *) main_pointer;` earlier in the lessons. It is just that now we are doing this using an array element.

----

Consider that we wrote this: `*(int_pointer_array + 0)`. This is the same thing as: `*int_pointer_array`. Why? Because adding 0 can be ignored altogether.

By putting a `*` in front of `int_pointer_array` we are no longer talking about `int_pointer_array`. Now we are referring to the `one star int` that it points to. Any time you put a `*` character in front of *any pointer* you are no longer referring to the pointer

With this code: 

    *(int_pointer_array + 0) = (int *) main_pointer;

    OR

    int_pointer_array[0] = (int *) main_pointer;

we are setting the first `one star int` in our array to the memory address that `main_pointer` is pointing to. That means we are now pointing to byte #0 of our ten-byte working space.

Now

    int_pointer_array[1] = (int *) (main_pointer + 6);

Remember

    *(int_pointer_array + 1) = (int *) (main_pointer + 6);
    
There you have it. Now let's assign some value to these two integers:

    *int_pointer_array[0] = 5;
    *int_pointer_array[1] = 15;

Why a `*` in front? Because we want to peel away all the layers of our `two star int` pointer. The array indexing automatically peels away one layer. A `*` character in front peels away the second layer. Why does array indexing peel off one layer? Because using array indexing is the same thing as using a `*` in front of the pointer with an offset.

Remember this: 

1. `int_pointer_array[0]` is the same thing as: `*(int_pointer_array + 0)`. 

2. `*int_pointer_array[0]` is the same thing as: `**(int_pointer_array + 0)`. 

Array indexing removes one layer. A `*` character removes another layer. Therefore

Now finally

    printf(""The values are %d and %d""

In the next lesson I will show you the final working program of everything you just learned. You will be able to see in action how we were able to use and re-use the same ten bytes of memory for different purposes.



----

Please ask questions if any part of this lesson is unclear.

When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v5l6/lesson_103_sample_program_demonstrating_pointers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v5ed/lesson_102_arrays_of_pointers_continued_part_three/
1255677912.0,9umha,Lesson 97 : Introducing Arrays of Pointers Part One,CarlH,77,10,21,"This lesson may appear a bit scary at first

----

In the last lesson I showed you a situation where we had two related pointers to which we gave the names: `int_pointer1` and `int_pointer2`. It should be apparent that if you have a situation that you are giving such names to variables or pointers in general

Why? Let's consider I have 5 such pointers:

    int *int_pointer1 = ...
    int *int_pointer2 = ...
    int *int_pointer3 = ...
    int *int_pointer4 = ...
    int *int_pointer5 = ...

Now, that could use each one? I could never do something like this:

    for (i = 1; i &lt;= 5; i++) {
        ... int_pointer i    (ex: int_pointer1
    }

There is simply no way to do this. C will not be able to take a partial variable name like `int_pointer` and figure out how to add an extra number at the end as part of a loop. On the other hand

    for (i = 1; i &lt;= 5; i++) {
        ... int_pointer[i] ...    (ex: int_pointer[1]
    }
   
Now this is doable. I can easily put a number inside of brackets as an array element. So to be clear

First, let's imagine how this would work. Here is a description of the array of pointers I plan to create:

    int_pointer[1] = Element [1] will be a pointer to some integer in memory.
    int_pointer[2] = Element [2] will be a pointer to a different integer in memory.

That is our goal. So

First of all, so I want to do the same here. 

Remember from previous lessons that having the memory is the *same thing* as having the data type that will fit in that chunk of memory. For example

From this

Well, this is not true for all systems. Therefore: We *cannot* use malloc() with the number 4 just because we think (or know) that the size of bytes we need is 4. That may be true on our system, but not others. In other words, we cannot *ever* trust that we know the size of any data type - with one exception: char.

Let me say that again, or pointers are 4 bytes, etc. Always use sizeof(). There is one exception. A `char` data type is *always* going to be one byte in size.

Now let's continue.

An array of pointers will look something like this in memory:

    ['Pointer #1']['Pointer #2']['Pointer #3']...

For this lesson, it would be something like this:

    B0 : ['Pointer #1']
    B4 : ['Pointer #2']
    B8 : ['Pointer #3']

Notice that each pointer starts 4 bytes later than the last one started. This is the very definition of an array. An array is a repeating collection of the same data type stored sequentially in memory one element immediately after the other.

----

How do you work with *any* array? You use a pointer. Therefore

But a pointer to what? What will our pointer be pointing to? Will it be pointing to integers? Characters?... No

Why? Because each pointer is to be stored in memory sequentially at B0, etc. That is the very definition of an array of pointers, which is what we want to create. We therefore need some pointer which will work like this:

    pointer[0] = ""point to B0"";
    pointer[1] = ""point to B4""; 
    pointer[2] = ""point to B8""; 

Do not worry about syntax right now. The above is a description of what we want, then B8. However, remember that array indexing is a shortcut for pointer offsets. Therefore, the above 3 lines could also be written like this.

    *(pointer + 0) = ""point to B0""
    *(pointer + 1) = ""point to B4""
    *(pointer + 2) = ""point to B8""

Why does adding one to our pointer get us to B4? Because the idea of pointer arithmetic is that you always increment by the size of the data type you are pointing to. Now

We are assuming in this lesson that a pointer is 4 bytes in size. So the first thing we need to consider is that we need to create a pointer of the data type `pointer`.

----

How do we create a pointer in general? Like this:

    data_type *pointer ...

What is our data type if we want an array of int pointers? Our data type is (int *) which means ""a pointer to an integer"".

Therefore

    (int *) *pointer ...

What does this mean? It means ""create a pointer called *pointer"". Of the data type ""pointer to int"". 

We are creating something called *pointer which will contain a memory address. The memory address it will contain will be the memory address where a pointer resides.

The syntax I showed you above is *nearly* correct. Let's take out the parentheses from `(int *)` for the data type

    (int *)  *pointer_name = ...

Becomes:

    int *   *pointer_name = ...

This is correct. We are saying to create a pointer called ""`pointer_name`"" which will point to the data type: `int *` which means ""pointer to an integer"".

So

Let's go back to our earlier example:

    B0 : ['Pointer to integer #1']
    B4 : ['Pointer to integer #2']
    B8 : ['Pointer to integer #3']

Let's consider our new pointer called `pointer_name` we just created. Can it point to B0? Yes. Why? Because B0 is a memory address which stores an integer pointer. It can point to B4 or B8 for the same reason. It can point to any memory address which contains a *pointer to an integer*.

Now, so lets create the actual array now:

    int *    *ptr_array = malloc(3*sizeof(int *));

`int *` is our data type. The second `*` indicates we are creating something that is a *pointer* to our data type (which is `int *`). Finally

Finally, since *all pointers* will be the same size.

Now

`ptr_array` is a pointer. It points to B0 of the 12 bytes we just allocated. So therefore:

    ptr_array = Byte #0 (The actual memory address)
    *ptr_array = *B0 (What is *at* Byte #0)

So what is `*ptr_array` ? It will be the actual *pointer* that resides at Byte #0.

How we can use the pointer at Byte #0 is the subject of the next lesson.

----

Last lesson for today. More tomorrow.

----

Please ask questions if you need to. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9uy0a/lesson_98_introducing_arrays_of_pointers_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9umha/lesson_97_introducing_arrays_of_pointers_part_one/
1255223292.0,9sulj,Lesson 80 : Introducing the 'struct' keyword.,CarlH,73,6,5,"In the last lesson I explained that you must describe a data structure before you can use it. In C

    struct &lt;give it a name&gt; {
        ... each element is described here ...
        ...
    };    &lt;-- notice you end it with a ; (semicolon)

From the above description you can see that you must give each structure a name. We have seen the same thing when you create variables or arrays

Unlike variables or arrays, not the actual data. This is not even setting up a place to *put* the actual data. It is only describing it. 

Therefore

Why do you have to give the description a name? Suppose you want to describe multiple kinds of data structures

Now

    ""Reddit$Programming$Classes""

So what we really need here are *three* character arrays. One for ""Reddit""

I will call the description: `first_description`

    struct first_description {
        char first_word[7];
        char second_word[12];
        char third_word[8];
    };

Notice I gave each element a name. I can name them anything I want

These are *not* variables in the typical sense. I am not actually creating anything here

Everything involving the `struct` keyword is *only a description*.

That is basically all there is to it. I have now *described* the data structure. Before we move on to the next lesson

    struct student_records {
        int student_record_number;
        char first_name[30];
        char last_name[30];
        char birth_date[10];
   };

Here I have *described* a data structure which will be used to keep track of student records for a school. Notice that I can mix different data types with no problem.

Remember that these are *only* descriptions

----

Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sutx/lesson_81_allocating_memory_for_a_data_structure/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sulj/lesson_80_introducing_the_struct_keyword/
1254576777.0,9qh89,Test of Lessons 40 through 49.,CarlH,110,38,3,"**Please do not post answers in this thread**

Someone who has not yet taken the test may see them. Be sure to review lessons 40 through 49 before beginning. If anything is unclear

----
**True or False**

1. You can use a &amp; character to obtain the memory address of a pointer the same as you can with a non-pointer variable.
2. The following is a good way to test equality: `if (height = 5) {`
3. When you create a text string using an array
4. Constants are typically stored in a read-only section of memory.
5. This code: `char *mystring = ""Hello Reddit"";` works by storing the entire string ""Hello Reddit"" into the pointer ""`mystring`"".

**Fill in the blank**

1. The only way you can see or work with any data larger than the basic data types (int, though some do this work behind the scenes.
2. A `_____` can be used to go through data one byte at a time in order to read it or to make changes to it.
3. An `_____` is a collection of data elements having the same data type.
4. A `_____` is a statement which conducts some test in order to decide between various sets of unique instructions to execute.
5. The `_____` flag on your CPU is used to evaluate all tests and comparisons and is therefore critical to all programs.

----
When finished

http://www.reddit.com/r/carlhprogramming/comments/9qh8y/test_of_lessons_40_through_49_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qh89/test_of_lessons_40_through_49/
1254419518.0,9pxq7,Test of Lessons 30 through 39 [Answers],CarlH,128,59,25,"If you missed any questions on this test or if you have any questions about the material
----

**True or False**

1. A string of text is stored in memory like a ""train""
2. When you create a pointer
3. Pointers can be used for looking at as well as changing data at a given memory address. **True**
4. If you use a pointer to replace data at a given memory address
5. Whenever you increase a pointer by one

**Fill in the blank**

1. A `_____` can be used as a way to refer both to the value at a given memory address
2. The `_____` character means ""address of"". **&amp;**
3. The `_____` character means ""what is at the address of"". ***
4. In the code in section (a)
5. If you wish to use printf() to print the memory address stored in a pointer, etc) **%p**


(a)

     unsigned short int width = 3;
     unsigned short int height = 9;

     unsigned short int *my_pointer = &amp;height;

     printf(""%d""

----
When you have fully reviewed and understood the material covered here

http://www.reddit.com/r/carlhprogramming/comments/9py2s/lesson_40_pointers_have_memory_addresses_too/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pxq7/test_of_lessons_30_through_39_answers/
1254343956.0,9pn3c,Lesson 36 : Use what you have learned.,CarlH,132,64,209,"This is not a typical lesson. This is a challenge to you in order to give you the opportunity to apply what you have learned.

Create your own program that demonstrates as much as you can about the concepts you have learned up until now. 

For example, characters, memory addresses (use %p - see the comment thread on Lesson 35), and anything you want. Experiment with different ideas, and be creative. Also, use pointers. 

Post your example programs in the comments on this thread. It will be interesting to see what everyone comes up with.

Be sure to put 4 spaces before each line for formatting so that it will look correct on Reddit. Alternatively

Have fun!

----
The next lesson is here:

http://www.reddit.com/r/carlhprogramming/comments/9pu1h/lesson_37_using_pointers_for_directly/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pn3c/lesson_36_use_what_you_have_learned/
1343299741.0,x6mn1,"[CarlHProgramming] All lessons through Course #1, Unit 10 now available as videos.",CarlH,77,9,http://www.reddit.com/r/carlhprogramming/comments/x6mn1/carlhprogramming_all_lessons_through_course_1/,,
1336830558.0,tjmoc,Thank you Carl !,Sinnermario,83,18,5,"I don't know if you read this but:

thank you for all the effort you have put into the lessons and making them available for us.

Your method of teaching is amazing, and not having a professor with such a well thought teaching methods as yours.

Your lessons are so easy to understand and well structured that allowed me to go through each Unit in max 1 hour


**Hat off with all respect to you sir !**",,t5_2r81y,1348402323.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/tjmoc/thank_you_carl/
1256270930.0,9ww0j,Test of Lessons 99 through 112,CarlH,69,4,66,"For this test

    1. Create a 'char *' pointer which uses malloc() to allocate enough space for a 2x10 array.
    2. Using pointer offsets as a replacement for array indexing
        1. Demonstrate using strcpy() how to store two null-terminated strings of up to ten characters.
        2. Demonstrate using printf() how to display both strings as part of a for loop.
        3. Demonstrate changing the character at position: [0][5] to an 'x'
        4. Demonstrate changing the character at position: [1][2] to an 'x'
        5. Write a printf() statement for 3
        6. Write and call a function to achieve step 5 above.

I recommend you post your finished program in this thread when you are done. When you post C code on Reddit

Be sure to use comments to help illustrate your understanding of what you are doing. If you choose to post your work is entirely 
up to you. If you do then we can critique your work and help you to improve.

If you get stuck or need help

**Feel free to post/link to your finished programs below.**

----

When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9wweg/lesson_113_introducing_finish_criteria/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ww0j/test_of_lessons_99_through_112/
1256156750.0,9webw,"Lesson 109 : Demonstrating a 2x5 ""array"" with pointer offsets",CarlH,69,4,11,"Now that we have finished the preceding lessons

I had also planned doing some lessons on how to use the ten bytes as a data structure

Now

----

First

    char *our_pointer = malloc(10);

Now the funny thing is

In order to store the data into our array

Remember from the last set of lessons that a 2x5 array will work like this:

    5 : 1D Component
    2 : 2D Component

Because 5 is our 1D component

    our_pointer[0][0] = Byte: 0
    our_pointer[1][0] = Byte: 5

Now we can use strcpy() to store words (four characters or less) at these locations.

    strcpy(our_pointer
    strcpy(our_pointer + 5

We can use printf() to show that this worked as expected:

    printf(""The first word is: %s""
    printf(""The second word is: %s""

There is of course one problem. We cannot use our array indexing the way we could if this had been created as a true char[2][5] array. Why is that? Remember from the last lessons I showed you that for any array greater than one-dimension

In our two-dimensional array

The truth is, this lesson would be incomplete if I did not show you how you could also use brackets to index this.

We will explore that in a few lessons. But first

----

    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;
    #include &lt;stdlib.h&gt;
    
    int main(void) {
    
    	char *our_pointer = malloc(10);
    
    	strcpy(our_pointer
    	strcpy(our_pointer + 5
    
    	printf(""First Word: %s \n""
    	printf(""Second Word: %s \n""
    
    	// Simulate array[1][1]

    	int B_Size = 5;  // Remember that B_Size is always equal to A. (5 in this case)
        int A_Size = 1;  // Unnecessary

    	printf(""array[1][1] would be: %c \n""
    	printf(""array[0][2] would be: %c \n""
    	printf(""array[1][3] would be: %c \n""
    
----

    	// simulate array[0] and storing a word using strcpy()

    	strcpy((our_pointer + (B_Size * 0))
    	printf(""array[0] string is: %s \n""

Don't let `(our_pointer + (B_Size * 0)))` scare you. Anything times zero is zero. Therefore

This is the same thing as:

        strcpy(our_pointer
        printf("" ... %s""

----

    	// simulate array[1] and storing a word using strcpy()

    	strcpy((our_pointer + (B_Size * 1))
    	printf(""array[1] string is: %s \n""

Don't let `(our_pointer + (B_Size * 1)))` scare you. `B_Size * 1` is just `B_Size`

This is the same thing as:

        strcpy(our_pointer + 5
        printf("" ... %s""

----

    	return 0;
    }

Output:

    First Word: two
    Second Word: word
    array[1][1] would be: o 

w**o**rd

    array[0][2] would be: o

tw**o**

    array[1][3] would be: d

wor**d**

    array[0] string is: test
    array[1] string is: ing


----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9wp0b/lesson_110_the_practical_use_of_functions_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9webw/lesson_109_demonstrating_a_2x5_array_with_pointer/
1255836793.0,9v573,Lesson 101 : Arrays of Pointers Continued : Part Two,CarlH,80,14,7,"In the last lesson I explained that because we are creating an array of `one star int` pointers

Put in more technical terms

Why is that? Because the thing that points to a `one star int` is a `two star int`. 

Now

    int **two_star_pointer = malloc(2 * sizeof( int * ) );

Now the only question that remains is

Well

1. We need a way to ""set"" the value of each element of the array

2. We need a way to ""see"" the value of each element of the array.

Let's create a couple of simple integers to work with:

    int height = 5;
    int width = 10;

Alright

    B0 : [Integer Pointer #1]
    B4 : [Integer Pointer #2]

Now we know that `two_star_pointer` already contains the memory address for B0. Therefore

Let's re-word the above paragraph:

`two_star_pointer` is the memory address where a `one star pointer` lives.

`(two_star_pointer + 1)` is the memory address where a different `one star pointer` lives.

Alright

Remember that if I say: `char *some_char_pointer = malloc(10)`

It is the same thing here. We already have our two `one star int` pointers. They just happen to be set to whatever the malloc(8) gave them. Now it is time to change that

If `two_star_pointer` is the memory address of a working `one star int` pointer

So how can we set that `one star int` pointer to have some value? Like this:

    *two_star_pointer = &amp;height;

Think about it. `*two_star_pointer` refers to what is actually at that memory address, which happens to be a `one star int` pointer.

Let me say this again. As soon as you put a `*` character in front of *ANY* pointer, we are no longer talking about `two_star_pointer`. We are talking about what it points to. What does it point to? A `one star int`. 

Therefore

    *two_star_pointer = &amp;height;

We are saying ""Take the thing that `two_star_pointer` actually points to

Look at this in action:

    int **two_star_pointer = malloc(2 * sizeof( int * ) );

    int height = 5;

    *two_star_pointer = &amp;height;

    printf(""The value of height is: %d ""

Why did I use two stars in the printf? Because one star would have referred to a `one star int`. Two stars would refer to a ""zero star int"", you are dereferencing it two layers deep, thus arriving at the original integer value.

So let's review this a bit. Imagine I have something like this:

    int ***three_star_int = ...

Now

1. If I write: `three_star_int` then I am referring to the actual `three star int`. I am referring to the actual memory address

2. If I write: `*three_star_int` then I am *no longer* referring to the `three star int`. I am referring to a `two star int`. Why? Because that is the thing a three star int points to. 

3. If I write: `**three_star_int` then I am *no longer* referring to the `three star int`. I am referring to a `one star int`. 

4. If I write `***three_star_int` then I am refering to the thing a `one star int` points to

Now let me show you a simple way to understand this. Any time you have a pointer of certain levels deep, to get the *kind* of pointer now referred to.

For example:

    **three_star_int ...

Ok

    ****six_star_int ...

Six minus four is two. This is therefore referring to a `two star int`.

    *two_star_int ...

Two minus one is one. This is therefore referring to a one star int. In other words

So with that in mind

    *two_star_pointer = &amp;height;

Now

    *(two_star_pointer + 1) = &amp;width;

Ok

    printf(""The values are %d and %d ""

It should make sense. Why didn't we use one star? Because one star means that we are putting the one star pointer into printf for %d. That would not be correct

Here is a sample program that helps make this clear:

----

    int height = 5;
    int width = 10;

    int **two_star_int = malloc(2 * sizeof(int *) );

    *(two_star_int + 0) = &amp;height;
    *(two_star_int + 1) = &amp;width;

    printf(""The values are: %d and %d \n""

----

If any of this is still unclear

The above code and how it works should make perfect sense to you at this point.

----

When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v5ed/lesson_102_arrays_of_pointers_continued_part_three/

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v573/lesson_101_arrays_of_pointers_continued_part_two/
1255492581.0,9tt3r,Lesson 92 : How function return values work,CarlH,76,9,15,"Lessons 91 and 92 used to be Lesson 91. I split this into two lessons to make it easier to grasp.

Remember as I said in the last lesson

----

I think it is important to preface this lesson by saying this: This lesson focuses on how a function truly returns a value at the machine code level. C and other languages are not always so ""pure"". There are many complexities to how a programming language such as C makes it possible to ""return"" data that is larger than what is allowed at the machine code levels.

These ""returns"" however are not true returns

We will get into the specifics of those processes later in the course. 

----

A function typically returns a value using a CPU register named EAX. 

EAX is just another register

Registers are simply places on the CPU that data can be stored, a 32 bit chip can hold a 32 bit data element in a register (typically).

No register is very large. However

You will learn more about microprocessor architecture later in the course. However

This means that before a function returns control to whatever called it

This is what will typically happen at the end of a function call:

1. The function will finish doing what it was designed to do.
2. The function will store a return value into EAX
3. The function will return control back to whatever called it.
4. The caller will then read EAX and understand that as the return value.

Now it should be very clear to you why a function returns one value. The EAX register is only designed to hold one value. Also

You can however return large data structures (arrays, a memory address, will fit into the EAX register just fine.

Because I showed you the assembly language/machine code instructions for push and pop

    mov eax

All of this work that I have described is done for you behind the scenes by C. 

The goal of these last lessons is for you to understand how in general parameters are sent to functions (the stack)

----

Please let me know if you have any questions on this material. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9tuh3/lesson_93_introducing_casts/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9tt3r/lesson_92_how_function_return_values_work/
1255049496.0,9s8jc,Lesson 69 : Review of Pointers Part Three,CarlH,68,4,27,"I had originally planned a different lesson here

The topic of this lesson is, and some do not. It is important to understand this. There are only *three things* we have to consider in this lesson, so this is not difficult:

1. Single variables of a given data type. (ex: int
2. Double quoted strings. (ex: ""Hello"")
3. Single quoted characters. (ex: 'a')

First

    int i = 5;
    char my_char = 'a';
    unsigned short int height = 10;

All of these single variables of a given data type will *never* be seen by C to be a memory address. Why? Because they are all small enough that they can be processed ""as is"". What I mean by this is

Bad:

    char some_character = 'z';
    char *my_pointer = some_character;    &lt;--- Bad. C does *not* see ""some_character"" as a memory address.

Good:

    char some_character = 'z';
    char *my_pointer = &amp;some_character;   &lt;--- Good. The &amp; operator gets the memory address.


The *only* way to get the memory address for variables such as these

Next: Double quoted strings of text. 

Any time you ever see a double quoted string of text

    &amp;""Hello"" &lt;--- invalid syntax in this case

Any double quoted string can be thought of as already having the &amp; character in front of it. Why? Because a string of text is too big to fit in any of the standard data types, you *must* have the memory address where it starts. 

Therefore

Example: 

    char *string = ""Hello"";   &lt;--- ""Hello"" is treated like a memory address. 

A memory address to what? To where ""Hello"" is stored in memory.

Now

A single quoted character is simply an ASCII value. For example, no different than any other. 

The following two lines are *perfectly identical*:

    char my_char = 'a';
    char my_char = 0x61;

0x61 *is* 'a'. It is just a number.

You cannot assign a pointer the value of a character

    char *some_pointer = &amp;'b';        &lt;--- Invalid syntax. 'b' is just a value

Therefore, like so:

    char my_character = 'b';
    char *my_pointer = &amp;my_character;

So lets review so far:

1. Single variables of a given data type. If you want to assign their memory address to a pointer
2. Double quoted strings. You cannot use a &amp; character and you do not need to
3. Single quoted characters. As far as C is concerned, such as 'a'.

Note that #3 above does *not* apply to variables of type char. A variable of type char is covered by #1 above. It is just a variable

    char my_char = 'a';    &lt;--- my_char is a variable stored in memory. If you want the memory address

    char my_char = 'a';    &lt;--- 'a' is a character. It has no memory address. It is not stored in memory. 
                           &lt;--- It is simply a number

In the next lesson we will extend this review into arrays.

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9s8ru/lesson_70_review_of_pointers_part_four/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9s8jc/lesson_69_review_of_pointers_part_three/
1255043508.0,9s7qm,Lesson 68 : Review of Pointers Part Two,CarlH,72,5,15,"I am taking this review process slowly

The `*` character means exactly *two* things concerning a pointer. It means either ""Make this variable a pointer""

When you first create a pointer

After a pointer is created

    char *my_pointer = ...     &lt;--- Here and *only* here
    ...
    ...                        &lt;--- For the rest of the program
    ...                             mean ""what is at the address contained in the pointer"" 

So that covers the `*` character. At this stage it should be very clear to you that any time you ever see the `*` character used with a pointer

Now

    char my_character = 'a';
    char *my_pointer = &amp;my_character;
    printf(""The character is %c ""

In the third line, therefore the `*` character means we are asking for ""what is at the memory address"" of the pointer. Which is of course, the character 'a'.

Now, arrays, array elements, and more. 

It might help to think of the &amp; operator as a function that *returns* a memory address. 

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9s8jc/lesson_69_review_of_pointers_part_three/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9s7qm/lesson_68_review_of_pointers_part_two/
1254576978.0,9qh8y,Test of Lessons 40 through 49 [Answers],CarlH,102,38,23,"If you missed any questions on this test or if you have any questions about the material
----

**True or False**

1. You can use a &amp; character to obtain the memory address of a pointer the same as you can with a non-pointer variable. **True**
2. The following is a good way to test equality: `if (height = 5) {` **False**
3. When you create a text string using an array
4. Constants are typically stored in a read-only section of memory. **True**
5. This code: `char *mystring = ""Hello Reddit"";` works by storing the entire string ""Hello Reddit"" into the pointer ""`mystring`"". **False**

**Fill in the blank**

1. The only way you can see or work with any data larger than the basic data types (int, though some do this work behind the scenes. **pointer**
2. A `_____` can be used to go through data one byte at a time in order to read it or to make changes to it. **pointer**
3. An `_____` is a collection of data elements having the same data type. **array**
4. A `_____` is a statement which conducts some test in order to decide between various sets of unique instructions to execute. **conditional flow statement** (it is ok if you put an if statement
5. The `_____` flag on your CPU is used to evaluate all tests and comparisons and is therefore critical to all programs. **zero** (ZF is ok)

----
When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9qk90/lesson_50_more_on_conditional_flow_statements/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9qh8y/test_of_lessons_40_through_49_answers/
1254495340.0,9q7fs,Lesson 46 : A new way to visualize memory.,CarlH,140,74,15,"Up until now we have used 16-byte ram to illustrate concepts in pure binary. We cannot continue like this because eventually it becomes too complex. A large part of the skill that you need as a programmer is the ability to visualize concepts more and more abstractly.

So because of that

    ...
    1000 : 0110 0001 : 'a'
    1001 : 0110 0010 : 'b'
    1010 : 0110 0011 : 'c'
    1011 : 0011 0001 : '1'
    1100 : 0011 0010 : '2'
    1101 : 0011 0011 : '3'
    1110 : 0000 0000 : null (also called \0 )
    ...

Instead of visualizing ram like this

    ...
    1000 : ['a']['b']['c']['1']['2']['3']['\0'] ...
    ...

Notice that the ... (ellipses) at the end of our ""abc123"" string indicates that other data might follow

We are still saying the exact same thing here as we did before. We are still looking at the exact same state of memory. The exact same bytes are storing the exact same values. We are just writing it out in a slightly more abstract way. 

Each [ ] block represents a byte. We are simplifying what is contained in each byte.

You should be able to clearly look at any of these [ ] blocks and realize that there is a single byte

You should understand that the memory address 1000 corresponds to the exact memory location that 'a' is stored. That 1001 corresponds to 'b' and so on.

Visualizing memory like this allows us to observe interesting details about our string. For example

Now if we want to study a more complex string

    1000 : ['H']['e']['l']['l']['o'][' ']['R']['e']['d']['d']['i']['t']['\0'] ...

It becomes easier to do, and understand that each character is stored in memory right after the previous character.

This method of visualizing the contents of ram will make the future lessons much easier to understand.

----
Please ask any questions you need to before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9q80s/lesson_47_introducing_the_character_string_as_an/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9q7fs/lesson_46_a_new_way_to_visualize_memory/
1254301377.0,9pfuj,Lesson 31 : Introducing arrays and pointers part two.,CarlH,142,77,33,"For the purpose of this lesson

----

In the previous lesson I showed you how to clearly visualize how variables are stored in memory. I also showed you that a variable really should be thought of in two different ways: the location of that variable in memory

Now we are going to explore this further

Lets again consider the string of text ""abc123"". Lets review how it is stored in memory:


    0110 0001 : 0110 0010 : 0110 0011 : 0011 0001 : 0011 0010 : 0011 0011 : 0000 0000
       ""a""    :     ""b""   :     ""c""   :     ""1""   :     ""2""   :     ""3""   : &lt;null&gt;


Let's now *store* the string of text ""abc123"" into our 16-byte RAM from the previous lesson. Lets say that we will store it at position ""eight"" in RAM. Like this:

    ...
    1000 : 0110 0001 &lt;--- ""a""
    1001 : 0110 0010 &lt;--- ""b""
    1010 : 0110 0011 &lt;--- ""c""
    1011 : 0011 0001 &lt;--- ""1""
    1100 : 0011 0010 &lt;--- ""2""
    1101 : 0011 0011 &lt;--- ""3""
    1110 : 0000 0000 &lt;--- the null termination
    ...

I want you to observe the following fact: Every single character in our string of text *has its own address* in memory! 

Even though our string as a whole starts at position 1000 (eight), the ""a"" character.

Now I want you to do a mental experiment. On your own

1. Start with the address 1000 in our 16 byte ram.
2. Say the character stored at that location.
3. Go to the very next address.
4. Repeat this process of saying characters until... the null termination is reached.

You just simulated exactly how the printf() function works!

----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pgmv/lesson_32_introducing_the_pointer_data_type/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pfuj/lesson_31_introducing_arrays_and_pointers_part_two/
1279406077.0,cqquy,[CarlHProgramming] New Lesson : 2.5.2 : N! Continued and Introducing Trees.,CarlH,73,9,17,"**Lesson Introduction:**

In this lesson we will continue learning about N!

**URL:**

http://www.highercomputingforeveryone.com/Course_2/Unit_5/Lesson_2/",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/cqquy/carlhprogramming_new_lesson_252_n_continued_and/
1255815095.0,9v36d,Lesson 99 : A quick review on Casting,CarlH,70,5,10,"I realize that casting is a confusing topic at first

In earlier lessons

    char *main_pointer = malloc(10);

Now `main_pointer` is a `char` pointer that is pointing to Byte 0 of our 10 byte working space. Now

    int *int_pointer = (int *) main_pointer;

This may be unclear to you. Why are we writing `(int *)` here? 

In this case

You can see that `main_pointer` is a pointer to a `char` while `int_pointer` is a pointer to an `int`. The two data types are not the same and are therefore not compatible with each other. We need a cast in order to make this assignment work.

In general

When I type:

    (int *) main_pointer

I am attempting to produce data of type `(int *)` by using `main_pointer` as input. 

The result of this casting operation can then be assigned to our `int_pointer` we created.

When I write this code:

    int *int_pointer = (int *) main_pointer;

What happens is something similar to this:

1. Transform `main_pointer` to an `(int *)` data type.
2. Take the result of this transformation
3. This transformation does not actually change `main_pointer`.

Remember that `main_pointer` is not actually changed. The cast operation takes place without changing anything

Casting is used when we need to take something of one data type and use it as another.

When it comes to pointers

Therefore, it is very easy to change that. All you have to do is put the cast of the correct data type in front of the pointer, and you instantly have a new pointer of the correct data type.

Here are some examples:

I have a pointer called `my_int_pointer` which was designed to point to integers. It points to the memory address we will call B4 in some allocated memory. I need to look at B4

    char *my_char_pointer = (char *) my_int_pointer;

Now

    int *my_int_pointer = (int *) my_char_pointer;

And that is all there is to it. Just remember that you use a cast in order to take something of one data type and change it so it can be used as a different data type altogether. Also remember

We will cover casts in greater detail later in the course. 

If you are unsure whether you understand this material well enough to proceed

    int *int_pointer = (int *) some_other_pointer;

The purpose is to create an integer pointer called `int_pointer` using a pointer to a different data type. The `(int *)` is used to specify that we want to convert `some_other_pointer` to an `integer pointer`. Remember

As long as you understand the above paragraph and you understand the purpose of the above code

----

Please let me know if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v4zx/lesson_100_arrays_of_pointers_continued_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v36d/lesson_99_a_quick_review_on_casting/
1255221695.0,9sugb,Lesson 79 : The need to describe a data structure ,CarlH,73,8,6,"Before we can learn to work with data structures

The first thing you must know about a data structure is that you cannot use it until you *describe* it. 

Up until now we have not had a requirement to describe *how* we are using the data we create. For example, or #21. As soon as I have the memory to work with, I can put anything I want anywhere I want.

With a data structure however, I must state this also. Every detail concerning the data structure must be described fully before I can do anything.

Why is that? Because you cannot index a data structure like an array. This is because elements of a data structure are *not* necessarily the same data type, which is why you have to describe a data structure before you can use it.

Here is a very simple data structure

    Figure (a)

    ""Reddit$Programming$Classes$""

Notice that '$' is really the NUL character, but has the NUL termination character where the $ characters would go.

Why is this not an array? Because each element is not the same length. Notice I did not put any ""filler"" text to make the word ""Reddit"" and the word ""Classes"" as long as the word ""Programming"".

How would we define this data structure? For each element

1. Where does each element begin?
2. How long is each element? 
3. What data type is each element?

Notice that with arrays all 3 of these questions are answered already. In the case of a data structure however

Now

First of all

The word ""Reddit"" starts at... 0. That is easy enough. What about ""Programming""

Hopefully at this stage it is not too confusing. We have to tell C where each element starts. In other words we need to state:

1. The first word starts at byte #0 and is 7 bytes in length
2. The second word starts at byte #7 and is 12 bytes in length
3. The third word starts at byte #19 and is 8 characters in length. 

Why do we need to state this? Because each element is of a different length. In an array with each element being the same length you can simply multiply that length times the element number to get its starting position. That method will not work here simply because we are using different lengths.

So, and their length. 

In the next lesson I am going to show you how to do this.

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sulj/lesson_80_introducing_the_struct_keyword/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sugb/lesson_79_the_need_to_describe_a_data_structure/
1255101920.0,9sg8m,Test of Lessons 60 through 72 [Answers],CarlH,69,6,17,"**You may submit answers in this thread. Please ask questions if any of this material is unclear to you.**
----

**True or False**

1. Saying `*(my_pointer)` is the same thing as saying `*(my_pointer + 0)` **True**
2. A `for loop` is a ""short-hand"" way of writing a `while loop`. **True**
3. A four dimensional array is actually an array of 3 dimensional arrays. **True**
4. If `my_string` is an array of characters
5. The code in Figure (a) is done correctly. **False**

**Fill in the blank**

1. To create a for loop which will start by setting the variable `i` to 3 that will execute 4 times

 **for (i = 3; i &lt; 7; i++) {** Some other variations are possible
2. When trying to understand an algorithm
3. For array indexing to work properly
4. To assign a string to an element of a 2-dimensional array
5. The 3rd line of code in Figure (a) below will imply that `my_pointer` is a pointer to what type of data? `_____`. **an entire array

Figure (a)

    char my_string[] = ""Hello"";
    char *my_pointer;

    my_pointer = &amp;my_string;

----

When you are finished

http://www.reddit.com/r/carlhprogramming/comments/9sgmy/lesson_73_understanding_array_indexing_as_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sg8m/test_of_lessons_60_through_72_answers/
1255051774.0,9s8wp,Lesson 72 : Using Pointers with Offsets,CarlH,71,5,8,"The subject of pointers is confusing to many beginners

This lesson is going to focus on the methods of using an ""offset"" with a pointer. This is a critical concept to master. Some of this material has already been covered

First of all

If I told you ""Start at your house, and that defines an exact location of something. Remember that your computer's memory is linear, thus *any* offset will be simply *plus* some number, or *minus* some number.

With pointers

    char *string = ""Hello Reddit"";

How can we find the 'R' in Reddit? Well, we have *all the information we need* in order to find 'R'. If we simply add 6 to the memory address, we get the memory address of 'R'. If we are at 'R', and we want to find 'H', we subtract six.

This is a critical concept to master. Any element of any data structure can be located by knowing the location in memory of any other element of the same data structure, anything at all.

Now let's expand this statement: All elements of any data structure can be located by an offset (plus or minus) from any other element. 

Suppose I didn't know where 'H' was

So now I have explained how offsets are useful

Think of the source element as being ""your house"" in the example I gave. You will either add or subtract some value to that ""source element"" and in so doing you will be able to reach any element in the data structure.

What do you get if you add a number to a memory address?

Another memory address. It is as simple as that. A pointer is *always* going to have a memory address, you are still going to get a *different* memory address as a result. The word ""different"" is important here. Unless you are adding or subtracting a 0, you *will* get a different memory address, and therefore different data.

Memory address plus 100 means: ""Give me the memory address 100 bytes forward from where I am."" Memory address minus 50 means: ""Give me the memory address 50 bytes backward from where I am."" 

[Note: Above example assumes a char pointer

You can also set ""bookmarks"" inside of memory

By doing this you could have two or more pointers working on data simultaneously

There are many reasons you may want to do that

To wrap this up: A pointer can be added to, you go *backwards*. 

Knowing how to properly use offsets is an important skill and will empower you to be able to achieve results that otherwise would not be possible.

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sg2i/test_of_lessons_60_through_72/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9s8wp/lesson_72_using_pointers_with_offsets/
1254320109.0,9pimr,Lesson 33 : How to create a pointer.,CarlH,145,81,43,"In the previous lesson we learned that it is possible to create variables that are designed to hold memory addresses. In this lesson we are going to explore how to create such a variable.

As we discussed, characters occupy one byte, `short int` might occupy two bytes, `int` might occupy four bytes (depending on the compiler), etc. 

Lets look at the way an `unsigned short int` might be stored in our 16 byte ram example. In this case

Lets imagine this code:

    unsigned short int total = 50250;

So we have stated that that the variable `total` will contain a value of 50

How would this look in binary? 

    1100 0100 : 0100 1010 

    2^15 + 2^14 + 2^10 + 2^6 + 2^3 + 2^1
    32,024 + 64 + 8 + 2 = 50,250

Remember that this unsigned short integer takes up *two* bytes. Therefore

    ...
    1000 : 1100 0100 &lt;--- first half
    1001 : 0100 1010 &lt;--- second half 
    ...

What I want you to notice is that obtaining the 8 bits at position 1000 is *not enough* to obtain the full value of this `unsigned short int` variable. It is however enough to start with. If we know that the `unsigned short int` starts at position 1000 then we know enough to get the value

As you can see, ""What is the *sixteen bit* value stored at memory address 1000. 

Now for the next half of this lesson.

You do not create a pointer *only* to store a memory address, ""What is at that location?"".

When you create a pointer

If you are planning to use the pointer to look at ASCII characters in memory, you must specify, ""I plan to use this pointer for type `unsigned short int`"". 

When you create a pointer

Now

Lets look at this in practice. Note that in the below example

    int * my_pointer;
    int *my_pointer;

There you see I have just created a pointer. Now, C needs to know how *much* data from that location to give me.

In the next lesson we will explore pointers more
----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pkde/lesson_34_assigning_a_value_to_a_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pimr/lesson_33_how_to_create_a_pointer/
1254292437.0,9per4,Test of Lessons 20 through 29 [Answers],CarlH,135,73,17,"**It is ok to post your answers to the test in this thread.**

If anything is unclear

----
**True or False**

1. If you are defining a fraction using binary, 1/8, etc. For example, the binary number: 0001.1100 would be: 1.75 because .1100 means ""1/2 plus 1/4"". **True**
2. It may not be possible to easily represent any fractional value in binary. Therefore
3. (**C**) An ""unsigned int"" is an int that can hold both positive and negative integers. **False**
4. (**C**) The character ""4"" is the same thing as the number 4 and can safely be used for mathematical operations. **False**
5. (**C**) A function that returns type ""int"" can be used in any place within the program that an ""int"" is expected. **True**

**Fill in the blank**

1. The `_____` point is the term for the symbol which separates the fractional part of a number from the integer part. This term is equivalent to a ""decimal point"" in a base-ten number. **radix**
2. 8.5 in binary is: `_____`. **1000.1** (padding with zeros on left or right is fine)
3. The lower-case letter 'c' is represented in ASCII like this: `_____`. **0110 0011**
4. When you give a plain English name to some data stored in memory
5. A string of text that ends with this byte: 0000 0000 is known as `_____`. This is done in order to ensure that a function knows where a string of text ends. **a null terminated string**
----
When you are sure you are ready

http://www.reddit.com/r/carlhprogramming/comments/9pfgk/lesson_30_introducing_arrays_and_pointers_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9per4/test_of_lessons_20_through_29_answers/
1254292059.0,9peox,Test of Lessons 20 through 29,CarlH,135,70,1,"**Please

Someone who has not yet taken the test may see the answers if you do this. 

Before you begin

If you have any questions or if anything is unclear

Remember
----

In the below test questions

**True or False**

1. If you are defining a fraction using binary, 1/8, etc. For example, the binary number: 0001.1100 would be: 1.75 because .1100 means ""1/2 plus 1/4"". 
2. It may not be possible to easily represent any fractional value in binary. Therefore
3. (**C**) An ""unsigned int"" is an int that can hold both positive and negative integers.
4. (**C**) The character '4' is the same thing as the number 4 and can safely be used for mathematical operations.
5. (**C**) A function that returns type ""int"" can be used in any place within the program that an ""int"" is expected.

**Fill in the blank**

1. The `_____` point is the term for the symbol which separates the fractional part of a number from the integer part. This term is equivalent to a ""decimal point"" in a base-ten number.
2. 8.5 in binary is: `_____`.
3. The lower-case letter 'c' is represented in ASCII like this: `_____`.
4. When you give a plain English name to some data stored in memory
5. A string of text that ends with this byte: 0000 0000 is known as `_____`. This is done in order to ensure that a function knows where a string of text ends.

----
When finished with the test

http://www.reddit.com/r/carlhprogramming/comments/9per4/test_of_lessons_20_through_29_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9peox/test_of_lessons_20_through_29/
1347847050.0,1001ux,"[CarlHProgramming] Thanks to your donations, real-time help chatrooms have been added to the website to provide instant help to anyone who needs it.",CarlH,77,13,http://www.reddit.com/r/carlhprogramming/comments/1001ux/carlhprogramming_thanks_to_your_donations/

Now

The new chatroom functionality is powered by ""cometchat"" which was paid for using donations. (Of course even had there been no donations I would still have done this

I have set it up so that any time anyone chats in one of the help chatrooms

If you wish to volunteer to help others and receive automatic notifications via email whenever there is chatroom activity

Questions/comments welcome.",,t5_2r81y,1347848535.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/1001ux/carlhprogramming_thanks_to_your_donations/
1279329620.0,cqi6q,[CarlHProgramming] New Unit. New Lesson : 2.5.1 : Programming and Math. N factorial.,CarlH,70,5,3,"**Unit Introduction:**

In this unit we will begin to explore some of the simple math that goes into programming

**Lesson Introduction:**

When you multiply a number times itself each time subtracting one

**URL:**

http://www.highercomputingforeveryone.com/Course_2/Unit_5/Lesson_1/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/cqi6q/carlhprogramming_new_unit_new_lesson_251/
1256226333.0,9wp0b,Lesson 110 : The Practical Use of Functions : Part One,CarlH,67,5,4,"In the last lesson I showed you how to demonstrate a simple 2x5 array using 10 bytes of memory allocated using a malloc() operation. Later in the course

At this point in the course though

Earlier in the course I taught you that variables were a way to give a name to a memory address where some data was stored. In this lesson, a variable and a function are quite similar. 

A variable gives you a way to give a simple name to a complex memory address. Similarly

In this lesson

1. Functions make your code easier to read.

2. Functions allow for more organized and structured code.

3. Functions make fixing problems and bugs simpler.

4. Functions reduce redundancy and allow you to re-use code. 

Now

In the last lesson

Recall that this code looked like this:

    Figure (a)

    strcpy((our_pointer + (B_Size * 0))
    printf(""array[0] string is: %s \n""

Does this appear difficult to read? If so, it appears difficult.

Now because the code in Figure (a) seems difficult to understand

Instead of writing the above 2 lines of code

    demonstrate_array();

In other words

The first step to creating any function is to decide on what that function is actually doing. This enables you to give a name to the function that is descriptive and easy to understand.

It is poor practice to give cryptic names to functions and/or variables. It is generally poor practice to call a variable `a` or a function `x()`. Always name a variable or a function something that can be easily understood by not just you, then it is alright to use a variable name such as `i`, `j`, `k`, etc. This is because those reading your code will understand what these variables mean.

Do this even if you are 100% sure that the only person who will ever read your code is you. Why? Because you may just find yourself a year or two later going back to something you have written

The more easily understood the code you write, and only I could read it. The fact that I could read it perfectly meant little to the buyer. 

I ended up having to go through and re-write large chunks of the program, and I wouldn't have had to do any of it if I had simply done this to start with. I encourage you not to make the same mistake I did. 

Now we have created a function with a name

That will be the topic of the next lesson.

----

Please let me know if you have any questions. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9wpnh/lesson_111_the_practical_use_of_functions_part_two/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9wp0b/lesson_110_the_practical_use_of_functions_part_one/
1255841583.0,9v5l6,"Lesson 103 : Sample program demonstrating pointers, casts, and arrays of pointers.",CarlH,75,43

If this looks difficult, see Lesson 104 and then come back to this lesson.

To make this even easier to read

----

Read through this *slowly*. Take your time, code, and output carefully. Ask questions if any part of this is unclear to you.

----

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;
    
    int main(void) {
		// For looping purposes
    	int i=0;
   	
		// Allocate a ten-byte working space 
        char *main_pointer = malloc(10);
   
		// Set the first two bytes of this working space to 'AB' using the pointer offset method.
        *(main_pointer + 0) = 'A';
        *(main_pointer + 1) = 'B';

		// Set the next two bytes to: 'CD' using array indexing.   
        main_pointer[2] = 'C';
        main_pointer[3] = 'D';
   
		// Set the rest of the string using the strcpy() function. 
        strcpy( (main_pointer + 4)
    
		// At this stage
    	printf(""First we use our ten bytes as a string like this: %s \n""

// Output: First we use our ten bytes as a string like this: ABCDEFGHI
   
		// Let's go through all ten bytes and display the hex value of each character 
    	printf(""Our ten bytes of memory look like this: (41 is A
    	for (i = 0; i &lt; 10; i++) {
    			printf(""%02x ""
    	}

// Output: Our ten bytes of memory look like this: (41 is A

// Output: 41 42 43 44 45 46 47 48 49 00

    	printf(""\n\n"");

		// Now let's create an array of two integer pointers 
    	int **int_pointer_array = malloc(2 * sizeof( int * ) );
    
  
		// Set the first of these integer pointers to point at byte #0 of our ten-byte working space
		// and set the second to point at byte #6 of our ten-byte working space. 

    	int_pointer_array[0] = (int *) main_pointer;
    	int_pointer_array[1] = (int *) (main_pointer + 6);

    	printf(""Now we will use B0-&gt;B3 as an integer

// Output: Now we will use B0-&gt;B3 as an integer

// (Note: remember this is B0-&gt;B3 of our *ten byte working space*.)
   
		// Give these two pointers a value. 
    	*int_pointer_array[0] = 5;
    	*int_pointer_array[1] = 15;
   
		// Using printf() we prove that the values we set are accurate
		// as occupying 4 bytes of memory

    	printf(""The first integer is: %d (hex: %08x) \n""
    	printf(""The second integer is: %d (hex: %08x) \n""

// Output: The first integer is: 5 (hex: 00000005)

// Output: The second integer is: 15 (hex: 0000000f)
    
    	printf(""\n"");
    	printf(""Our entire ten byte memory space now looks like this: \n"");
   
		// Again we go through all 10 bytes and display their new contents.
		// It is easy to see that the first four bytes and the last four bytes are 
		// the integers we created. 

    	for (i = 0; i &lt; 10; i++) {
    			printf(""%02x ""
    	}
    
    	printf(""\n"");

// Output: Our entire ten byte memory space now looks like this:

// Output: 05 00 00 00 45 46 0f 00 00 00

// (Note: Notice that the integers are 05 00 00 00

		// Finally we demonstrate that bytes #4 and #5 are unaffected
    	printf(""\nBytes #4 and #5 are set to: %c and %c \n""
    	printf(""\n"");
    	printf(""Our two integers are set to: %d and %d \n""


// Output: Notice that Bytes #4 and #5 are unaffected and remain set to: E and F

// Output: Still

        free(main_pointer);
        free(int_pointer_array);

    	return 0;
    }

----

Output:

    First we use our ten bytes as a string like this: ABCDEFGHI
    Our ten bytes of memory look like this: (41 is A
    41 42 43 44 45 46 47 48 49 00

    Now we will use B0-&gt;B3 as an integer
    The first integer is: 5 (hex: 00000005)
    The second integer is: 15 (hex: 0000000f)

    Our entire ten byte memory space now looks like this:
    05 00 00 00 45 46 0f 00 00 00

    Notice that Bytes #4 and #5 are unaffected and remain set to: E and F

    Still

----

It may be beneficial for you to write this code into your editor so you can see ""color highlighting"". Alternatively

Remember that this is *only a demonstration*. We are doing some rather unusual and unorthodox things here. The entire purpose of this is simply to show you how these concepts can be used to directly manipulate memory in interesting ways. 

I *highly* recommend that you type out this program, but actually type it out. This will greatly help you to understand the material. Do this even if you get a different result. Remember that this is designed to work where an integer is 4 bytes in size.



----

If any part of this is unclear

http://www.reddit.com/r/carlhprogramming/comments/9v5w9/lesson_104_the_sample_program_in_lesson_103/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v5l6/lesson_103_sample_program_demonstrating_pointers/
1255306421.0,9t2ch,Test of Lessons 73 through 84 [Answers],CarlH,73,4,11,"You may post your answers here

----

**True or False**

1. The malloc() function allocates memory and automatically initializes all bytes allocated to 0 (null).  **False**
2. When you write a data structure definition
3. Unlike an array
4. You must manually add up the size of all elements of a data structure in order to know how much memory to allocate. **False**
5. When you are done using allocated memory

**Fill in the blank**

1. The malloc() function must be used with a `_____`. **pointer**
2. The `_____` keyword can be used to create a new ""data type"" from a data structure. **typedef**
3. Instead of writing this: `(*our_pointer).first_word` we can write this: `_____`  **Answer:** `our_pointer-&gt;first_word` when working with member elements of a data structure.
4. Whenever you use malloc() to allocate memory
5. You create a data structure using the: `_____` keyword. **struct**",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/9t2ch/test_of_lessons_73_through_84_answers/
1255306186.0,9t2bn,Test of Lessons 73 through 84,CarlH,75,10,5,"**Do not post answers in this thread** Someone who has not taken the test may see them.

----

**True or False**

1. The malloc() function allocates memory and automatically initializes all bytes allocated to 0 (null). 
2. When you write a data structure definition
3. Unlike an array
4. You must manually add up the size of all elements of a data structure in order to know how much memory to allocate.
5. When you are done using allocated memory

**Fill in the blank**

1. The malloc() function must be used with a `_____`.
2. The `_____` keyword can be used to create a new ""data type"" from a data structure.
3. Instead of writing this: `(*our_pointer).first_word` we can write this: `_____` when working with member elements of a data structure.
4. Whenever you use malloc() to allocate memory
5. You create a data structure using the: `_____` keyword.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/9t2bn/test_of_lessons_73_through_84/
1255106311.0,9sh4l,Lesson 74 : Understanding Array Indexing as Pointer Offsets Part Two,CarlH,71,6,8,"Recall in our previous lesson we have set out to create a two dimensional array using only pointers. Our array is to consist of four words each having a maximum of six total bytes in length. 

The first step in our task is to allocate the storage we will need. In this case

    char storage[] = ""12345678901234567890123"";

Now we are ready for part two of our lesson. 

Once we have allocated the memory we will need

    [0] : ""One""
    [1] : ""Two""
    [2] : ""Three""
    [3] : ""Four""

Well

Before we examine how to put this word into our string of text

So

    char *ptr = &amp;storage[0];

Our pointer now contains the memory address of the first byte

    Figure (a)

    *(ptr + 0) = 'O';    // &lt;-- At the memory address where storage begins
    *(ptr + 1) = 'n';    // &lt;-- At the very next byte
    *(ptr + 2) = 'e';
    *(ptr + 3) = '\0';

Remember that '\0' is a *single character* which is: 0000 0000. Also, and then adding some number.

Notice the similarities to the above code

    Figure (b)

    storage[0] = 'O';
    storage[1] = 'n';
    storage[2] = 'e';
    storage[3] = '\0';

The code in Figure (a) and the code in Figure (b) are identical.

Now we are done with the first word. Let's put in the second word. Where does it go? We would *not* begin our second word right after the first word. Why? Because as you learned in earlier lessons arrays must meet the criteria that *all elements* are the *same length*. What is the length we chose in this case? six. Meaning

    Figure (c)

    Bytes  0,  3,  4,  5 : ""One""
    Bytes  6.  7.  8.  9. 10
    Bytes 12, 15, 16, 17 : ""Three""
    Bytes 18, 21, 22, 23 : ""Four""

Because we are starting at 0 and counting to 23

Even if each word doesn't fill up the six bytes allocated to it

Before we put it in

Now

    *(ptr + 6) = 'T';
    *(ptr + 7) = 'w';
    *(ptr + 8) = 'o';
    *(ptr + 9) = '\0';

Done. Notice that saying `storage[6] = 'T'` achieves the same thing as the first line of the above code.

The third word will begin at byte #12. Notice that this is 6`*`2. Just as we talked about

The first word starts at position 0 because 6`*`0 is 0. The second word at 6 because 6`*`1 is 6. The third word at 12 because 6`*`2 is 12. And so on. Remember, and so on. If this is confusing to you, examine Figure (c) and notice what byte # each array element starts at. Notice the third element starts at byte 12.

    *(ptr + 12) = 'T';
    *(ptr + 13) = 'h';
    *(ptr + 14) = 'r';
    *(ptr + 15) = 'e';
    *(ptr + 16) = 'e';
    *(ptr + 17) = '\0';

Now the fourth word. 6*3 is 18

    *(ptr + 18) = 'F';
    *(ptr + 19) = 'o';
    *(ptr + 20) = 'u';
    *(ptr + 21) = 'r';
    *(ptr + 22) = '\0';

Notice that ""Four"" follows immediately after ""Three"" in our array

Now we have stored all the words. Here is what our string now looks like:

    ""One$__Two$__Three$Four$_""

I needed some way to represent the invisible character NUL, not part of C itself.

Remember that we started the word ""Three"" at position 12. Why? because ""Three"" is word number 2 (0, we would say: 12+2 which is 14. Look above at the code where we stored ""Three"" into memory and you will see that character 14 is in fact 'r'. You should mentally experiment with other concepts concerning arrays and use the above examples as a guide. For example, how would you find the 2nd letter of the word ""Four"" ? 

In the next lesson we will look at how to use the strings we have stored in memory as if they were arrays.

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9shw5/lesson_75_understanding_array_indexing_as_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sh4l/lesson_74_understanding_array_indexing_as_pointer/
1341808646.0,w97h7,[CarlHProgramming] I am looking for your input. Please tell me what you would like to see next.,CarlH,71,7,37,"So

Some of you started the course years ago

If the vast majority of you have already gone past the lessons I started with

I need to get a feel for where everyone is.

Please reply here and tell me:

Why are you subscribed? What are you looking for in /r/carlhprogramming ? What would you like to see me cover next

I want to give you what you are here for,False,,t5_2r81y,1341831865.0,,,t3_w97h7
1276427081.0,cehhz,Question Re: CarlHProgramming : Tests or No Tests?,CarlH,71,9,18,"I am debating whether or not to bring over the tests/continue adding new tests with the courses. Currently

Edit: Ok,False,,t5_2r81y,True,,,t3_cehhz
1257052610.0,9ztbi,Lesson 125 : Calculating a winning move,CarlH,71,6,17,"In the last lesson I showed you how to write a function that can detect whether or not a position is won for either 'X' or 'O'.

How could we write a function that can find a winning move? For example

    [X][ ][ ] =&gt; 012
    [ ][ ][ ] =&gt; 345
    [X][ ][ ] =&gt; 678

Here it is obvious that the winning move is ""3"". If we intend to have an ""artificial intelligence"" engine that can win vs a human player

Remember in earlier lessons I explained that you can use functions you have already built in order to make more powerful functions possible. This is such a case. Because we have a function that can evaluate whether or not a position is won or not

The way it works is simple. We just need to play all possible moves

Let's look at a sample tic-tac-toe position:

    [X][ ][X] =&gt; X_XO__O__
    [O][ ][ ]
    [O][ ][ ]

There are five possible moves that can be played: 1, 7, and 8.

In pseudo code

    play move 1
    is it a winning position? If so
    play move 4
    ... repeat this process for 1, 7, and 8

One thing you will notice is that it will be important to ""play a move"" without actually playing it. In other words

Let's go back to the raw data:

    ""X XO  O  "" (Remember we are using spaces)

Watch how simple this is:

    char raw_data[] = ""X XO  O  "";
    char test_position[10];
    int i

    for (i = 0; i &lt; 9; i++) {
        if (raw_data[i] == ' ') {
            strcpy(test_position
            test_position[i] = 'X';
            win_result = is_winning_position(test_position
            printf(""The result of playing X at position %d is: %d \n""
        }
    }

Output:

    The result of playing X at position 1 is: 10
    The result of playing X at position 4 is: 0
    The result of playing X at position 5 is: 0
    The result of playing X at position 7 is: 0
    The result of playing X at position 8 is: 0

Now we can just cut-paste this code into a function:

----

    int find_winning_move(char *raw_data) {
        char test_position[10];
        int i

        // Go through all possible squares
        for (i = 0; i &lt; 9; i++) {

            // Determine if that square is empty
            if (raw_data[i] == ' ') {

                // Copy the actual board into the ""test_position""
                strcpy(test_position

                // Play 'X' at that square
                test_position[i] = 'X';

                // Check to see if this is a winning move or not
                win_result = is_winning_position(test_position

                // Printf similar to: The result of playing X at position 1 is: 10  (non-zero = win)
                printf(""The result of playing X at position %d is: %d \n""
            }
        }

        return win_result; // This is not quite finished yet
    }

We create `test_position` to be a temporary tic-tac-toe board that the computer player can try various moves on without affecting the actual game. We then copy the current board position into the `test_position` using strcpy(). Finally we obtain the result of the ""`is_winning_position`"" function we wrote in the last lesson. We do this for each possible move

----

Because we now have a function that can calculate a winning move one level deep

    [X][ ][ ] =&gt; 012
    [O][ ][X] =&gt; 345
    [O][ ][ ] =&gt; 678

Here there exists a winning move for 'X'

    char raw_data[] = ""X  O XO  "";

How can we modify our function so that it can find a winning move two levels deep? That is the subject of the next lesson.

----

Please ask questions if any of this material is unclear to you.",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ztbi/lesson_125_calculating_a_winning_move/
1257048248.0,9zt0h,Lesson 124 : Introducing Switch and Case,CarlH,70,8,4,"In the last lesson I showed you that it is often useful to cause a function to return additional values other than 1 and 0. You should realize that it would be quite tedious to write individual if statements for each possible return value. Also

It turns out there is a short-hand method for doing this

    if (i == 1) {
        printf(""The value is one \n"");
    } else
    if (i == 2) {
        printf(""The value is two \n"");
    } else
    if (i == 3) {
        printf(""The value is three \n"");
    }

Can become:
    
    switch (i) {
        case 1 : printf(""The value is one \n""); break;
        case 2 : printf(""The value is two \n""); break;
        case 3 : printf(""The value is three \n""); break;
    }

So the syntax is simple. You write the word ""switch"" followed by the data item you are going to perform all the tests on. For each test

    int won_position_return_value = is_winning_position(raw_data

    switch (won_position_return_value) {
        case 10 : printf(""Horizontal win on Row #1""); break;
        case 13 : printf(""Horizontal win on Row #2""); break;
        case 16 : printf(""Horizontal win on Row #3""); break;
    }

Of course we could replace the printf() statements with a block of code. The idea is simple. With a ""switch"" statement we can replace a lot of ""if"" statements with something that is much easier to read.

What happens if none of the ""case"" statements apply? Then a ""default"" statement is used. Here is an example of default in action:

    int i = 5;

    switch (i) {
        case 2 : printf(""This won't print \n""); break;
        case 4 : printf(""This won't print either \n""); break;

        default : printf(""This will print because the other cases failed. \n""); break;
    }

Now with this in mind we can create another interesting function for our tic-tac-toe game. This function would be designed to display additional winning information based on the return value received from the ""`is_winning_position`"" function. It would work like this:

    void show_win_details(int win_value

        switch (win_value) {

            // Horizontal
            case 10 : 
                printf(""Horizontal win on first row for Player: %c \n""
            break;
            case 13 : 
                printf(""Horizontal win on second row for Player: %c \n""
            break;
            case 16 : 
                printf(""Horizontal win on third row for Player: %c \n""
            break;

            // Vertical
            case 20 : 
                printf(""Vertical win on first column for Player: %c \n""
            break;
            case 21 : 
                printf(""Vertical win on second column for Player: %c \n""
            break;
            case 22 : 
                printf(""Vertical win on third column for Player: %c \n""
            break;

            // Diagonal
            case 31 : 
                printf(""Diagonal win upper left to lower right for Player: %c \n""
            break;
            case 32 : 
                printf(""Diagonal win lower left to upper right for Player: %c \n""
            break;

            default: printf(""Some error occurred. \n""); break;

        }
    }

----

Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9ztbi/lesson_125_calculating_a_winning_move/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zt0h/lesson_124_introducing_switch_and_case/
1256229301.0,9wpnh,Lesson 111 : The Practical Use of Functions : Part Two,CarlH,70,4,0,"First

    Figure (a)

    strcpy((our_pointer + (B_Size * 0))
    printf(""array[0] string is: %s \n""

Sometimes you will know ahead of time that you want to create a function and you will write it from scratch. Other times you will want to take some code you have already written and convert it to a function. In this lesson I will show you how to take code you have already written and turn it into a working function.

To create any function like this

1. Create a blank function and simply copy and paste the code into it that you will use to build your function.

2. Determine what arguments you will need for the function.

3. Convert the code in the function to use those arguments.

4. Decide on a return value

5. Test the function to ensure it works as expected.

Now let's create our `demonstrate_array()` function. First let's create a blank function with no arguments and no return value. Therefore

    int main(void) {
        ... main() code goes here ...
    }

    void demonstrate_array(void) {
        strcpy((our_pointer + (B_Size * 0))
        printf(""array[0] string is: %s \n""
    }

Notice that this function is created *after* the main() function ends. This should be the case for any functions you write at this stage in the course.

This is the first step for creating a function. I have simply cut and pasted the code I intend to use into a ""blank"" function. This will *not* work yet however.

A common beginner source of frustration is trying to make functions, invariably you will get some strange C compiler errors.

Understand that as frustrating as these errors can be, and you should be glad when you get them. 

Why? Because when you get an error

The *worst* thing that can happen to you is that the program compiles, finding and fixing the problem is a lot harder. For this reason, you should be glad when your compiler gives you an error.

So before we go on

    /home/carl/oct22.c: In function demonstrate_array:
    /home/carl/oct22.c:33: error: our_pointer undeclared (first use in this function)
    /home/carl/oct22.c:33: error: (Each undeclared identifier is reported only once
    /home/carl/oct22.c:33: error: for each function it appears in.)
    /home/carl/oct22.c:33: error: B_Size undeclared (first use in this function)

It is impossible to learn C (or any language) without being able to understand these kinds of error messages. Therefore

    /home/carl/oct22.c:33: error: our_pointer undeclared (first use in this function)

First, `oct22.c`. Also, notice that the `line number` which created the error is given. In this case, line 33.

A common beginner mistake concerning errors is to look at the line where the error is reported to have occurred

Therefore

The next thing I should point out is that often one or two problems can generate hundreds of error messages. Just because you see five hundred errors in a program you try to compile does not mean you have to go and fix five hundred different things. 

It is therefore always advisable to start fixing errors by addressing the first error message you see. Often you will find that each error you fix will cut drastically the total number of error messages there are.

First

      strcpy((our_pointer + (B_Size * 0))

This is my line #33. This is where I should *start* looking in order to fix any problems. 

That is our first error message. This type of error message simply means that we are using a variable we have not declared. In this case

Well

    char *our_pointer = malloc(10);

So we *have* declared it

The answer to this question is the topic of the next lesson.

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9wqec/lesson_112_the_practical_use_of_functions_part/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9wpnh/lesson_111_the_practical_use_of_functions_part_two/
1256043323.0,9vvfg,Lesson 107 : Understanding Multi-Dimensional Arrays Better : Part Two,CarlH,74,11,5,"This lesson is a bit more intense than most. Go through this material slowly.

----

In the last lesson I explained that in order to understand an index of a multi-dimensional array

Understanding how multi-dimensional arrays work is critical no matter what language you are programming in. The problem many beginners have is that it is natural to try and understand an array as a grid. For example

There are two major problems with this approach. First

The second problem is that this method breaks down once you get past three dimensions. How could you mentally visualize a four or five dimensional array with this type of method? You cannot.

It is important to remember that all multi-dimensional arrays are simply one-dimensional arrays in disguise. The process of converting any multi-dimensional array to a pointer offset is the same process for converting that multi-dimensional array to a one-dimensional array.

In order to do this effectively

First we are going to start with a two dimensional array:

    char 2d_array[10][10];

Here we are stating that we have an array of ten elements

I started with this array because it is two-dimensional

I am going to draw out some of this grid in order to make this lesson clearer:

          0  1  2  3  4  5  6  7  8  9

     0    0  1  2  3  4  5  6  7  8  9
     1   10 11 12 13 14 15 16 17 18 19
     2   20 21 22 23 24 25 26 27 28 29
     .   ... 
     7   70 71 72 73 74 75 76 77 78 79
     8   80 81 82 83 84 85 86 87 88 89
     9   90 91 92 93 94 95 96 97 98 99

Note that you can identify any element of this array by simply lining up the grid. For example

This method falls apart though if we consider this array to be three dimensional. Certainly I cannot draw a 3D representation of such an array in this text box. However

First

Notice therefore that I chose [10][10] because it gives us a ""ones"" place, and each column is a new ""one"". 

How else could you visualize this array? You could visualize it by simply understanding that each time you add a ""ten""

Let's re-consider the array element: [2][5]. You could also understand this by saying: two tens

Now consider this array:

    char 3d_array[10][10][10];

We are still left with two luxuries. First

With the above array, and a one. This is true only because the original array dimensions are: [10][10][10].

Now imagine you are standing on a zero. There is a straight line that extends out in front of you towards infinity with numbers marked off at intervals starting at zero and incrementing by one. 

How do you represent [4][2][1] from this situation? The answer is, and finally you take one step.

At this stage you should be perfectly comfortable visualizing even an eight dimensional array provided that each array index has a size of ten. 

... Continued on the next lesson ...

----

Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9w07x/lesson_108_understanding_multidimensional_arrays/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9vvfg/lesson_107_understanding_multidimensional_arrays/
1255844992.0,9v5w9,Lesson 104 : The sample program in Lesson 103 revisited.,CarlH,76,9,6,"Here is the same sample program you just looked at

----

    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;string.h&gt;
    
    int main(void) {
   
        // Allocate a ten-byte working space 
        char *main_pointer = malloc(10);
    
        // Set the entire string to ""ABCDEFGHI&lt;NUL&gt;""
        strcpy(main_pointer

        // At this stage
    
        // Now let's create an array of two integer pointers 
        // In other words

        int **int_pointer_array = malloc(2 * sizeof( int * ) );
    
        // Set the first of these integer pointers to point at byte #0 of our ten-byte working space
        // and set the second to point at byte #6 of our ten-byte working space. 

        int_pointer_array[0] = (int *) (main_pointer + 0);
        int_pointer_array[1] = (int *) (main_pointer + 6);
    
        // Give these two pointers a value. 
        *int_pointer_array[0] = 5;
        *int_pointer_array[1] = 15;

        // At this stage

        free(main_pointer);
        free(int_pointer_array);

        return 0;
    }

----

It would be beneficial for you to type this program out into your own editor

----
Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v68b/lesson_105_on_the_address_of_operator_and_pointers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v5w9/lesson_104_the_sample_program_in_lesson_103/
1255109981.0,9shw5,Lesson 75 : Understanding Array Indexing as Pointer Offsets Part Three,CarlH,65,3,8,"**The text in this lesson is almost identical to Lesson 74.**

We are going to make one change from the last lesson. Instead of storage being defined as a single variable array

    char storage[4][6];

What you are going to read is a modified version of the last lesson which will contrast the differences between a single dimensional array

Now lets begin right after we create a pointer to the start of the array.


----

Our pointer now contains the memory address of the first byte of our two dimensional 4x6 array. The first byte of our array is where we want to put the 'O' for one. Let's store the word ""One"" like this:

    Figure (a)

    *(ptr + (0 + 0)) = 'O';
    *(ptr + (0 + 1)) = 'n'; // &lt;-- same as storage[0][1] = 'n';
    *(ptr + (0 + 2)) = 'e';
    *(ptr + (0 + 3)) = '\0';

Notice the similarities to the above code

    Figure (b)

    storage[0][0] = 'O';
    storage[0][1] = 'n';
    storage[0][2] = 'e';
    storage[0][3] = '\0';

So our two dimensional array `storage` has four words. storage[0] is of course the word ""One"". Therefore

The code in Figure (a) and the code in Figure (b) are identical.

Now we are done with the first word. Let's put in the second word. 

We would *not* begin our second word right after the first word in memory. Why? Because as you learned in earlier lessons arrays must meet the criteria that *all elements* are the *same length*. What is the length we chose in this case? six. Meaning

    Figure (c)

    storage[0] :  0,  3,  4,  5 : ""One""
    storage[1] :  6,  9, 10, 11 : ""Two""
    storage[2] : 12, 15, 16, 17 : ""Three""
    storage[3] : 18, 21, 22, 23 : ""Four""

Because we are starting at 0 and counting to 23

Even if each word doesn't fill up the six bytes allocated to it

Now

    *(ptr + (6 + 0)) = 'T';  // &lt;-- Same as storage[1][0] = 'T'
    *(ptr + (6 + 1)) = 'w';
    *(ptr + (6 + 2)) = 'o';  // &lt;-- Same as storage[1][2] = 'o';
    *(ptr + (6 + 3)) = '\0';

Each letter of this word is identifiable using an offset from where the word begins. Since the word ""Two"" begins at byte  #6

The third word will begin at byte #12. Notice that this is 6`*`2. Just as we talked about

Now let's store ""Three"" starting at byte #12:

    *(ptr + (12 + 0)) = 'T';
    *(ptr + (12 + 1)) = 'h'; // &lt;-- same as storage[2][1] = 'h';
    *(ptr + (12 + 2)) = 'r';
    *(ptr + (12 + 3)) = 'e'; // &lt;-- same as storage[2][3] = 'e';
    *(ptr + (12 + 4)) = 'e';
    *(ptr + (12 + 5)) = '\0';

Now the fourth word. 6*3 is 18

However

    *(ptr + ((6*3) + 0)) = 'F'; // &lt;-- Same as storage[3][0] = 'F';
    *(ptr + ((6*3) + 1)) = 'o';
    *(ptr + ((6*3) + 2)) = 'u';
    *(ptr + ((6*3) + 3)) = 'r'; // &lt;-- Same as storage[3][3] = 'r';
    *(ptr + ((6*3) + 4)) = '\0';

Why did we do it this way? Because now you can clearly see the relation between offsets and array indexing. It is as follows:

    array[x][y] means *(ptr + (SIZE * x) + y)

In this case

Notice that ""Four"" follows immediately after ""Three"" in our array

Now we have stored all the words. Here is what our string now looks like:

    ""One$__Two$__Three$Four$_""

Remember that we started the word ""Three"" at position 12. Why? because ""Three"" is word number 2 (count: 0, we would say: 12+2 which is 14. We can also do this by saying: (6*2) + 2. 

----

Now some closing notes:

The purpose of this lesson is to help you visualize pointers

In this lesson

Observe how this progresses:

    storage[0][0]   is   *(ptr + (6*0) + 0)    is   *(ptr + 0)        is   *ptr

    storage[1][3]   is   *(ptr + (6*1) + 3)    is   *(ptr + 6 + 3)    is   *(ptr + 9)

OR

    array[x][y]     is   *(ptr + (size * x) + y)

In the end

One thing I hope you have learned from this lesson is that any dimensional array is in truth

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sj83/lesson_76_understanding_array_indexing_as_pointer/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9shw5/lesson_75_understanding_array_indexing_as_pointer/
1254414218.0,9pwqs,Lesson 39 : About pointers concerning multi-byte variables.,CarlH,130,68,35,"Recall in the last lesson that we added one to our pointer in order to cause it to point to the next data element in memory.

Lets imagine a different case now. We are still going to use our 16 byte ram for this example

Lets imagine the following code:

    unsigned short int height = 10;
    unsigned short int width  = 14;

    unsigned short int *ptr = &amp;height;

Now in this example

Now, is stored at memory address 1000 in our 16-byte ram. 

    ...
    1000 : 0000 0000 0000 1010 &lt;--- height = 10; &lt;--- ptr contains ""1000"" 
    ...

Now keep in mind that because our variable is two bytes in size

    ...
    1000 : 0000 0000 &lt;--- first half of height; &lt;--- ptr contains ""1000"" 
    1001 : 0000 1010 &lt;--- second half of height.
    ...

Now lets go ahead and add the second variable `width` to our ram directly after `height`:

    ...
    1000 : 0000 0000 &lt;--- first half of height; &lt;--- ptr contains ""1000"" 
    1001 : 0000 1010 &lt;--- second half of height. 
    1010 : 0000 0000 &lt;--- first half of width;
    1011 : 0000 1110 &lt;--- second half of width. 
    ...

Do not think based on this example that variables are always placed one right after the other in ram when you create them. 

Now we know that `ptr` is pointing to address 1000 which contains the *start of* the variable ""height"". So the next question to ask  is what is the value `*ptr` is referring to?

Because `ptr` is pointing at address 1000

Let's go back briefly to the lesson where we talked about how to create a pointer. We mentioned that it is important to specify the data type for what the pointer will be pointing to. In that lesson I explained that asking for the data at a memory address is not enough

In this case

Therefore

The whole 16 bits that make up the variable `height`. Why? Because when we created the pointer `ptr` we specified that it will be used for pointing at variables of the data type `unsigned short int`. 

What would happen if we set *ptr = 0; ?

Then C understands that because ptr was created to look at two-bytes

    int height = 10;      // height is stored at the memory address 1000 
    int *ptr = &amp;height;

    *ptr = 0;

The final result is:

    ...
    1000 : 0000 0000 &lt;--- ptr points here
    1001 : 0000 0000 
    ...

Think of `*ptr = 0;` as saying: ""Store the `unsigned short int` value of zero (that means: 0000 0000 0000 0000) into the memory location at position 1000 in ram""

So you can see that `*ptr` will see and change *two bytes* of data which begin at whatever memory address is stored in `ptr`. 

Now

No. 

Because C understands we have created a pointer for type `unsigned short int`, that we are doing so on the understanding that each element we point to is an `unsigned short int`. 

This means that C realizes that if we say `ptr = ptr+1;`, this means that we want to cause `ptr` to point at the next *two bytes* in memory, and C assumes that those next *two bytes* are an `unsigned short int`.

In our last lesson because we were using the data type `char`

In this example

This reasoning holds true for any data type. 

So now

    int height = 10;      // Set height to ten.
    int width  = 5;       // set width to 5

    int *ptr   = &amp;height; // ptr contains the memory address 1000 (eight)

    ptr  = ptr + 1;       // ptr now contains the memory address 1010 (ten)

    *ptr = 14;            // Change the entire two-bytes at location 1010 to fourteen: 0000 0000 0000 1110.

Keep in mind that this example is purely for the sake of this lesson. Our 16-byte ram is special because variables always get stored one after the other. In your real ram

The final state of ram after this code is:

    ...
    1000 : 0000 0000 &lt;--- first half of height; 
    1001 : 0000 1010 &lt;--- second half of height. 
    1010 : 0000 0000 &lt;--- first half of width; &lt;--- ptr contains ""1010"" 
    1011 : 0000 1110 &lt;--- second half of width.
    ...

Notice that width is now set to fourteen.
----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pxnj/test_of_lessons_30_through_39/
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pwqs/lesson_39_about_pointers_concerning_multibyte/
1256992673.0,9znll,Lesson 120 : A simple rendering algorithm,CarlH,64,4,6,"In the last lesson I showed you that we need to have some function which can combine our ""raw data"" with our ""display model"" to create a usable final result that can be displayed. 

Here is how this process is intended to work:

    _XO_XXX_O =&gt; [ ][X][O]
                 [ ][X][X]
                 [X][ ][O]

Now

    _XO_XXX_O

Produces this as output:

                 [ ][X][O]
                 [ ][X][X]
                 [X][ ][O]

How do we convert the raw data to a usable version that can be displayed.

Let's think of this process another way. We are to some extent creating a sort of mathematical operation


    _XO_XXX_O +  [ ][ ][ ] =  [ ][X][O]   
                 [ ][ ][ ]    [ ][X][X]   
                 [ ][ ][ ]    [X][ ][O]   

Let's rewrite this as:

    A + B = C

A is our ""raw data"". B is our rendered blank tic-tac-toe board. C is the final result which is achieved by ""joining together"" A and B.

Let's first evaluate the data format itself: `_XO__XX_O`

Every character in this simple text string corresponds to a square on the final tic-tac-toe board. We know there are three possibilities. An underscore character means that we ""do nothing"". That is to say

We know that we have to do this one at a time for each character. We can write out a simple loop for this in pseudo-code like this:

    for each character :
        if 'X' : place 'X' into proper square
        If 'O' : place 'O' into proper square
        proceed to next character.

Notice that I do not have any operation to take place if the square is blank. Whenever you are writing an algorithm

Now, we are saying ""While there are still squares left to render... render the next one."" 

Let's re-write this as a while loop in pseudo-code:

    while (there are squares left to render) {
        if 'X' : mark square as 'X'
        if 'O' : mark square as 'O'
    }

So this algorithm is going to ""stay alive"" until the last square is rendered. Now all we need is a mechanism to ""mark the square"". Remember what I said in an earlier lesson: You always understand an algorithm by starting with the first iteration.

The same applies when designing an algorithm as it applies when reading one. Therefore

You should clearly see then that this will be skipped

Our 'X' character needs to be rendered in our display model. Let's again look at our display model:

    [ ][ ][ ]
    [ ][ ][ ]
    [ ][ ][ ]

Alright

    [ ][ ][ ]\n[ ][ ][ ]\n[ ][ ][ ]\n

The key point to understand here is that each space within the brackets is an ""insertion point"" where a rendered X or O can be placed. It is therefore important to identify all of these points. I am going to place a hash mark inside all insertion points to make this clearer.

    [#][#][#]\n[#][#][#]\n[#][#][#]\n

Now, after the first iteration, our display model would look like this:

    After 1st iteration : [ ][#][#]\n[#][#][#]\n[#][#][#]\n

Notice that the remaining # characters indicate the insertion points not yet processed. Now we are on our second iteration. For this next insertion point

    After 2nd iteration : [ ][X][#]\n[#][#][#]\n[#][#][#]\n

Now, then array[3] is a '[' character, and array[4] is the insertion point we just placed an X into.

If that was confusing

    0 1 2 3 4 5
    [   ] [ X ]

In other words

    array[4] = 'X';

Now

    [#][#][#]$[#][#][#]$[#][#][#]$

The locations of each hash mark above are:

    #1 : array[1]
    #2 : array[4]
    #3 : array[7]

    #4 : array[11]
    #5 : array[14]
    #6 : array[17]

    #7 : array[21]
    #8 : array[24]
    #9 : array[27]

Do you notice a pattern here? Each set of three increases by exactly ten from where the previous set began. We start at 1, within each set of three, the next hash mark is located exactly three characters ahead of the previous character.

Whenever you notice a pattern

    for (i = 0; i &lt;= 2; i++) {
        for (j = 1; j &lt;= 7; j+=3) {
            hash is array[ (i * 10) + j ]
        }
    }

Understanding this algorithm is easy if you start with the first iteration. On the first iteration

    i = 0
        j = 1
            hash is array[ (i * 10) + j ] OR
            hash is array[0 + 1] OR

            hash is array[1]

So the first time this executes

    i = 0
        j = 4
            hash is array[4]

Notice that with any algorithm you process the inner most loop first. Therefore

    i = 0; j = 7
    array[7]

And now the fourth. Here we have reached the condition of the inner loop (j is now &lt;= (which means less than OR equal to) seven). So now we can say the following:

    i = 1; j = 1;
        array[ (i * 10) + j ] OR...
        array[10 + j] OR...
        array[11]

Now the instruction ""i++"" (which means add 1 to the variable 'i') executes. Therefore i changes from 0 to 1.

Notice that j also gets reset to 1. Any time the inner loop finishes

Remember that our for loop is only dealing with two simple variables: `i` and `j`. They each follow a set pattern. Finally

    iteration #1 : i=0; j=1;     array[1]
    iteration #2 : i=0; j=4;     array[4]
    iteration #3 : i=0; j=7;     array[7]
    iteration #4 : i=1; j=1;     array[11]
    iteration #5 : i=1; j=4;     array[14]
    iteration #6 : i=1; j=7;     array[17]
    iteration #7 : i=2; j=1;     array[21]
    iteration #8 : i=2; j=4;     array[24]
    iteration #9 : i=2; j=7;     array[27]

Now looking at this

    for (i = 0; i &lt;= 2; i++) {

That should make sense to you as you look at the values for the variable 'i' in the above table. The variable 'i' starts at zero. Then each time that loop finishes

    for (j = 1; j &lt;= 7; j+=3) {

When you look at the values for 'j' above

Here you can see that we have constructed an algorithm which is capable of going through and precisely hitting each insertion point that we will be replacing with either an 'X' or an 'O'. If this process still seems a bit like black magic

1. First you must look closely at the display model. In this case

2. Then you must identify all of the points in that model which will need to be ""hit"" by the algorithm you are designing. In this case we found they were: `1, 11, 14, 17, 21, 24, 27`.

3. Next

4. Then

5. Finally you write the actual algorithm

In the next lesson I will show you how to take this algorithm and create a function that can  render and display our raw tic-tac-toe board data.

-----

Please ask questions if any of this material is unclear. When ready

http://www.reddit.com/r/carlhprogramming/comments/9zs8i/lesson_121_our_final_tictactoe_board_display/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9znll/lesson_120_a_simple_rendering_algorithm/
1256964566.0,9zkve,Lesson 118 : Introducing a new use for the while loop,CarlH,65,2,17,"One of the first kinds of loops we learned about was the while loop. In the last lesson I showed you that every time you mark a square in the tic-tac-toe game

Now

    Start tic-tac-toe game 
    Think about move &lt;-------------------------.
    Make a move                                |
    Wait for opponent to make a move           |
    Run checks related to game over
    Think about next move ---------------------'

Notice how there is a loop inherent in this process. It is a natural part of what it means to be playing a game

    while (game is in progress) {
        think about next move;
        make move;
        wait for opponent to make move;
        check if game is over
    }

And the final closing brace simply indicates to return back to the start of the loop. Let's examine the start of the loop again now:

    while (game is in progress) {

Using what we learned a couple lessons ago

    while (is_game_in_progress() )  {
    }

Now we are using a function for this purpose. Therefore, repeat, and keep repeating until finally the game is over.

Let's list this as a requirement:

    [ ] A function to determine if the game is still in progress

This applies for applications as well as games. Any time you start any program, do this""

A program should not be thought of as merely a set of instructions to perform a task. Rather

These kinds of loops can be thought of as the mechanism that keeps a program alive. In most applications

    while ( is_game_running() ) {
        start_level_1();

        while ( is_level_1_in_progress() ) {
            ... 
            introduce_enemy_unit();

            while ( enemy_unit_is_alive() ) {

The above example works for games

    while ( is_program_running() ) {
        new_drawing();

        while ( is_drawing_active() ) {
            load_paint_brush();

            while ( is_paint_brush_active() ) {

And so on. By created ""nested"" loops such as these

This concept is also useful for algorithms that are designed to complete a complex task. Consider a sorting routine:

    while ( is_data_sorted_yet() ) {
        ...
    }

So the idea is that the ""process"" of sorting the data will remain ""alive"" until some point is reached where the data is finally sorted. At this point

Again just as with functions you can see that there are different ""kinds"" of loops. I am here introducing you to a while loop whose purpose is to keep the program itself

Notice also as I show you these concepts that writing a program is largely about recognizing where to apply the correct tools. It is not about ""forcing a tool to work."" The nature of the program will dictate what kind of tool you need. Planning a project is simply recognizing what tools you need at various points within the project.

Now, I am also showing you that you can have ""kinds"" of loops. As far as a programming language is concerned, one while loop is really no different than any other. But as a programmer, you can be creative and apply different purposes to a loop. 

In this case, the very word ""alive"" may be enough to indicate the need for this kind of loop. 

----

Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9zn2t/lesson_119_the_basics_of_rendering_and_displaying/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zkve/lesson_118_introducing_a_new_use_for_the_while/
1255117724.0,9sj83,Lesson 76 : Understanding Array Indexing as Pointer Offsets Part Four,CarlH,67,6,10,"In this lesson

    ""One$__Two$__Three$Four$_""

Now

    storage[0] :  0,  3,  4,  5 : ""One""
    storage[1] :  6.  7.  8.  9. 10
    storage[2] : 12, 15, 16, 17 : ""Three""
    storage[3] : 18, 21, 22, 23 : ""Four""

Now we have all the information we need to finish. The last step in our task is to use printf() to actually display these strings as if they were arrays.

Normally we would do this:

    printf(""Here is a string %s""

But *what* exactly goes there? A pointer to a string. In other words

Let's now see this in action:

    printf(""The 1st string is: %s \n""
    printf(""The 2nd string is: %s \n""
    printf(""The 3rd string is: %s \n""
    printf(""The 4th string is: %s \n""

Notice that ptr + 0 is the same thing as ptr. Here you see that I am just giving printf() the correct memory address to the start of the string I want to print.

In our next lesson we will do away with the `storage` array altogether.

Now
----
    #include &lt;stdio.h&gt;

    int main() {

        char storage[]   = ""12345678901234567890123"";

        char *ptr = &amp;storage[0];

        *(ptr + (6*0) + 0) = 'O';
        *(ptr + (6*0) + 1) = 'n';
        *(ptr + (6*0) + 2) = 'e';
        *(ptr + (6*0) + 3) = '\0';

        *(ptr + (6*1) + 0) = 'T';
        *(ptr + (6*1) + 1) = 'w';
        *(ptr + (6*1) + 2) = 'o';
        *(ptr + (6*1) + 3) = '\0';

        *(ptr + (6*2) + 0) = 'T';
        *(ptr + (6*2) + 1) = 'h';
        *(ptr + (6*2) + 2) = 'r';
        *(ptr + (6*2) + 3) = 'e';
        *(ptr + (6*2) + 4) = 'e';
        *(ptr + (6*2) + 5) = '\0';

        *(ptr + (6*3) + 0) = 'F';
        *(ptr + (6*3) + 1) = 'o';
        *(ptr + (6*3) + 2) = 'u';
        *(ptr + (6*3) + 3) = 'r';
        *(ptr + (6*3) + 4) = '\0';

        printf(""The 1st string is: %s \n""
        printf(""The 2nd string is: %s \n""
        printf(""The 3rd string is: %s \n""
        printf(""The 4th string is: %s \n""

        return 0;
    }

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sjii/lesson_77_introducing_memory_allocation_using/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sj83/lesson_76_understanding_array_indexing_as_pointer/
1254405768.0,9pv6q,Lesson 38 : About changing the memory address stored in a pointer.,CarlH,131,67,25,"Remember that a pointer contains a value, then it has no meaning except for the memory address 1000 and the data that resides at that memory address. 

Let's look again at the 16-byte ram example from the previous lesson:

    ...
    1000 : 0110 0001 : 'a' &lt;--- ptr points here
    1001 : 0110 0010 : 'b'
    1010 : 0110 0011 : 'c'
    1011 : 0011 0001 : '1'
    1100 : 0011 0010 : '2'
    1101 : 0011 0011 : '3'
    ...

Remember that since we are talking about a string of text

Notice that we have reverted back to the state of RAM from before we changed the 'a' to 'b'. We still have a pointer called `ptr` which contains the memory address 1000 and which therefore points to the 'a' character.

We know from the previous example that we can change the data at location 1000 by the following line of code:

    *ptr = 'b';

What if we wanted to change the next character? 

In general

It turns out we already know the address of the next character in our string. It would be 1001 in ram, we get the address of 'b'. If we add one to that address, we get the address of 'c', and so on. 

If we want to change the 'a' in our ram

We can see this in action with the following code:

                         // To start with

    *ptr = 'A';          // With this instruction we have changed 'a' to 'A'
    ptr = ptr + 1;       // by adding 1 to ptr

    *ptr = 'B';          // Now we have changed 'b' (what was at 1001) to 'B'
    ptr = ptr + 1;       // By adding 1 to ptr

    *ptr = 'C';          // Now we have changed 'c' to 'C' by changing ""what is at"" that address.

What are we saying here? First of all the pointer `ptr` is pointing the memory address 1000

Then

Here is the state of our ram after these instructions have executed:

    ...
    1000 : 0100 0001 : 'A'
    1001 : 0100 0010 : 'B'
    1010 : 0100 0011 : 'C'  &lt;--- ptr points here
    1011 : 0011 0001 : '1'
    1100 : 0011 0010 : '2'
    1101 : 0011 0011 : '3'
    ...

Notice that `ptr` is pointing where we left it

We have changed the data that used to be ""abc"" and have turned it into ""ABC"". Also we have seen an important principle in action. It is often necessary when working with data to start at the beginning of the data

Also we have learned an important fact concerning pointers: You can add a value to a pointer and cause it to point to a different location in memory. In our example, etc. 

Whenever you change the memory address of a pointer, then `*ptr` will refer to the data at the address, for example an 'a'. 

If we change the `ptr` so that it points to a different address

Any time you change the memory address contained in a pointer

----
Please feel free to ask any questions before continuing to:

http://www.reddit.com/r/carlhprogramming/comments/9pwqs/lesson_39_about_pointers_concerning_multibyte/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pv6q/lesson_38_about_changing_the_memory_address/
1254087941.0,9omg2,End of Day 2 of /r/carlhprogramming,CarlH,191,131,37,"[Edit: This was written September 28

Thank you everyone for your support and dedication on this project. I hope you have enjoyed this course as much as I have enjoyed making it available. I cannot believe that what started as an offer to teach a handful of people has resulted in nearly two thousand people being signed up. I am glad to be a part of this and I hope it continues to grow.

I know that many of you are watching this sub-reddit continually looking for the next lesson. For that reason

I put up a lot of lessons today

Congratulations to everyone on having not only written your first ""Hello Reddit"" program, than simply typing code out of a book.

I need to go until tomorrow. Meanwhile I encourage everyone to continue to build the community by helping out so that everyone is able to master all the lessons so far presented. I welcome any feedback or questions.

Remember this is only day two. ",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9omg2/end_of_day_2_of_rcarlhprogramming/
1343784701.0,xhcpq,I am thinking of adding individual progress tracking at Higher Computing for Everyone. What are your thoughts on this?,CarlH,72,10,16,"A few people have asked me to set up some kind of individual progress checking at Higher Computing for Everyone. I would like to hear what you think of this idea. 

If you agree, questions, and feedback in this thread.

----

Edit: Thank you everyone for your feedback. I will definitely be implementing some form of progress tracking in the very near future. Also

For now

1. A more direct ""path"" to finishing a lesson, (3) Optionally read or skim the text, (4) When finished, Click ""I am finished with this lesson"".

2. Certain lessons should yield rewards/achievements/badges/etc. Two that I can think of right off hand are one for starting the course

3. Every lesson completed should earn a number of points proportional to the size of the lesson

4. Tracking what lesson you were last on

Any other ideas?

----

Edit: http://www.reddit.com/r/carlhprogramming/comments/xj01g/carlhprogramming_i_added_lesson_tracking_and_an/",,t5_2r81y,1343874822.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xhcpq/i_am_thinking_of_adding_individual_progress/
1256987354.0,9zn2t,Lesson 119 : The basics of rendering and displaying data,CarlH,65,5,14,"It is possible to write a tic-tac-toe game that never actually displays a tic-tac-toe board. Similarly

Data exists only within the computer as a sequence of 1s and 0s. Nothing says that a sound file has to be played or that a graphics file has to be displayed on the screen. Indeed

The act of creating a ""usable"" image from raw data is known as ""rendering"". For example, textures, and so on. However, until it is rendered it will remain just data. Rendering will convert that data into an image that can be displayed on your monitor.

Notice therefore that any data has to go through some rendering process before that data can be displayed or visualized. There are various ways to achieve this. 

Suppose that you were writing a chess game. You therefore need to have some data format which stores the actual chess position at any time. With this data, and everything else you may need to do. However, you cannot display the raw data.

You could however go into your favorite graphics program and draw out a chess board complete with texture, and so on. Next you could similarly draw out all of the chess pieces. Finally, you could have a function which reads your raw data of the chess position and then starts inserting chess piece graphics into the graphic of the blank chess board. The final result would be a fully rendered version of your chess position. This perfectly illustrates what I am trying to explain.

Now

     _XO \n
     _XX \n
     X_O \n

Notice because of the \n characters

We could define our raw data instead like this:

    _XO__XX_O

Now

    [ ][ ][ ]
    [ ][ ][ ]
    [ ][ ][ ]

There it is. When we display our tic-tac-toe board

    char tictactoe_display_model[] = ""[ ][ ][ ]\n[ ][ ][ ]\n[ ][ ][ ]\n"";

We have here created data which is *ready* to display correctly. In this case

Now all we need is a process which can take our tic-tac-toe board *raw data* and combine it with our *display model* to create what we will actual display to the screen. Let's visualize this process:

    _XO__XX_O =&gt; [ ][X][O]
                 [ ][ ][X]
                 [X][ ][O]

Notice that the ""data"" itself is only 9 characters in size. I do not need to include any \n characters. Our display model is 30 characters in size. We can perform various manipulations on the data without affecting the display model. When we are ready to display the tic-tac-toe board

Here is something to consider. The same tic-tac-toe board data: `_XO__XX_O` can just as easily be rendered into actual graphics. You could for example easily create a graphics file of a blank grid of 3x3 squares for a tic-tac-toe game. Then you could write a function which goes and draws actual X and O graphics into those squares. It is not difficult. We may in fact visit this later in the course.

This same concept applies with web-based applications. You can write out a web page in simple HTML which has no ""moving parts""

    &lt;p&gt;Hello {name}

That is your ""display"". You could easily have a function which converts `{name}` into the person's actual name by doing a lookup from some database. We will go over this later in the course.

----

Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9znll/lesson_120_a_simple_rendering_algorithm/
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zn2t/lesson_119_the_basics_of_rendering_and_displaying/
1255809941.0,9v2mh,Test of Lessons 85 through 98 [Answers],CarlH,66,2,9,"You may post your answers to this thread. If you have any questions about any of these answers

----

**True or False**

1. When you call a function
2. Pointer arithmetic will always add one byte regardless of the data type being pointed to. For example, I will be pointing to one byte further away in memory. **False**
3. As long as you know the size of the data type you are working with, I can type `4` instead of `sizeof(int)` in a program I am writing. **False**
4. You cannot have more than one pointer pointing to the same location in memory. **False**
5. If you have variables with names like: `var1, etc.`, It is possible to write a loop which will know how to complete the variable name with the proper number. **False**


**Fill in the Blank**

1. You use the `_____` ""machine code"" instruction to place data ""onto"" the stack. **PUSH**
2. You use the `_____` ""machine code"" instruction to retrieve data from the stack. **POP**
3. The two operations used in questions 1 and 2 above operate on which part of the stack? `_____` (The middle, etc). **TOP**
4. A `_____` is an operation when you take data of one data type (such as `int`, and you transform the same data to a different data type. Usually this is done by putting the *new* data type in parentheses in front of the old data. **Cast**
5. Using variables with names like `var1

----

When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v36d/lesson_99_a_quick_review_on_casting/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v2mh/test_of_lessons_85_through_98_answers/
1254438171.0,9q0mg,Lesson 43 : Introducing the constant.,CarlH,131,68,45,"Up until now we have only spoken about variables. We have learned that you can create a variable and then later you can change it. For example you can write:

    int height = 5;
    height = 2;
    height = 10;

All of this is valid. There is nothing that stops you from storing a new value in a variable. 

The reason we use the name ""variable"" is because variables can be changed. In other words

This is not the case with a constant. A constant is data that is stored in ram just like a variable

The first question you might have is

Consider this code:

    char *string = ""Hello Reddit!"";

We know from the previous lesson that the text ""Hello Reddit!"" is stored in memory, it created it as a constant. 

If we create a pointer and point it at that text

Just to review: A variable can be changed and is both readable and writable. A constant cannot be changed and is only readable. 

----
Please ask any questions and be sure you have mastered this material before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9q543/lesson_44_important_review_and_clarification_of/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9q0mg/lesson_43_introducing_the_constant/
1254419133.0,9pxnj,Test of Lessons 30 through 39,CarlH,124,60,2,"**Please do not post answers in this thread.**

----

**True or False**

1. A string of text is stored in memory like a ""train""
2. When you create a pointer
3. Pointers can be used for looking at as well as changing data at a given memory address.
4. If you use a pointer to replace data at a given memory address
5. Whenever you increase a pointer by one

**Fill in the blank**

1. A `_____` can be used as a way to refer both to the value at a given memory address
2. The `_____` character means ""address of"".
3. The `_____` character means ""what is at the address of"".
4. In the code in section (a)
5. If you wish to use printf() to print the memory address stored in a pointer, etc)

(a)

     unsigned short int width = 3;
     unsigned short int height = 9;

     unsigned short int *my_pointer = &amp;height;

     printf(""%d""

----
When done

http://www.reddit.com/r/carlhprogramming/comments/9pxq7/test_of_lessons_30_through_39_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pxnj/test_of_lessons_30_through_39/
1349471438.0,110gcg,[CarlHProgramming] I will be live-streaming building a web application framework from scratch.,CarlH,73,12,0,,t5_2r81y,False
1257037758.0,9zs8i,Lesson 121 : Our final tic-tac-toe board display function,CarlH,66,5,23,"In the last lesson I showed you the basic algorithm we need in order to locate all of the different points that we want to write an 'X' or a 'O' into our ""display model"". In this lesson

First

    _XO_XXX_O +  [ ][ ][ ] =  [ ][X][O]   
                 [ ][ ][ ]    [ ][X][X]   
                 [ ][ ][ ]    [X][ ][O]   

Now

    char raw_data[] = ""_XO_XXX_O"";
    char display_model[] = ""[ ][ ][ ]\n[ ][ ][ ]\n[ ][ ][ ]\n"";

Now we already know the algorithm which will ""hit"" all of the spaces inside our display model


    for (i = 0; i &lt;= 2; i++) {
        for (j = 1; j &lt;= 7; j+=3) {
            ... array[ (i * 10) + j ] ...
        }
    }

Now we are ready to begin. 

In order to make this algorithm effective

The first character from our raw data will go in position array[1] with our display model. In this case of course, just like we saw in the last lesson.

Let me draw a simple table showing this:

    raw_data[0] =&gt; display_model[1]
    raw_data[1] =&gt; display_model[4]
    raw_data[2] =&gt; display_model[7]
    raw_data[3] =&gt; display_model[11]
    raw_data[4] =&gt; display_model[14]
    raw_data[5] =&gt; display_model[17]
    raw_data[6] =&gt; display_model[21]
    raw_data[7] =&gt; display_model[24]
    raw_data[8] =&gt; display_model[27]
   
Seeing patterns is absolutely a critical skill for a programmer. Here you should see three distinct patterns. The `raw_data` has some number that is continually increasing by one. The `display_model` has two variables

We have already taken care of i and j. Now we need a third variable which will simply increase by one with each iteration. Let's look again at our for loop structure:

    for (i = 0; i &lt;= 2; i++) {
        for (j = 1; j &lt;= 7; j+=3) {
            ... array[ (i * 10) + j ] ...
            ... somehow here we need a third variable for raw_data ...
        }
    }

Now

    for (i = 0; i &lt;= 2; i++) {
        for (j = 1; j &lt;= 7; j+=3) {
            display_model[ (i * 10) + j ] = raw_data[k];
        }
    }

The last thing we need to do is simply create k. Well, but we do not really need to.

You see

    int i = 0;
    int j = 0;
    int k = 0;

    for (i = 0; i &lt;= 2; i++) {
        for (j = 1; j &lt;= 7; j+=3) {
            display_model[ (i * 10) + j ] = raw_data[k++];
        }
    }

And we are done. By placing ""k++"" inside of the `raw_data` index, and this is done by saying k++.

Note that: 

    display_model[ (i * 10) + j] = raw_data[k++];

is the same as:

    display_model[ (i * 10) + j] = raw_data[k];
    k++;

Now let's observe the final process:

----
    #include &lt;stdio.h&gt;
    
    int main(void) {
    
        char raw_data[] 		= "" XO XXX O"";
        char display_model[] 	= ""[ ][ ][ ]\n[ ][ ][ ]\n[ ][ ][ ]\n"";
    
        int i
    
        for (i = 0; i &lt;= 2; i++) {
            for (j = 1; j &lt;= 7; j+=3) {
                display_model[ (i * 10) + j ] = raw_data[k++];
            }
        }
    
    	printf(""%s\n""
    	
    }

----

You will notice that I used a simple shortcut for creating our i, you can make exceptions for simple loops. This is because I am initializing i and j in the very next lines of code. Also, notice I set k to zero. 

I also made one other small change. I removed the underscores and replaced them with spaces. This removes the need to have some kind of process to check if there is an underscore, instead of an underscore character meaning ""nothing"", we are using the space for the same purpose. It changes nothing concerning the process involved, it simply speeds it up.

It would be trivial to modify this function to use underscores instead of spaces. You could just add an if() statement that would skip over that iteration if an underscore were present

        for (i = 0; i &lt;= 2; i++) {
            for (j = 1; j &lt;= 7; j+=3) {
                if (raw_data[k] != '_') {
                    display_model[ (i * 10) + j ] = raw_data[k++];
                } else {
                    k++;
                }
            }
        }

This simply translates to ""skip to the next k iteration if this is an underscore.""

Now we can easily transform this algorithm into a function and we have a proper way to display our tic-tac-toe board based on the raw data

----

    #include &lt;stdio.h&gt;
    
    int main(void) {
    
        char raw_data[] 		= "" XO XXX O"";

        display_board(raw_data);

        return 0;
    	
    }

    void display_board(char *raw_data) {
        char display_model[] 	= ""[ ][ ][ ]\n[ ][ ][ ]\n[ ][ ][ ]\n"";
    
        int i
    
        for (i = 0; i &lt;= 2; i++) {
            for (j = 1; j &lt;= 7; j+=3) {
                display_model[ (i * 10) + j ] = raw_data[k++];
            }
        }
    
    	printf(""%s\n""
    }

----

Notice that when I created the function all I did was cut-pasted *exactly* the same code I had in the main() function. You can experiment with this by changing the ""raw data"" that goes to the function

Please ask questions if any of this material is unclear to you. When ready

http://www.reddit.com/r/carlhprogramming/comments/9zsyo/lesson_122_function_to_evaluate_a_won_position/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zs8i/lesson_121_our_final_tictactoe_board_display/
1255670903.0,9ulj6,Lesson 96 : Using Casts with Pointers Part Two,CarlH,71,12,19,"In this lesson I am doing something highly unorthodox for the purpose of better explaining and illustrating pointers and casts. I therefore feel it is necessary to preface this lesson. This is purely for illustrative purposes. I want you to see that bytes are just bytes

This is poor programming practice to actually do what is shown in this lesson in any real program. Just remember as you read this lesson

----


In the last lesson, as opposed to creating one integer at byte 0, and another integer at byte #6 (which is actually a rather dumb thing to do, but I am showing this to you so that you understand pointers better). In this lesson, we are going to continue but this time with the original plan.

So

    &lt; B0 B1 B2 B3  &gt;  &lt; B6 B7 B8 B9 &gt;    &lt;--- two 4-byte integers

B4 and B5 will be ""wasted space"".

As you recall in the last lesson, point it to the address of ""`main_pointer`"", and finally I have to ""type cast"" our new pointer so that C knows our intentions.

Let's review the syntax of this. First

    char *main_pointer = malloc(10);

Then we created an integer pointer

    int *int_pointer = (int *) main_pointer;

This created a pointer of type `int *` (pointer to integer. That is what the `*` means). It contains the memory address of the start of our 10 bytes. This means that we have bytes: `&lt;B0-B1-B2-B3&gt;` in use as an integer pointer. By dereferencing that pointer

How about bytes: `&lt;B6-B7-B8-B9&gt;` ? Well, it will point to B8. We simply cannot reach byte #6.

Pointer arithmetic always works based on the size of the data type the pointer is tied to. An int pointer will increment/decrement by 4 bytes. A char pointer will increment/decrement by one byte.

Therefore, we can use type casting. Observe:

    int *int_pointer2 = (int *) (main_pointer + 6);

Notice what I did here. (main_pointer + 6) is a memory address. That memory address corresponds to byte #6. We are type casting it using `(int *)`. Our type cast allows us to assign the new value (after the type cast) to a new pointer we created called `int_pointer2`. 

Keep in mind at this stage we have *three* total pointers. `main_pointer` is our primary pointer which is pointing at byte #0 of a ten byte memory space. `int_pointer` is an integer pointer which points at the same address as `main_pointer`, `int_pointer2` is our third pointer, just like `int_pointer` except it points at byte #6. 

It is perfectly ok to have many pointers all looking at the same range of memory. it is perfectly ok if multiple pointers contain the same memory address, that change will be visible by all pointers which point to that memory address. 

Alright

----

    int *int_pointer1 = ( int *) (main_pointer + 0);
    int *int_pointer2 = ( int *) (main_pointer + 6);

    *(int_pointer1 + 0) = 53200;
    *(int_pointer2 + 0) = 32000; 

Now, if I were to look at each byte one at a time, I would see that the first integer is occupying bytes &lt;B0-B1-B2-B3&gt; and the second integer is occupying bytes &lt;B6-B7-B8-B9&gt;. I would also see that bytes B4 and B5 will be unchanged, and contain whatever they used to.

Keep in mind that this lesson is for instructional purposes only. It is *not* good programming practice to do this. 

I am only showing it to you so that you can see that in fact it can be done

Now

It should be apparent to you that if you are naming variables with a number at the end

However

----

Not so many lessons today as it is my son's birthday (5 years old). 

I will write more tomorrow

----

Please ask questions if any of this is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9umha/lesson_97_introducing_arrays_of_pointers_part_one/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9ulj6/lesson_96_using_casts_with_pointers_part_two/
1279398691.0,cqq09,"[CarlHProgramming] Questions thread. Any questions from any past lesson, or general question about computing welcome.",CarlH,69,6,http://www.reddit.com/r/carlhprogramming/comments/cqq09/carlhprogramming_questions_thread_any_questions/, a number of you may be stuck/confused on various lessons. 

Please post your question in this thread

This will also help give me an idea what previous lessons might need better explanation.

----

**Quick update**: 

I have switched the site away from JavaScript navigation today. Many of you have asked for it

I have also removed the green introduction from the top of the pages

Please test out the new navigation and let me know your thoughts.

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/cqq09/carlhprogramming_questions_thread_any_questions/
1257048098.0,9zt04,Lesson 123 : About functions returning values other than 1 and 0,CarlH,64,5,8,"In the last lesson I showed you how to write a simple function to evaluate a won position for any tic-tac-toe position. This function returns 1 every time a position is won. It achieves exactly the purpose we gave it in that it can tell us perfectly if a position is won for either 'X' or 'O'.

What it cannot tell us however is *how* the position was won. Was it won vertically, but it turns out there is a much easier way.

Remember earlier I told you how the ""zero flag"" works. Really

In other words

Put another way

    if (5) { printf(""Five \n""); }
    if (-3) { printf(""Negative Three \n""); }
    if (0) { printf(""Zero \n""); }

Output:

    Five
    Negative Three

Notice then that the only result which does not output is ""Zero"". If an if statement evaluates as ""zero"" then it is false. If it evaluates to *any non zero value* it will evaluate as true. We can take advantage of this to get more details from our function.

Instead of writing `return 1;`  each time a win is confirmed

    0 : No win is detected
    1 : A horizontal win is detected
    2 : A vertical win is detected
    3 : A diagonal win is detected

Keep in mind that if we return a 1, the same if statement we used earlier will evaluate:

    if (is_winning_position(raw_data
        ... this will work for ANY non-zero value ...
    }

That means inside of that if statement
    

    if (int return_value = is_winning_position(raw_data
        if (return_value == 1) {
            printf(""A horizontal win resulted for X!"");
        }
        if (return_value == 2) {
            printf(""A vertical win resulted for X!"");
        }
    }

This is useful. However

We could therefore create a map of all eight possibilities. However

Is there another way we can do this? Remember that each test uses a for loop to go through columns and rows. We therefore *know* what number of row (0, 3, 6) we are dealing with. Observe now how we can put all of this information together to get much more detailed information about won positions:

----

    int is_winning_position(char *raw_data

        int i;

        // Test for horizontal win
        for (i = 0; i &lt;= 6; i+=3) {
            if (raw_data[i] == player &amp;&amp; raw_data[i+1] == player &amp;&amp; raw_data[i+2] == player) {
                return 10 + i;
            }
        }

        // Test for vertical win
        for (i = 0; i &lt;= 2; i++) {
            if (raw_data[i] == player &amp;&amp; raw_data[i+3] == player &amp;&amp; raw_data[i+6] == player) {
                 return 20 + i;
            }
        }

        // Test for diagonal win
        if (raw_data[4] == player) {
            if (raw_data[0] == player &amp;&amp; raw_data[8] == player) {
                return 31;
            }
            if (raw_data[2] == player &amp;&amp; raw_data[6] == player) {
                return 32;
            }
        }

        return 0;

    }

Notice that 10 + i; will translate to 10 for the first row, and 32 for the other diagonal.

All of these return values will evaluate as ""True"" by our if statement simply because they are non-zero values. We can now see not only if a position is won, and 30 as ""starting points"", we can easily determine whether or not the win was horizontal, vertical, or diagonal. 

----

Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9zt0h/lesson_124_introducing_switch_and_case/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zt04/lesson_123_about_functions_returning_values_other/
1257047715.0,9zsyo,"Lesson 122 : Function to evaluate a ""won"" position",CarlH,67,8,4,"There are exactly three ways that a tic-tac-toe position can be won: Horizontal

Let's consider the `raw_data` format we used in the previous lesson. The first and most obvious won position would look like this:

    XXX =&gt; raw_data = ""XXX______"";
    ___
    ___

Let's look at the array index positions for our tic-tac-toe board:

    012
    345
    678


In other words, and [2] would be set to 'X' (or 'O'), then a win exists.

There are three possibilities for a horizontal win for 'X'. They are:

    raw_data[0]
    raw_data[3]
    raw_data[6]

Do you see any patterns? If we think of this table as having three rows

We could write this out in pseudo-code like this:

    for (i = 0; i &lt;= 6; i+=3) {
        ... test: raw_data[i]
    }

That would go through all three rows and test to see if we have a horizontal won position. All it is really saying is this:

    start at position [0] (the start of the first row)
    check to see if position [0]
    jump to the next row (by adding three) and repeat

So to check to see if a horizontal win exists, [2] and then repeat this test after adding 3. We do this for all three rows and we have finished. Now this test can be easily done using an if statement for the first row, like so:

    if (raw_data[0] == 'X' &amp;&amp; raw_data[1] == 'X' &amp;&amp; raw_data[2] == 'X') {
        ... horizontal win exists for 'X' ...
    }

This would test the first row for a horizontal win. Notice that the nature of the '&amp;&amp;' operation means that `raw_data[2] == 'X'` will only take place if the other two tests confirmed. Remember that we learned this in a previous lesson. Therefore

Now we just need to convert that if() statement to something that works for all three rows

    int i;

    for (i = 0; i &lt;= 6; i+=3) {
        if (raw_data[i] == 'X' &amp;&amp; raw_data[i+1] == 'X' &amp;&amp; raw_data[i+2] == 'X') {
            ... horizontal win exists ...
        }
    }

Now

    X__ =&gt; raw_data[] = ""X__X__X__""
    X__
    X__

So here we see that a vertical win exists where there are 3 'X' (or 'O') that are exactly 3 apart. If you find an 'X' on the first row

Let's convert this to an algorithm. First

    if (raw_data[0] == 'X' &amp;&amp; raw_data[3] == 'X' &amp;&amp; raw_data[6] == 'X') {
        ... vertical win exists ...
    }

Now

    for (i = 0; i &lt;= 2; i++) {
        if (raw_data[i] == 'X' &amp;&amp; raw_data[i+3] == 'X' and raw_data[i+6] == 'X') {
             ... vertical win exists ...
        }
    }

And we are done.

Lastly, and there is no need for a for loop:

    012 =&gt; the raw_data[] positions for our tic-tac-toe board
    345
    678

    if (raw_data[0] == 'X' &amp;&amp; raw_data[4] == 'X' &amp;&amp; raw_data[8] == 'X') {
    if (raw_data[2] == 'X' &amp;&amp; raw_data[4] == 'X' &amp;&amp; raw_data[6] == 'X') {

Notice that both of these if statements have `raw_data[4]` in common. Therefore

    if (raw_data[4] == 'X') {
        if (raw_data[0] == 'X' &amp;&amp; raw_data[8] == 'X') {
            ... diagonal win exists ...
        }
        if (raw_data[2] == 'X' &amp;&amp; raw_data[6] == 'X') {
            ... diagonal win exists ...
        }
    }

Here we are saying that we test the center square first. If the center square is not marked

All we have to do now is put all of this together into a simple function. First we should consider what parameters do we need to send to this function? Certainly we need to send `raw_data`

----

    int is_winning_position(char *raw_data
        int i;

        // Test for horizontal win
        for (i = 0; i &lt;= 6; i+=3) {
            if (raw_data[i] == player &amp;&amp; raw_data[i+1] == player &amp;&amp; raw_data[i+2] == player) {
                return 1;
            }
        }

        // Test for vertical win
        for (i = 0; i &lt;= 2; i++) {
            if (raw_data[i] == player &amp;&amp; raw_data[i+3] == player &amp;&amp; raw_data[i+6] == player) {
                return 1;
            }
        }

        // Test for diagonal win
        if (raw_data[4] == player) {
            if (raw_data[0] == player &amp;&amp; raw_data[8] == player) {
                return 1;
            }
            if (raw_data[2] == player &amp;&amp; raw_data[6] == player) {
                return 1;
            }
        }

        return 0;

    }

----

Do not let the `== player` confuse you. We are simply using the word ""player"" in place of whatever character was sent. If 'X' was sent

I used one other trick here. I return 1 every time a win is confirmed. I return 0 at the end. This means that the only way this function will return 0 is if it has exhausted all possibilities of a win. In other words, it will return 0 only if no win is found.

This means we can use our function as a question in an if statement like this:

    if (is_winning_position(raw_data
        printf(""X has won!"");
    }

You can very easily read that as: ""If this is a winning position for 'X'. If and only if the function returns a 1 then this if statement will evaluate as true. 

----

Please ask questions if any of this material is unclear. When ready

http://www.reddit.com/r/carlhprogramming/comments/9zt04/lesson_123_about_functions_returning_values_other/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zsyo/lesson_122_function_to_evaluate_a_won_position/
1343225912.0,x4r3a,"[CarlHProgramming] All lessons through Course #1, Unit 9 now available as videos.",CarlH,65,8,http://www.reddit.com/r/carlhprogramming/comments/x4r3a/carlhprogramming_all_lessons_through_course_1/

http://www.highercomputingforeveryone.com

",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/x4r3a/carlhprogramming_all_lessons_through_course_1/
1255809790.0,9v2lo,Test of Lessons 85 through 98,CarlH,62,6,0,"**Please do not post your answers in this thread. Someone who has not yet taken the test may see them.**

In a way, I think it is a good idea to have a test here.

----

**True or False**

1. When you call a function
2. Pointer arithmetic will always add one byte regardless of the data type being pointed to. For example, I will be pointing to one byte further away in memory.
3. As long as you know the size of the data type you are working with, I can type `4` instead of `sizeof(int)` in a program I am writing.
4. You cannot have more than one pointer pointing to the same location in memory.
5. If you have variables with names like: `var1, etc.`, It is possible to write a loop which will know how to complete the variable name with the proper number. 


**Fill in the Blank**

1. You use the `_____` ""machine code"" instruction to place data ""onto"" the stack.
2. You use the `_____` ""machine code"" instruction to retrieve data from the stack.
3. The two operations used in questions 1 and 2 above operate on which part of the stack? `_____` (The middle, etc).
4. A `_____` is an operation when you take data of one data type (such as `int`, and you transform the same data to a different data type. Usually this is done by putting the *new* data type in parentheses in front of the old data.
5. Using variables with names like `var1

----

When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9v2mh/test_of_lessons_85_through_98_answers/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9v2lo/test_of_lessons_85_through_98/
1254398372.0,9pu1h,Lesson 37 : Using pointers for directly manipulating data in memory.,CarlH,128,66,34,"In an earlier lesson we saw that text is encoded as individual ASCII bytes and stored in memory like a train. We also learned that because each memory address only contains one byte of actual memory

Lets review this by going back to our 16-byte RAM example

    ...
    1000 : 0110 0001 : 'a'
    1001 : 0110 0010 : 'b'
    1010 : 0110 0011 : 'c'
    1011 : 0011 0001 : '1'
    1100 : 0011 0010 : '2'
    1101 : 0011 0011 : '3'
    ...

Did I make a mistake? I hope you noticed that I forgot to terminate the string with a null (all zeroes) byte. 

Now

    char *ptr = &lt;address in memory of the 'a'; 1000&gt;;

This is of course not real syntax. For now

Now we learned that the * character takes on a new meaning once the pointer has been created. Now we can use our pointer `ptr` in two ways in the source code:

    ptr = the address in memory of 'a'
    *ptr = 'a' itself

Notice that we have not created any `char` variable for the 'a' itself. The truth is

Up until now we have learned that you can use pointers to *look at* data in memory. For example

    int total = 5;
    int *my_pointer = &amp;total;

    printf(""The total is: %d""

This code should make *perfect* sense to you. You should also know exactly what the above line of code will output:

    The total is: 5

So here we have an example of using a pointer to ""see"" what is in memory. Now I am going to show you that you can use a pointer to ""change"" what is in memory also. 

Let's go back to our 16-byte ram example. Here we have the pointer `ptr` which contains the address 1000 which corresponds to the 'a' character. The 'a' character in this case is the first of the string ""abc123"".

When we say *ptr, then it will no longer be an 'a'. 

In fact

    ...
    1000 : 0110 0001 : 'a' &lt;----- ptr points here
    1001 : 0110 0010 : 'b'
    ...

Since we know that `ptr` points to address 1000

    *ptr = 'b';

What have we just done? We have written a line of C that reads like this:

""Replace the binary sequence at position 1000 with the ASCII character 'b'""

After this line of code executes

    ...
    1000 : 0110 0010 : 'b' &lt;----- ptr still points here
    1001 : 0110 0010 : 'b'
    ...

We have changed the 'a' to a 'b'. 

Where did the 'a' go? It is *gone*. It is as if it never existed. Since the data itself has been changed in the memory location that 'a' used to reside at

This means that if we create a variable and assign it some value

Consider this code:

    int total = 5;
    int *my_pointer = &amp;total;

    *my_pointer = 10;

    printf(""The total is: %d""

What do you think will be the output? Consider what is happening here. We are saying

This means that the variable `total` has been changed. The old value of 5 is gone forever

In this lesson you have learned that you can use pointers not only to look at memory directly
----
Please feel free to ask any questions before proceeding to:

http://www.reddit.com/r/carlhprogramming/comments/9pv6q/lesson_38_about_changing_the_memory_address/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9pu1h/lesson_37_using_pointers_for_directly/
1256928452.0,9zghv,Lesson 116 : Using functions as questions,CarlH,61,7,3,"It is often the case when writing a program that you will need to ask *some question* concerning the data you are working with. For example

Let's consider our question ""Is the game over"" as a mixture of ""English"" as well as ""programming code"". It would look like this:

    if (game is over) {

Whenever you write out plain-English ""code"" like this

You should see from our pseudo-code example that it would make sense to use a function here. Let's see how that would look:

    if (game_is_over()) {

Notice how our words ""game is over"" can perfectly translate to a function name. Our code has now with very little effort transformed from pseudo-code to actual ""C"" code.

The idea then is to cause the ""`game_is_over()`"" function to return a 1 if the game is over

If the ""`game_is_over()`"" function returns a 1

    if (game_is_over()) { : becomes
    if (1) {

Why? Because remember that if `game_is_won()` returns a 1

So in other words

For example:

    if ( player_is_out_of_ammunition() ) {

And you can see how easy that is to read. 

Back to our tic-tac-toe-game, who won. So, let's consider how that might look:

    if (game_is_over()) {
        if (winner_is_x()) {
        }
        if (winner_is_o()) {
        }
        if (game_was_a_tie()) {
        }
    }

Notice how easy this is to read.

We haven't yet decided how to make these functions

    [ ] Functions we need for our tic-tac-toe data structure
        [ ] Determine if the game is over
        [ ] Determine if X won
        [ ] Determine if O won
        [ ] Determine if the result was a tie

Now, who is winning, etc. These types of functions are useful any time you need to ask any question. 

So in this lesson I am showing you that functions are not merely chunks of code that can achieve some task

In later lessons I will show you other kinds of functions you can create

----

Please ask questions if any of this material is unclear. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9zijj/lesson_117_introducing_function_hierarchy/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zghv/lesson_116_using_functions_as_questions/
1255101079.0,9sg2i,Test of Lessons 60 through 72,CarlH,63,5,4,"**Please do not post answers in this thread.** 

Others may see the answers if you do.

----

**True or False**

1. Saying `*(my_pointer)` is the same thing as saying `*(my_pointer + 0)`
2. A `for loop` is a ""short-hand"" way of writing a `while loop`.
3. A four dimensional array is actually an array of 3 dimensional arrays.
4. If `my_string` is an array of characters
5. The code in Figure (a) is done correctly.

**Fill in the blank**

1. To create a for loop which will start by setting the variable `i` to 3 that will execute 4 times
2. When trying to understand an algorithm
3. For array indexing to work properly
4. To assign a string to an element of a 2-dimensional array
5. The 3rd line of code in Figure (a) below will imply that `my_pointer` is a pointer to what type of data? `_____`.

Figure (a)

    char my_string[] = ""Hello"";
    char *my_pointer;

    my_pointer = &amp;my_string;

----

When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9sg8m/test_of_lessons_60_through_72_answers/
",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9sg2i/test_of_lessons_60_through_72/
1254168114.0,9owms,"End of day 3, and some notes.",CarlH,139,81,http://www.reddit.com/r/carlhprogramming/comments/9owms/end_of_day_3_and_some_notes/

I know we are covering a lot of material here very quickly

Please remember this: The speed at which I am putting these lessons up *is not* the speed at which I expect you to finish them. It is far more important that you master each lesson than that you try to keep up with me. *Do not skim any lesson.*

If you are still on lesson three, and I respond to every one - except in those cases where someone else has accurately replied (thanks for the help guys!). 

If a lesson is completely over your head

If by chance you do not get a response to your question, do not be afraid to ask for help.

Also *take the tests*. You might look at a test and say ""I know all these answers"",,False,,t5_2r81y,True,,True
1256942091.0,9zijj,Lesson 117 : Introducing function hierarchy,CarlH,59,3,7,"We established in the last lesson that there are certain functions we need to write which have the purpose of determining if something is true or false. It is useful to give these functions names that make it easy to distinguish them from other functions we will use. A good way to do this is to put the word ""is"" in front of each function that is designed to be used as a question. For example: `is_game_over()`.

Now

We need some function called ""mark_square()"". Let's list that as a requirement:

    [ ] A function that can mark a square in the 3x3 grid

Now,2)` or `mark_square(1,1)`. Lastly, we need to know whether to mark the square as an 'X' or an 'O'. 

Our final function therefore will have three sub-requirements:

        [ ] Argument to specify X coordinate
        [ ] Argument to specify Y coordinate
        [ ] Argument to specify X/O to mark

Planning a project effectively requires you to put yourself in the mental state as though a given task were already finished

Consider now that we *have* a working function that can mark a square as an X or O anywhere we want. We also have from our previous lesson functions that can determine if a game is won

Let's take this lesson and the last lesson and write a small bit of pseudo-code that helps us to understand how our program will work in general whenever a player makes a move.

    mark_square(...);
    if (game_is_over() ) {
        if (winner_is_x() ) {
        ...
        if (winner_is_o() ) {
        ...
        if (game_is_tie() ) {
        ...
    }
    ...

You should be able to see that every time we mark a square, who the winner is, etc. 

Think about this not as a programmer, and if so who won.

Now

Every time a move is made, we have to check for X, then O, then a tie.

Let's write out the above paragraph slightly different:

    move is made
        -&gt; is_game_over()
            -&gt; is_winner_x()
            -&gt; is_winner_o()
            -&gt; is_game_tie()

You can see that a natural hierarchy forms without any effort on our part. Observe that I do not create a hierarchy of functions. The hierarchy creates itself

For example

Consider these two examples: 

    Figure (a) : Running all functions one after the other

    mark_square(...);
    if ( is_game_over() ) {
        if ( is_winner_x() ) {
            ...
        ...
    }

The problem with this approach is that anywhere we use `mark_square()` in our program, every time we write out `is_game_over()` we have to write out all the code related to who the winner was. If at some point later on we had to change any of that code, we would have to manually change it *everywhere* we had done this. This would be tedious and frustrating. 

However

    Figure (b) : Taking advantage of function hierarchy

    int mark_square(int x
        .... code to mark the square goes here ...

        if ( is_game_over() ) {
            if ( winner_is_x() ) {
                 ...
            }
        ...
        }
    }

Notice that this is only possible because we are first planning out our project. If we had started the tic-tac-toe game by just writing code

Observe what I have done. I have taken the `mark_square()` function and I have caused this function to call the `is_game_over()` function

Here you can see a simple example of function hierarchy. One function calls another. That function calls another. It is possible to write more powerful and complex programs by being able to take advantage of functions you have already written. By having these ""layers"" of functions

Now I will show you a similar example taken from another application. If you have a function that can draw a single pixel, you can write a word, and if you have that function, you can write a paragraph. And so on.

Whenever you cause one function to call another

We will explore this more later in the course.

----

Please ask questions if any of this is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9zkve/lesson_118_introducing_a_new_use_for_the_while/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zijj/lesson_117_introducing_function_hierarchy/
1256926123.0,9zg1z,Lesson 115 : Structures contain data and information about that data,CarlH,57,1,4,"In the last lesson I showed you the basics behind how to manage simple projects. Fundamentally this comes down to keeping track of the different tasks you are doing

Now

First of all

Let's put that down as a requirement:

    [ ] A structure exists to contain the tic-tac-toe board

That is simple enough. Notice that this is a statement of fact. It is either true

Let's be more specific. What should be contained in this structure? First of all

        [ ] Contains an array of 3x3 characters

To plan the next step, but that is all it can contain.

Our goal is to contain not only the tic-tac-toe board

So our next set of requirements should be ""Information about the tic-tac-toe board"".

Here are a few such requirements we can have:

    [ ] Whose turn it is (X or O)
    [ ] Whether the position is won for 'X'
    [ ] Whether the position is won for 'O'
    [ ] What ""move #"" this is (first move

We could always add on later, we will want to have additional information such as potential moves to evaluate, whether or not the position looks like X is winning or O is winning, and so on.

Containing data as well as information about that data is an important programming concept which we will explore later.

Now, a tic-tac-toe board. This ""thing"" in this case is a 3x3 array. But this ""thing"" also has information associated with it. 

The tic-tac-toe board is the ""thing""

Let's suppose we have a data structure for a paint-brush in some graphics program. The paint-brush is the ""thing"". However, perhaps the type of the brush, and so on.

So you can see here that it is important to realize that when you construct a data structure

Now

    [ ] Tic-Tac-Toe Game
        [ ] A structure exists for the tic-tac-toe board position
            [ ] Whose turn it is (X or O)
            [ ] Whether the position is won for 'X'
            [ ] Whether the position is won for 'O'
            [ ] What ""move #"" this is (first move

Notice that our requirements are not concerned with *how* we implement these things. We are simply stating them as goals to achieve to complete the project. 

----

Please ask questions if any of this material is unclear to you. When you are ready

http://www.reddit.com/r/carlhprogramming/comments/9zghv/lesson_116_using_functions_as_questions/",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/9zg1z/lesson_115_structures_contain_data_and/
1317934223.0,l3e8m,PDF/.doc Versions of Entire First Course (Version 0.2),tkwb,63,13,24,"Hey guys

I spent about twenty minutes today manually compiling these from Carl's site. I haven't added anything or modified formatting or anything. I'll work on correcting/prettying-up formatting as I have time and release new versions.

http://dl.dropbox.com/u/42863719/HigherComputingForEveryone%200.2.doc

http://dl.dropbox.com/u/42863719/HigherComputingForEveryone%200.2.pdf


Please leave any suggestions. Primarily

1) Would you rather it be one long document (currently around 266 pages)

2) Typeface/size?

3) General comments

Thanks guys

EDIT: Huge thanks to jambarama and zouhair

http://www.reddit.com/r/carlhprogramming/comments/l3e8m/pdfdoc_versions_of_entire_first_course_version_02/c2pm8vl",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/l3e8m/pdfdoc_versions_of_entire_first_course_version_02/
1344576315.0,xzebs,[CarlHProgramming] Quick Update,CarlH,64,10,6,"Hey everyone

Just a quick heads up to let you know that I won't be able to do more lessons until probably Wednesday or Thursday. Meanwhile, etc.

All is well,,False,,t5_2r81y,False,,True
1343469932.0,xakzo,Interactive quizzes and tutorials are now integrated into Higher Computing for Everyone.,CarlH,60,9,6,"Hi everyone

I have now added functionality for interactive tests and tutorials built right into each unit. I have also added quizzes to Units 1 through 10. 

Feedback appreciated.

[See Here](http://highercomputingforeveryone.com/Course_1/Unit_2/Quiz_1/)",,t5_2r81y,1343480601.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xakzo/interactive_quizzes_and_tutorials_are_now/
1314027500.0,jqnvj,I don't know if anyone will find this useful but here are my notes on the first 15 units of the program (google doc),justhereforhides,61,8,5,"(Self link because I that's just how I role) 

https://docs.google.com/document/d/1a2d2onRg1isaiCPw8_KGiaTtGAGhYCMmYv9P_qlFGl4/edit?hl=en_US

Feel free to give feedback

Edit: I've been a bit busy getting ready for college,False,,t5_2r81y,True,,,t3_jqnvj
1343039801.0,x0dr5,"[CarlHProgramming] All lessons through Course #1, Unit 8 now available as videos.  ",CarlH,59,8,http://www.reddit.com/r/carlhprogramming/comments/x0dr5/carlhprogramming_all_lessons_through_course_1/,,
1352499613.0,12xpf2,"[CarlHProgramming] Announcing Free Personalized Lessons, And next live coding session.",CarlH,54,8,http://www.reddit.com/r/carlhprogramming/comments/12xpf2/carlhprogramming_announcing_free_personalized/

First Announcement:

I am looking for around 10 people who want to learn programming

If you want to be one of the people

1. What programming language/languages/technologies do you want to learn?
2. What is your eventual goal?
3. What is your experience
4. A brief description of your educational background.
5. Roughly what schedule you would prefer. Ex: Only on weekends

Edit: Some people are asking if slots are still open, expect this to happen next week some time.


----

Second Announcement:

Tomorrow (Saturday

I am going to continue the process of building a web application framework from scratch

----

[Watch live November 10th,False,,t5_2r81y,1352591948.0,,,t3_12xpf2
1344198406.0,xq87b,"[CarlHProgramming] Course #1, Unit 12 Finished. All lessons converted to video, and end-of-unit quiz added.",CarlH,52,2,False,
1276512322.0,cerqp,"[New Lesson Published] Course 2, Unit 4, Lesson 13 : Better understanding of Analysis Functions",CarlH,48,5,False,
1276504405.0,ceqss,"For those who do not know, here is an easy way to set up an RSS-Feed for seeing when new lessons are available [CarlHProgramming]",CarlH,41,5,http://www.reddit.com/r/carlhprogramming/comments/ceqss/for_those_who_do_not_know_here_is_an_easy_way_to/

This tip was suggested by caesararum on my other post. Much thanks.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/ceqss/for_those_who_do_not_know_here_is_an_easy_way_to/
1347918244.0,101lmc,"[CarlHProgramming] Update : All videos for Units 13 and 14 published, Quiz for Unit 13 added.",CarlH,42,5,http://www.reddit.com/r/carlhprogramming/comments/101lmc/carlhprogramming_update_all_videos_for_units_13/

* Lesson 14.1

(I will update this post as additional text lessons are completed).

Once I am done updating the text lessons for Unit 14,False,,t5_2r81y,False,,,t3_101lmc
1350725146.0,11sj1j,Shimon Schocken: From NAND to Tetris - Internet course that let you understand computers better,userdei,38,6,0,,t5_2r81y,False
1350263509.0,11hlgn,Building a PHP MVC Web Application Framework - Session 2 - Q&amp;A,liveat60fps,35,6,18,"For those following Carl's series about building web applications

The recording of the second session (October 13th 2012) can be found [here](http://www.youtube.com/watch?v=nHuH19D8JtU).

Thanks to Carl for his hard work in presenting these sessions to us.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/11hlgn/building_a_php_mvc_web_application_framework/
1351912679.0,12jsdv,[CarlHProgramming] No live coding session this Saturday ,CarlH,33,3,3,"Sorry everyone

I am recovering from a bad flu,,False,,t5_2r81y,False,,True
1350692507.0,11ryt4,"Reminder: Session 3 of ""Building a web application framework from scratch"" begins Sat, Oct 20, 9:00 PM EST",CarlH,33,6

----


Hello everyone

Today (Sat

In this course, such as Apache. You also will typically need a server side scripting language, to handle everything that happens to your code in order to create what the end-user will see, and for that we will be using PHP. You also need a database to store your information, and for that we will be using MySQL, and so on.

In this course you will learn about how to build your own complex web applications

When you have completed this course, version control, and more. 

In the previous sessions

----

[Session #1

Major topics that were covered:

* Setting up a server (Amazon EC2
* Setting up a web server (Apache 2.0 on an Ubuntu Linux Machine)
* Configuring a development environment (GNU Screen, etc.)
* The basics of networking and IT security (firewall rules
* The basics of using a version control system (GIT)
* The basics of server side scripting (PHP)

In this session

----

[Session #2

Major topics that were covered: 

* How to use GNU Screen to save your work/session for later.
* The basics of HTML and Forms
* The basics of how to use log files
* Using .htaccess to force all URLs to go to a central ""controller""
* The basics of Model View Controller methodology.
* The basics of Regular Expressions

In this session we explored GNU screen more

----

[Session #3

Major topics expected to be covered:

* Setting up a MySQL Server
* Creating simple PHP scripts that store data in a MySQL database
* The basics of using Sessions
* More about using GIT for version control
* Further development of the MVC itself

As with all sessions, so expect me to Google for things when I get stuck, and to perhaps spend some time troubleshooting when something doesn't work right. 

Also

",,t5_2r81y,1350828664.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/11ryt4/reminder_session_3_of_building_a_web_application/
1346097039.0,yx4ed,"CarlH, How Do You Feel About Codeyear / Codecademy?",Ganrao,40,14,http://www.reddit.com/r/carlhprogramming/comments/yx4ed/carlh_how_do_you_feel_about_codeyear_codecademy/

I see you offer your own online course teaching programming and that is really an awesome thing to do for people. I only discovered this subreddit after realizing Reddit probably has a large programmer community that I could go join. So how do you feel about Codeyear?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/yx4ed/carlh_how_do_you_feel_about_codeyear_codecademy/
1345628359.0,ympb1,"[CarlHProgramming] Course #1, Unit 13 New Video Lessons (Sticky)",CarlH,34,5,http://www.reddit.com/r/carlhprogramming/comments/ympb1/carlhprogramming_course_1_unit_13_new_video/, the text versions of these lessons will be re-written.

Here are links to the completed lessons:

**These lessons will remain in Unit 13**

* [Lesson 13.1 : The basics of algorithm design part 1](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_1/)

* [Lesson 13.2 : The basics of algorithm design part 2](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_2/)

* [Lesson 13.3 : The basics of algorithm design part 3](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_3/)

* [Lesson 13.4 : The basics of algorithm design part 4](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_4/)

----

**These lessons (13.5 onward) will become the new Unit 14:**


* [Lesson 13.5 : Introducing Multi-Dimensional Arrays](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_5/)

* [Lesson 13.6 : Introducing Multi-Dimensional Arrays (part two)](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_6/)

* [Lesson 13.7 : Introducing Multi-Dimensional Arrays (part three)](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_7/)

* [Lesson 13.8 : Introducing Multi-Dimensional Arrays (part four)](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_8/)

* [Lesson 13.9 : Introducing strcpy() ](http://www.computerscienceforeveryone.com/Course_1/Unit_13/Lesson_9/) 

If you have not already completed Units one through twelve

(All videos are now published)",,t5_2r81y,1346837706.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/ympb1/carlhprogramming_course_1_unit_13_new_video/
1344221064.0,xqsgx,Will there be any lessons on 2d graphics? ,thirdeyesanta,30,1,2,"I've taken some courses on programming but haven't learned anything on 2d graphic applets. Having knowledge on the mechanics is extremely important for any programmer but without the knowledge of graphics,,
1364770500.0,1bdujw,carlhprogramming,thenetworka,33,6,6,When is Carl coming back to make more videos?,t5_2r81y,True
1353202762.0,13dn4k,"[CarlHProgramming] No livestream today, sorry. Livestreams and lessons will resume after the holidays.",CarlH,35,8,http://www.reddit.com/r/carlhprogramming/comments/13dn4k/carlhprogramming_no_livestream_today_sorry/

I will be resuming lessons and livestreams around the beginning of January. I hope that everyone has an enjoyable holiday season.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/13dn4k/carlhprogramming_no_livestream_today_sorry/
1351309693.0,125rj3,New Video Lessons for Unit 16,CarlH,30,1,0,"I will update this post as new lessons are published. Note that I am posting URLs as soon as they become available

* [16.1 Using Pointers with Offsets Part 1](http://www.youtube.com/watch?v=3y3BqAU7CqM)
* [16.2 Using Pointers with Offsets Part 2](http://www.youtube.com/watch?v=7s9sZ_lYttw)
* [16.3 Using Pointers with Offsets Part 3](http://www.youtube.com/watch?v=IewsNZv6Mso)",,t5_2r81y,1351315668.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/125rj3/new_video_lessons_for_unit_16/
1362933593.0,1a11hd,carlhprogramming google hang out,thenetworka,30,5,10,"anyone interesting in google hangout to talk about this course and other things related to computer science?

what time would you guys like to google hangout?",,t5_2r81y,1364044821.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/1a11hd/carlhprogramming_google_hang_out/
1362532708.0,19qufw,PSA: OS X users should not use Codeblocks for this course. Use XCode instead.,valtism,33,7,11,"Codeblocks performs horrible on OS X. Instead,,
1351364147.0,126m5h,Reminder: Live Coding Session starts at 9:00 PM EST Today.,CarlH,29,4,0,,t5_2r81y,False
1348721867.0,10jsho,New Videos for Unit 15 : Review of Pointers,CarlH,31,5,2,"Hello everyone

I am currently in the process of editing and publishing video lessons for Unit 15. I will be updating this post as each video is published.

* [Lesson 15.1](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_1/)
* [Lesson 15.2](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_2/)
* [Lesson 15.3](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_3/)

Lesson 15.4 ETA: Oct 5
",,t5_2r81y,1349216869.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/10jsho/new_videos_for_unit_15_review_of_pointers/
1346459644.0,z5wuw,Making a stopwatch in C,einargud,27,1,6,"Hey!

After following the course pretty well (I'm at 12.2 atm) I've decided that I want to make a stopwatch calculator (time * something + something) for for related stuff.

I know how to make the stopwatch

I've also made one that displays hour:min:seconds one after another like so:

    00:01:50
    00:01:51
    00:01:52
    00:01:53
    00:01:54
    etc    

But is it possible to show a ticking stopwatch at the same location? Without writing a new line every second and without clearing the screen. Pretty much changing the number that's already on the screen.

I hope you understand :)",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/z5wuw/making_a_stopwatch_in_c/
1345371995.0,ygv9e,"[CarlHProgramming] Switched servers, please report any issues.",CarlH,32,7,http://www.reddit.com/r/carlhprogramming/comments/ygv9e/carlhprogramming_switched_servers_please_report/

I went through the courses myself

http://www.computerscienceforeveryone.com",,t5_2r81y,1345493088.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/ygv9e/carlhprogramming_switched_servers_please_report/
1351449077.0,12896i,Reminder: Live Coding Session starts at 4:00 PM EST Today.,CarlH,27,2,7,"Today at 4:00 PM EST I will be hosting a live recap session on the topic of how to build a web application framework from scratch. You can watch it here: http://www.justin.tv/livecompsci

---- 

Edit: This has already happened,False,,t5_2r81y,1351534320.0,,,t3_12896i
1349741066.0,116123,New Videos for Unit 15 Published,CarlH,28,2,1,"Unit 15 is now complete

* [Pointer Review Part 1](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_1/)
* [Pointer Review Part 2](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_2/)
* [Pointer Review Part 3](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_3/)
* [Pointer Review Part 4](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_4/)
* [Pointer Review Part 5](http://www.computerscienceforeveryone.com/Course_1/Unit_15/Lesson_5/)
",,t5_2r81y,1349748446.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/116123/new_videos_for_unit_15_published/
1308554527.0,i45f2,Question on Lesson 27...,Steiny,30,4,6,"Sorry

So the code I've written for lesson 27 goes like this:

 int main ()    
{
    int chance = 50;
    printf(""Before I flip a coin there is a %d percent chance it lands\n heads
    printf(""But after I flip the coin and get heads
    return 0;
}    

Formatted that way
Before I flip a coin there is a 50 percent chance it lands
heads
But after I flip the coin and get heads
 percent chance it would land heads?    

The obvious ""fix"" is to chance the second reference (%d) to a plain old ""50"", and show me how I could use %d twice in the same command or whatever it's called.

Thanks again,False,,t5_2r81y,False,,,t3_i45f2
1361420208.0,18xnhh,Login not working.,Iasklotsofthings,29,7,9,"I lost the password for my first account so I tried making another account. I tried but nothing happens,,
1344044199.0,xngfo,So what exactly is the difference between C and C++?,funkyrailroad,26,4,19,"Or maybe ""exactly"" is not the biggest issue,,
1372131632.0,1h0l4e,"These lessons are great, I hope they don't end like this.",jailbird5000,30,9,http://www.reddit.com/r/carlhprogramming/comments/1h0l4e/these_lessons_are_great_i_hope_they_dont_end_like/, there are plenty of other tutorials,
1356379136.0,15dynu,"Youtube is blocked in my country, is there any way i can download the videos?",zack12,29,7,http://www.reddit.com/r/carlhprogramming/comments/15dynu/youtube_is_blocked_in_my_country_is_there_any_way/

I can use VPN,False,,t5_2r81y,False,,,t3_15dynu
1343774162.0,xh20v,[CarlHProgramming] All Lessons in Unit 11 on Course #1 have been converted to videos,CarlH,30,7,0,"Today I finished uploading the last videos for Unit 11 in Course #1. This was by far the trickiest set of lessons so far. I ended up splitting Lesson 1 into two lessons

Only five more units to go,False,,t5_2r81y,False,,,t3_xh20v
1343656621.0,xe2ut,Course 1 Unit 6.3: Fractals question,atceh,23,1,9,"I understand that I have to converge to an approximate number

But wouldn't it be easier if

    0010 . [ 0001 ] [ 0000 ] [ 0000 ]
           1/10     1/100    1/1000

This could represent every fractal from .0 to .999 which would take many more bits for being accurate to a 1000th.

Is this true or am I overseeing something?",,t5_2r81y,1343657639.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xe2ut/course_1_unit_63_fractals_question/
1318001030.0,l4700,"Working off tkwb's doc of the entire first course, I created a doc &amp; pdf with linked table of contents, and used tex to make a pretty pdf.  Enjoy!",jambarama,25,0,False,
1358823382.0,17157n,Why can I build and run this program in CodeBlocks on Windows but not in Xcode on Mac OS X?,eldormilon,25,2,13,"[Here is a screenshot](http://i.imgur.com/BBuYiyy.png) of what happens when I try to run this simple program using Xcode on Mac OS X.

It works fine when I run it using CodeBlocks in Windows. The problem is

I have already installed Command Line Tools for Xcode.

Could anyone propose a possible solution to this problem? Do I have to use different code because of the different OS?

And if you see this Carl

**EDIT**: This problem has been solved thanks to the suggestions by wormnut and Creating_Logic.",,t5_2r81y,1358870024.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/17157n/why_can_i_build_and_run_this_program_in/
1337033073.0,tn4wv,"Why is it difficult to learn a C version language if 
you learned programming thru Python first
the other way around? ",11,12,http://www.reddit.com/r/carlhprogramming/comments/tn4wv/why_is_it_difficult_to_learn_a_c_version_language/,"Just a claim that was presented in another thread but wasn't explained. The thread is locked. I assume it has to do with syntax logistics, but how more specifically? ",,,,
1367787798.0,1dr1fu,http://www.computerscienceforeveryone.com/ down now. Any news/updates?,Johnnybananaa,26,6,10,I havent finished and cant reach the site now,t5_2r81y,True
1333904979.0,rzejc,Does anyone know of any other tutorials like these?,treeman1,27,7,13,"I want to continue learning programming like Carl has been teaching it
Also,False,,t5_2r81y,False,,,t3_rzejc
1320800461.0,m5hsp,"This code shouldn't work, but it does?",CMahaff,25,4,http://www.reddit.com/r/carlhprogramming/comments/m5hsp/this_code_shouldnt_work_but_it_does/

    struct card ca;
    ca.currentCard = 15;
    strcpy(ca.name
    printf(""Card: %d\n""
    printf(""Name: %s\n""

(Example is completely random). This example differs from the ""Learn to Program"" series - there is no memory allocation and the struct is not  declared as a pointer. Is this bad syntax?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/m5hsp/this_code_shouldnt_work_but_it_does/
1361221331.0,18rtzq,What will I be able to do after completing the course?,,26,6,5,"I just started the course,,
1353425118.0,13ifkc,Why do we need pointers?,TopNFalvors,23,4,11,"Hello

I am coming from a VB.NET background

Why does C need pointers?  I understand the syntax

Like in the ""real world""

Thanks!",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/13ifkc/why_do_we_need_pointers/
1350418952.0,11l70t,Assembly Tutorials?,ph34r,25,5,10,"Hi everyone

Does anyone know of any good tutorials that will help push me in the right direction for a novice programmer looking to understand assembly? If they are structured similar to Carl's that would be great,False,,t5_2r81y,False,,,t3_11l70t
1343838761.0,xigbu,What to move on to after the C course?,,20,2,4,Part way through the C course on Carls site and was wondering what i should move onto after completing the course? Other sites? Books?,t5_2r81y,True
1330428269.0,q9kmw,pdf Version of Unit 2,asielen,23,5,7,"I found the pdf versions of the first unit easier to follow than the website but as far as I can tell no one has made a pdf version of the second unit so

Let me know what you guys think.

http://dl.dropbox.com/u/14417731/CarlH_Unit2_v1.pdf",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/q9kmw/pdf_version_of_unit_2/
1310723290.0,iqagv,[CarlHProgramming] What would you like to learn?,CarlH,21,2,33,"When I start up new lessons

Therefore,False,,t5_2r81y,False,,,t3_iqagv
1362075117.0,19epgz,Just found this reddit and looking to start. Always wanted to learn.,Fall3nF3ars,21,2,9,"I just found this site and wanted to start,False,
1352659024.0,130p23,"Visual for Arrays of Pointers, lesson from unit 2",muffinman007,19,1,http://www.reddit.com/r/carlhprogramming/comments/130p23/visual_for_arrays_of_pointers_lesson_from_unit_2/,False,
1319382093.0,lm1qe,"Why isn't Course 2, Unit 5, Lesson 3 Showing up?",Alt950,29,2, but not three. Three is already made

Link to Lesson 3: http://www.highercomputingforeveryone.com/Course_2/Unit_5/Lesson_3/

EDIT: Anyone know when the next Lesson (Lesson 4) gunna be put up? .-.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/lm1qe/why_isnt_course_2_unit_5_lesson_3_showing_up/
1314651306.0,jyby1,Slight Confusion,He_mea_maa_mau_ia,22,4,1,I do not know if anyone else was troubled by this but the link to download codeblocks is in lesson 5.3 but in lesson 5.1 is when you can start tinkering around with some code. Can the link be put in 5.1 also or is it meant to be that way? Thanks for all the hard work!,t5_2r81y,True
1366453878.0,1cqh5s,Where's Carl?,grudypv,22,4,3,Will he ever be found?,t5_2r81y,True
1361244013.0,18smxq,"Are the lessons availalbe in a way that can be reviewed offline.
",3,1,http://www.reddit.com/r/carlhprogramming/comments/18smxq/are_the_lessons_availalbe_in_a_way_that_can_be/,,,False,t5_2r81y,True
1345583475.0,yln0n,Practicing Coding,Cellax,19,3,6,"I have been following the tutorials online and I think they are great.  However,,
1322974597.0,mzghl,How do I make my printf() make it so that it creates a new line?,Mrlucky77,26,8,9,"At this moment

[My code](http://codepad.org/yUGVXz2l)",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/mzghl/how_do_i_make_my_printf_make_it_so_that_it/
1372055983.0,1gye0r,I'm having trouble finding the program (for lack of better word) to write my first program in.,listos,18,1,11,"What I mean is episode 5 tells me to write a program,False,
1367855910.0,1dsqon,hello . no videos further lessons 16.3 ?,d2idan,22,7,6,,t5_2r81y,True
1356859056.0,15o26h,Thank you so much for this!,chriswhitlock91,23,6,8,"My dad is a computer programmer for HP and for 21 years I've wondered what he does. I'd ask him ""i know what a programmer IS, but I'm already learning and it's interesting stuff. Never thought I'd learn what my dad does from someone other than my dad :-P",t5_2r81y
1351765499.0,12g9g6,Looking for online resources for exercises.,Nooobish,17,2,3,"Can anyone recommend some online resource where coding exercises are provided similar to what is usually found at the end of chapters in college textbooks?  
I can play around on Codeblocks but having someone set specific tasks to reach and then showing me a solution so I can compare my solution to it would be greatly beneficial.  
Truth be told,,False,,t5_2r81y,False,,True
1349157356.0,10syr3,Formatting CodeBlocks? ,sirbikesalot,17,1,4,"I've just found out about this course and I am really enjoying it,False,
1345558587.0,ykww6,"[CarlHProgramming] New supplemental video uploaded for Course #1, Lesson 13.2 : Displaying data in memory as binary.",CarlH,21,5,http://www.reddit.com/r/carlhprogramming/comments/ykww6/carlhprogramming_new_supplemental_video_uploaded/,,
1344734819.0,y2nsg,1.14.5 pointers and arrays,WeiZhiqiang,20,3,3,"Relatively minor question

(type)* pointer = &amp;array

where array[] has already been declared.

What would you use for this,False,,t5_2r81y,False,,,t3_y2nsg
1347459539.0,zrlkd,"(Hopefully) an interesting article on C, C++ and linked lists",fuzzybootz,21,5,http://www.reddit.com/r/carlhprogramming/comments/zrlkd/hopefully_an_interesting_article_on_c_c_and/,,
1344378519.0,xuj3h,A question about pointers and their significance,bestpatriots,15,1,6,"Note: I saw the lesson where it explained what the need for pointers were and I was amazed by the fact


Are the CTRL+C and CTRL+V functions on any computer a result of pointers? What I'm saying is that suppose you have a string of text that corresponds with a URL, are you basically making a pointer and thus when you paste, you are merely referencing to the address of the pointer (such as with an &amp;)? And if true, wouldn't the memory address of it be gone when you close the program? 

This is just a curious question to further expand the my understanding of the significance of pointers. If it's much more complex,False,,t5_2r81y,False,,,t3_xuj3h
1344294676.0,xsj6m,Question on 1.10.6 pointers and arrays,WeiZhiqiang,15,1,3,"In the lesson the code is:

char string[] = ""Hello Reddit"";
  char *my_pointer = string;

  printf(""The first character of the string is: %c""


With the expected output of ""H"". I substituted the last line for:

printf(""The first character of the string is: %c""

and got the same result. This makes sense to me as string and my_pointer are in essence the same pointer,,False,,t5_2r81y,False,,True
1344078051.0,xo102,Cellular automata source code,fiodorson,16,3,7,"Hi there. In advance

I'm fascinated by concept of [cellular automaton](http://en.wikipedia.org/wiki/Cellular_automaton) and I want to write my own little world with my rules and my creations ""living"" in it.

Did anyone of you tried to write something like this in C, I don't have anything to analize.

 [Game of Life](http://en.wikipedia.org/wiki/Conway's_Game_of_Life) is most popular example of cellular automaton.",,t5_2r81y,1344078463.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xo102/cellular_automata_source_code/
1337090375.0,to79d,Beginner Coding Program?,JonzoR82,20,3,10,"Hey guys.  I started reading through the Carl H. tutorials,False,
1317297764.0,kv6t9,PDF/Ereader version of lessons,disturbedfood,19,3,9,"Could this be possible? I would find it much more convenient to put the lessons on a Kindle to read them from there,False,
1316361334.0,kjkjj,Regarding Unit 7 Lesson 7.3 : Terminating strings of text and other data,Sogeking99,17,1,2,"First of all

Is this the part of the dreaded 'memory management' I've heard of from C? ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/kjkjj/regarding_unit_7_lesson_73_terminating_strings_of/
1310104744.0,ijse4,Is there anything to download?,Jiboomer,19,4,5,"I'm completely new to programming and I'd like to learn but I have no idea what I'm doing as of yet. I read up to the fifth lesson and I have no idea where to type in the C codes. Online it says I have to get a compiler which I did,False,
1366759565.0,1cyz38,Anyone have any idea what's going on with the website? It's been down most of the day...,ParticleSpinClass,16,1,2,"Confirmed by http://www.isup.me/

As a backup,False,,t5_2r81y,1366800503.0,,,t3_1cyz38
1352748379.0,132s2n,Question on transcripts,_HyDrAg_,15,1,4,Im thinking about starting to read the modified text transcript of the lessons and not watching the videos because its faster.  Will I miss anything or is it the same?,t5_2r81y,True
1315805521.0,kcsfl,Anyone got any exercises?,sayaendo,17,3,6,"I fully understand all the lessons but it's just impossible to memorize them all without exercises. I imagine there are others with a similar situation.

Nothing big is required,False,,t5_2r81y,True,,,t3_kcsfl
1364667822.0,1bbahn,Website really slow for anyone else?,EryHax,16,2,8,"Just wondering if it's happening to me or anyone else. Takes a good 10-30 seconds for me to navigate page to page.

The videos are wonderful though. Much better than my CS class.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1bbahn/website_really_slow_for_anyone_else/
1364337351.0,1b2le5,Trouble logging in or registering,Kaminaaaaa,14,3,5,"Before my laptop crashed, it just keeps going back to the homepage with the login. I gave up on logging in and tried to register,False
1354598338.0,148wul,Is Char / Int not stored?,bubblepopcity,16,4,5,"http://www.computerscienceforeveryone.com/Course_1/Unit_8/Lesson_3/

char myChar = 'a';

int myInt = 1;

From this lesson I learned the information is stored like this.

Variable Name  : Variable Value

1001 (myChar) : 0110 0001 ('a')

1010 (myInt)   : 0000 0001 (1)

Shouldn't there be a 3rd column to determine what type of variable this is? How does the computer know what type of variable is stored at that location?  In my head I see something like this.

Variable Type : Variable Name : Variable Value

0001 (char)   : 1001 (myChar) : 0110 0001 ('a')

0002 (int)     : 1010 (myInt)    : 0000 0001 (1)

So how does the computer know what type of variable it is?  Does it retrieve the 1's and 0's from the memory address

Someone on the other website asked this question and it seems like it takes months for a response so I figured I'd ask it over here. They also never got an answer because no one understood his question.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/148wul/is_char_int_not_stored/
1350262275.0,11hk93,Building a PHP MVC Web Application Framework - Session 1 - Q&amp;A,liveat60fps,15,1,0,"For those following Carl's series about building web applications

The recording of the first session (October 6th 2012) can be found [here](http://www.youtube.com/watch?v=3WdftjZepww).

Thanks to Carl for his hard work in presenting these sessions to us.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/11hk93/building_a_php_mvc_web_application_framework/
1332084544.0,r22uc,Any good text books dedicated to further knowledge about C programming after finishing all the lessons in the course?,mag1strate,16,5,6,I am starting unit two and want to continue afterwards. Do you guys know of any nice text books dedicated to advancing my knowledge in C?,t5_2r81y,True
1330634386.0,qdeen,Help with lesson 9.1 ,againer,15,4,3,"So I've been trying to to teach myself C and this tutorial is amazing ( thanks Carl). I finally feel like I'm really understanding everything well. While I've been ""practicing "" along side and understand the code I'm having trouble with lesson 9.1. I can understand the concept of changing variables by using pointer to reassign the original variable in the memory address. However when I actually run this code I keep getting the error of ""redefinition of *ptr"". Is this code just an exercise in understanding or is it meant to actually work?   

[Codepad](http://codepad.org/uqO7QNx5 )",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/qdeen/help_with_lesson_91/
1328206713.0,p7zfo,"During this lesson production halt, let's get some practice with exercises!",avp574,16,3,http://www.reddit.com/r/carlhprogramming/comments/p7zfo/during_this_lesson_production_halt_lets_get_some/

So

**Exercise 1:** Using a data structure

**Edit:** Here is my solution using [codepad](http://codepad.org/tivUws7R)",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/p7zfo/during_this_lesson_production_halt_lets_get_some/
1314486280.0,jwiez,"Unanswered question on lesson 42 (lesson 9.6: ""the char* pointer)",,15,1,13,"OK

You use the following code in this lesson:

    char *string;
    string = ""Hello Reddit!"";

Why isn't it

    char *string;
    *string = &amp;""Hello Reddit!""; 

Why are `*` and `&amp;` omitted? Don't we want the memory address that ""string"" points to (`*string`) to be assigned as the memory address where ""Hello Reddit!"" is (`&amp;""Hello Reddit!"")?

**edit:** I'm getting even more confused now. Take the meaning of `*` and `&amp;`

Now take this example from lesson 35:

    int total = 5;
    int *ptr = &amp;total;

Shouldn't it be:

    int total = 5;
    int ptr = &amp;total;

Because

I really don't understand the logic behind this piece of syntax... 

",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/jwiez/unanswered_question_on_lesson_42_lesson_96_the/
1354595479.0,148twy,Storing variables in RAM question,bubblepopcity,14,1,7,"http://www.computerscienceforeveryone.com/Course_1/Unit_8/Lesson_1/

In this lesson Carl explains that if you had 16 bytes of ram

unsigned short int total = 5

would get placed into 1 of the random 16 memory addresses in Ram.

Example.

Random memory address number 8 was chosen.

1000 (or total) = 0000 0101 (or 5).

My question.  Is it is possible to store less then a byte of information into a memory address like RAM or your hard drive

Example.  If I had 2 variables total = 5 and newtotal = 6. (lets assume they are unsigned short int they take half a byte

1000 (total,,False,,t5_2r81y,1354595877.0,,True
1352337478.0,12ty9h,help with my array coding (from lesson 16),muffinman007,13,1,5,,t5_2r81y,False
1351077392.0,1200vw,Question on Arrays,Nooobish,13,2,11,"I mistakenly offset each of the arrays incrementally by one in [this](http://codepad.org/ISOM79hT) practice code when I should have formatted it [this](http://codepad.org/kYQ2waJB) way.  
I can't quite grasp what the memory did in order to output: Name is:MoeMZwoeMT  
I realize that the sequence is M for first_letter
But I can't quite grasp how the machine produced this.  
Here's how I'm initially thinking thorough [this](http://codepad.org/JYnqdGaR).  
I realize I'm thinking this through wrong but I'd love to be corrected and shown the right way.
",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1200vw/question_on_arrays/
1347735908.0,zxql8,2 questions about this tutorial in regards to game development,ThEwOtSiT182,13,1,2,"So

1: Should I complete Course 2 as well(is the content necessary or more specialist)?

2: After completing these tutorials

Thanks in advance.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/zxql8/2_questions_about_this_tutorial_in_regards_to/
1342547995.0,wpnkl,Unit 11.9 question: how if statement stops another if statement from happening,,14,1,8,"	#include &lt;stdio.h&gt;
		int is_this(char);
	
	int main(void) {
   		 char my_precious = 'r';
    
    if(is_this(my_precious)) {
		printf(""It's my precioussss!"");				// &lt;----  from printing ""It's my preciousss!""?
 	   }												//	|
  	  return 0;											//	|
	}													//	|
	int is_this(char my_precious) { // How does this stop 	|
	    if (my_precious &amp; 0x20) {
        	return 1;
    	}
    	 return 0;		
	}

~~I hope I got the formatting right, it formatted correctly on first try.

Anyway,,False,,t5_2r81y,False,,True
1311539277.0,iykul,Question on Flags,DangerDanThePantless,17,6,7,"**The next reason you should know binary involves understanding something called ""flags"". Flags are representations in binary of several true/false states of something. Lets say for example you are designing a game

You can do this with a single byte! Eight bits. Each position can represent a given weapon. 1 = yes you have it

0100 = (0 in the ""plasma cannon"" place, and 0 in the ""knife"" place).

Adding a weapon to inventory


So it would look like 1100 to show you have the plasma cannon and the shot gun right? ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/iykul/question_on_flags/
1375648336.0,1jp4rd,Any exercises?,alon99,13,2,3,"Hi carl
first i wanna say that your lessons are AMAZING!
i have no background in computing

my question is: where can i find low level exercises to practice what i learn? i'm actually looking for ""home work"" i can do to improve my learning (right now all i can do is to repeat the lessons..)

i'm at class 1

thanks for everything and keep up with your good work",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1jp4rd/any_exercises/
1363266737.0,1aa5yx,Download of videos?,Element0f0ne,16,4,4,"I know there are ways to download and save YouTube videos, or some other way to download all the videos at once,
1358993308.0,175wj2,How do you send a User Submitted Variable to a Function?,Captain_Fuzzyboots,12,0,4,"So i was doing a little bit of practice with an Interactive version of the code asdf12321asdf helped me with :)
My function and everything else(according to  me doesnt lack a thing to not do the conversion from characters to binary).I just cant send the user submitted variable to my function
Since i do not know how to put code into reddit without having  it all on the same line
here is the link : http://codepad.org/8MIEZVGZ
Link to previous question(the one which asdf12321asdf helped me with) : http://www.reddit.com/r/carlhprogramming/comments/174yp3/some_wierd_results_i_get/

Also could you as a secondary Q tell me how to write code without  changing the layout of your lines?
Thanks a lot :) ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/175wj2/how_do_you_send_a_user_submitted_variable_to_a/
1331965515.0,r0jpm,Practicing basics,Zyrth,12,3,5,"I've been around programming and computers forever

I decided to try to make a program that would ask for a number of variables



http://codepad.org/BijxQN9f

Theres the results


I'm proud of myself and just wanted to share :D any comments on things i could have done easier or differently are welcome

",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/r0jpm/practicing_basics/
1327938751.0,p33cg,Anyone have a doc and/or pdf of course 2?,avp574,16,3,3,"I've been working through these courses on my commute

Has anyone done the same for course 2?

**EDIT:** I'm willing to make the files, but I have no idea how to make a pdf searchable (or is that done automatically when you publish a word file to pdf? I'll have to test that out later).",,False,,t5_2r81y,True,,
1315716258.0,kbsiu,Does anybody else hear that...?,lordloss,36,25,10,"Its the sound of crickets since this place hasn't been updated in awhile. I was excited to start doing these lessons only to find out that they stop abruptly? These are good lessons,,
1364108429.0,1awkd0,"I'm having difficulty understanding why certain arguments for a ""while"" loop create an infinite loop.",,14,4,8,"The code:  http://codepad.org/8UKyYTC3  (See comments)

The program takes a string of text and capitalizes all of the letters using a ""while"" loop that is ""jumped over"" when a positive comparison is made to an already capitalized string. 

When I try to use the array that I created for the comparison text in the ""while"" loop argument

Any help with understanding why my code works like this (and wont work with the other argument) would be appreciated. ",,t5_2r81y,1364108701.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/1awkd0/im_having_difficulty_understanding_why_certain/
1354482096.0,145z71,"If signed int is the same as int , why does C have signed int.",the_barbarian_jedi,13,2,http://www.reddit.com/r/carlhprogramming/comments/145z71/if_signed_int_is_the_same_as_int_why_does_c_have/,,
1352283479.0,12shc7,Question on pointers,Numbafive,14,6,9,"So if we have this [this code](http://codepad.org/vtqPQui9).  
What I'm getting confused about is the fact that:  
    printf(""%s\n""
is returning Hello as an output.  
Doesn't the data stored at pointer contain the address of ""Hello"". So shouldn't whatever is contained at pointer be equal to the address of what the start of the string ""Hello"" be? In other words shouldn't:
    printf(""%s\n""
be outputting the address itself instead of the string contained within the address where the output of:  
    printf(""%s\n"",,False,,t5_2r81y,False,,True
1343513242.0,xbcxq,Some difficulty understanding a user submitted code on lesson 1.8.7,WeiZhiqiang,10,1,5,"I like to open most people's submitted codes in the comments and read through to see if I can follow along. I was perusing http://codepad.org/I4xGlPu8 and I didn't quite get it. 

As far as I can tell the program starts with the variable 'a' which is given a decimal value that translates to the binary value of the character 'l'

The program next adds 2 (why not just start with 'a' 2 higher?), and why does adding or subtracting 1 to ptr change the letter by more than one place?

If someone could walk me through the first block of letters it would be greatly appreciated.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/xbcxq/some_difficulty_understanding_a_user_submitted/
1372432925.0,1h93ge,Does anyone know what the deal is with registering?,yowzah,14,6,7,"I've been unable to register at the site,,
1365724742.0,1c66wo,Lesson 2 videos?,EryHax,9,2,2,I see they aren't on the site. Will there ever be lesson 2 videos?,t5_2r81y,True
1364348916.0,1b30rz,What programming language should I use to accomplish this?,Elchobacabra,11,3,14,"Please ELI5

Here's some quick back story to help explain what I'm trying to accomplish.

So I work as an intern at a high end computer training facility that is very well know and radda radda but I'm just an intern....to the operations department which is basically just being a secretary (not saying its bad to be a secretary

Recently

Which are:
(1) going onto ""Website A"" and cross checking the information to make sure it matches up with ""Website B"" none of it is hard and any monkey can do it

(2) I am in charge of making the certificates for the people who take some of our classes and attend them and mail it to them. what I want to do is

What program should I download and where can I start learning how to make a program that can do that for me


Thank you to whoever read that huge wall of text!

http://www.youtube.com/watch?v=Blxv5ZGOkf4

so heres a koala being adorable",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1b30rz/what_programming_language_should_i_use_to/
1349033015.0,10q0gh,Any guides on working with files in C? ,Opia,11,4,2,"I completed the first course recently

 Does Carl cover this in course #2? Or does anyone have a good guide on this subject? ",,t5_2r81y,1349033553.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/10q0gh/any_guides_on_working_with_files_in_c/
1344444913.0,xw06h,1.12.6 &amp; vs &amp;&amp;,WeiZhiqiang,10,1,4,"You mention at the end of the video that &amp; should not be confused with &amp;&amp;,,False
1342807963.0,wvvgs,Lesson 122 / 4.8 question: Why won't this display the winner properly?,AppleGuySnake,10,0,0,"EDIT: SOLVED.  I'm an idiot

""I always forget some mundane detail!"" - Michael Bolton

It displays the board in a winning position

http://codepad.org/Ut4x0ttb",,t5_2r81y,1342809188.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/wvvgs/lesson_122_48_question_why_wont_this_display_the/
1331622290.0,qu8ro,Question regarding pointers,wwjd_for_a_klondike,13,3,3,when I was working on a code for pointers I was attempting to write something that would show the Peter Piper poem. This was basically my [code](http://codepad.org/6EzmiW2b) are char variables limited to only a single character as a value?,t5_2r81y,True
1365797591.0,1c8834,Lesson 12.6: test_character?,Llourn,8,1,4,"Hey guys

Now the question is

How does:
if(test_character &amp; 0x20) determine if the letter if lower-case if there's no value inside of the variable test_character?

This might be a stupid question

(here's a link to the lesson if you want to take a look http://www.computerscienceforeveryone.com/Course_1/Unit_12/Lesson_6/  the code is shown at about 12min 30sec. )",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1c8834/lesson_126_test_character/
1345052243.0,y9rtu,How do programs like Babelfish work?,Rude_Man_Who_Shushes,13,7,10,"You input text

How would one develop an app like this on their own? What are the drivers behind the technology?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/y9rtu/how_do_programs_like_babelfish_work/
1328142193.0,p6x3j,Practicing basics. Why won't my code work? [x-post from r/learnprogramming],avp574,9,1,0,,t5_2r81y,False
1364665546.0,1bb81h,A question about programming.,tehgreatist,11,3,10,"Hi carl (and anyone else reading).

I am a 24 year old american guy with an associates degree in a field I'm not so sure I'm enjoying anymore. I've liked computers since I was a kid

I'm in the process of soul searching for a new career.  I think programming might be a good fit for me, but you seem like a good guy to ask.  It's not that I will never have a passion for it, but I want to be realistic and straightforward with my intentions of actually making a career out of this, if this is the path I choose to go down.  I'm aware that I may have to go back to school for this, and I am ok with that.

What is the world out there like for the average programmer? How much money can they expect to make?  Is the job in demand?  Do you think it will continue to be in demand?  How big is the possibility of going to school and learning one ""language"" and then a year or two later

Thank you for your time.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1bb81h/a_question_about_programming/
1353982968.0,13ulbn,Should I try out this program?,AjaXstarcraft,13,6,5,Hello! Do you think that this is a good program? I am not necessarily looking to become a programmer but just want to try something new!  ,t5_2r81y,True
1353321524.0,13g1sv,Question on Course 2 Unit 2.3 Arrays of pointers.,Numbafive,8,2,16,"I've been going through Course 2 Unit 2.3 and in it Carl is discussing about a pointer that is pointing to an array of pointers that are in turn pointing to int values. Or so I understand.  

Anyways about halfway though he says:  
&gt;We are assuming in this lesson that a pointer is 4 bytes in size.  
  
Why are we assuming that a pointer is 4 bytes in size?

Isn't a pointer simply an address?

So wouldn't a pointer pointing to a pointer that is in turn pointing to an int be one byte (since it will contain the address of the pointer pointing to the int) and wouldn't the pointer pointing to the int also be one byte since all it contains is the address of the int?

So to better illustrate this:

pointer_1 (1 byte containing address of pointer_2) ---&gt; pointer_2 (1 byte containing address of int) ---&gt; int (4 bytes).  

And wouldn't pointer_2 be pointing to the first byte of the 4 total bytes of int?  

As an aside i have a minor thing to clear up. When Carl says:
&gt;     (int *) *pointer  
What does this mean? It means ""create a pointer called *pointer"". Of the data type ""pointer to int"".   
 
So would it be absolutely correct to say that when we create a normal pointer as in:  

    int *pointer  
this means: ""create a pointer called pointer,False,,t5_2r81y,False,,,t3_13g1sv
1351402580.0,127ir9,A question that i'm not sure was ever covered in the lessons. It involves libraries and the MinGW.,OddManDoes,10,5,12,"So I was working on a project that needs to make use of the OpenSSL/MD5.h libraries or a library that serves the same function. The issue is these libraries were made for Linux. As far as I can tell after some google work was that because of the MinGW I can add them as libraries I can use in my regular codeblocks compiler. The problem is I have no clue how to do that and because of my limited knowledge of jargon I don't know how to parse my question in such a way that google can return useful results. 

How can I add these things as libraries? Or am I just totally missing something and there's an easier way to go about this? 

EDIT: Also I forgot to mention that the platform i'm developing this on is Windows.


 
Edit 2: Since I want to be as clear as possible i'm trying to make a simple program that gives the MD5 hash of a fiile. I've found lots of implementations so there's no shortage of examples to follow and learn from. I found this snippet of code on stackoverflow. [Link to the code itself.](http://stackoverflow.com/questions/10324611/how-to-calculate-the-md5-hash-of-a-large-file-in-c)

    

",,t5_2r81y,1351461927.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/127ir9/a_question_that_im_not_sure_was_ever_covered_in/
1346338827.0,z2vj0,Quick question about changing a value with a pointer,glassia,9,2,12,"http://codepad.org/RYfwKOm7

why doesn't the above code return 6?

 It may be a nooby question but I cant get it to change to 6

but that isn't convenient because I need to do further functions on int i before i output the result on the screen. Any help will be grateful. Thanks. ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/z2vj0/quick_question_about_changing_a_value_with_a/
1346187531.0,yzcw9,"Problem with Course 2, Unit 1, Lesson 8",mag1strate,9,3

""You can however return large data structures (arrays, a memory address, will fit into the EAX register just fine.""

Thank You!",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/yzcw9/problem_with_course_2_unit_1_lesson_8/
1345648977.0,yn36d,Question about pointers 1.8.7,Mendo92,13,4,2,"I'm having some difficulty wrapping my head around pointers. I apologize in advance for the wordiness and length

Correct me if I am wrong, for example, in the lesson when the code is:

    int total = 5;
    int *ptr = &amp;total;

Everything makes sense to me. However

SO: If you had a variable that you knew would take up more than one byte (for example in a previous lesson we used 50

Essentially would the pointer ""understand"" the length of the variables stored in it? ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/yn36d/question_about_pointers_187/
1344462899.0,xwl36,Problems with implementing OO Deck/Cards in C++,brogrammer7,8,1,3,"I'm trying to learn OO in C++ and as an exercise I tried to implement a deck of cards.  I was able to create a Deck object made up of Card objects and shuffle it

Am I going about things the wrong way?  I've done this many times in Java/Python but I've never done C++ before.

Code+Errors:
http://pastebin.com/F4z18yji

Thanks for any help or advice.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/xwl36/problems_with_implementing_oo_deckcards_in_c/
1364045642.0,1auvqq,code blocks,thenetworka,7,1,2,Which code block software should I download for this course?,t5_2r81y,True
1358968182.0,174yp3,Some Wierd Results I get...,Captain_Fuzzyboots,8,3,2,"So I was making the ""representing data in binary"" program and it worked
See that 0 was shifted!!
Could you please explain why?
Thanks :)
My code is below
                           #include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int main()
{
                 
                    char my_char='a';

                       /* 'a'= 0110 0001 */

                 int i;  //looping variable

             unsigned char bitmask=0b1000000;

        for(i=0;i&lt;8;i++)
        {

        if(my_char &amp; bitmask)
        {
            printf(""1"");
        }
        else
        {
            printf(""0"");
        }
        bitmask=bitmask/2;
        if(i==3)
        {
            printf("" "");
        }
        }
    return 0;
}


",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/174yp3/some_wierd_results_i_get/
1355768071.0,150577,Programming question Chapter 12,bubblepopcity,8,2,14,"I just finished chapter 12 of Carl's course

http://codepad.org/yijteDfO

Problem:  I tried to create a variable to hold a binary digit

Thanks in advance

_

_

Edit: http://codepad.org/Aankn09R   It looks like I found my answer.  I was trying to print the value of the equation which I expected to be a 1 or a 0

Edit2:  Fixed my original code - http://codepad.org/sY6zJpHd

Edit3: Final code - http://codepad.org/QKOkJN0m

Alright I'm done with my review.  I'm still kinda confused on how functions work so I hope we learn about them more in the future.  In my code I didn't need myPointer to return any value back to my main function,,False,,t5_2r81y,1356034562.0,,True
1353910532.0,13su62,This Fails to Execute. Who Has the Nous Tell Me Why?,herpderpherpderpderp,11,5,4,"First ever post on reddit so forgive me if I do something full of fail.
In ""introducing bit masking"" lesson

http://codepad.org/pzT1Fr5Q

It fails. I can't for the life of me work out why and would appreciate any insight anyone has to offer.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/13su62/this_fails_to_execute_who_has_the_nous_tell_me_why/
1344500979.0,xxixg,Question on ,Numbathree,10,5,3,"I have this simple bit of code [here](http://codepad.org/ES3X3zp2) that I can't quite get my head around.  
I'll try and explain how I'm looking at it:  
`char m = 'l';`  
I'm saying that I'm introducing a character 'm' that is equal in value to the character 'l'. So from now on it's as if the character 'l' does not exist.  
`int n = m;`  
I'm saying that I'm introducing an integer 'n' that is equal in value to the character 'm'. Or is it the opposite?  Where I'm introducing a character 'n' that is equal in value to the integer 'm'?  
Also
I realize that's it's to do with the fact that the character 'l' in binary is 0110 1010 which equals 108 in decimal but I'm still confused.


",,t5_2r81y,1344501190.0,,,True,http://www.reddit.com/r/carlhprogramming/comments/xxixg/question_on/
1344159690.0,xpkbp,Help! Unable to access codepad.org links.,Numbathree,10,3,3,"For the past few days since I started course 1
Is the site down or is it just me?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/xpkbp/help_unable_to_access_codepadorg_links/
1332190313.0,r3zko,Help using typedef in a custom funtion.,3Jane_goes_to_Earth,7,1,4,"I'm trying to write a custom funtion that uses a data type I defined as per the last lesson of Carl's first course

I'm also not sure if I'm defining the function quite corectly because the example in the custom funtions lesson does not take arguments.

Here is the [code](http://codepad.org/culowKkg)

Thanks in advance!",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/r3zko/help_using_typedef_in_a_custom_funtion/
1328931589.0,pkcfi,Help with another piece of code I have please?,xxrepresent,10,4,5,"I've written this in C: http://codepad.org/qBRAwsbH

It compiles correctly. The problem I am having is finding a way to store data that all functions would be able to use. I thought that by using a structure I can store information in them

Any fix or ideas?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/pkcfi/help_with_another_piece_of_code_i_have_please/
1366354588.0,1cnzyb,Question about array and pointers.,lumpygrumpy,7,1,12,"Hi everyone

I'm up to lesson 10.5~10.6 where pointers are used to manipulate character arrays.

Example code:
int main(void) {
    char string[] = ""Hello Reddit"";

    char *pointer = string;
    *pointer = 'h';
    pointer = pointer + 1;

    *pointer = 'E';

    printf(""%s""
    return 0;
}

I understand why that prints hEllo Reddit. Why wouldn't the following work as well?

int main(void) {
    char string[] = ""Hello Reddit"";

    *string = 'h';
    string = string + 1;
    *string = 'E';

    printf(""%s""
    return 0;
}

Isn't string a pointer to the start of ""Hello Reddit"" anyway? And also why can't you use string = string + 1 like in the working example?

Thanks!",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1cnzyb/question_about_array_and_pointers/
1361369433.0,18vwiw,Strings are constants yet they point to the same memory address,gyaani_guy,6,1,3,"    int main(void){
        char* red = ""Hello Reddit"" ;
        printf(""%d""
        red = ""digg"" ;
        printf(""%d""
        return 0 ;
    }

In the above the value of &amp;red printed is same. But shouldn't it be different considering that ""hellow reddit"" and ""digg"" are string literals and hence should be placed in different places in memory ?? Here it seems they are being overwritten.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/18vwiw/strings_are_constants_yet_they_point_to_the_same/
1354505376.0,146kcv,Void and Return Questions,bubblepopcity,8,1,9,"1.  Why do you need void and return? What purpose do they serve. I tried changing both of these and the program seems to work just fine.
http://codepad.org/stqP37AY

2.  I'm confused with the return 0 and return 1. Will both cases return
control to the operating system(like Carl says it is used for), what is the advantage to getting this correct? 

Another way to ask this.  How does your program act differently if returns 0 or returns 1.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/146kcv/void_and_return_questions/
1354446366.0,145b89,Question on Pointer Arrays and Casting.,Numbafive,5,1,2,"So in [Course 2 Unit 2.6](http://www.computerscienceforeveryone.com/Course_2/Unit_2/Lesson_6/) Carl goes on to explain casting and having an array of layered pointers.  
Anyways
First
&gt;    
    malloc(2 * sizeof( int* ) )  
  
Why is the size int* and not simply int
Isn't it simply a way to tell the program to treat whatever comes after it as an int regardless of what original value type it holds?  
  
Second
&gt;     int **two_star_pointer = malloc(2 * sizeof( int * ) );  
  
Why does he then go on to say:  
&gt;We need something that can point to a one star int. That means
  
Why can't we have another normal one star pointer pointing to the other one star pointer?  
Can someone help out here?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/145b89/question_on_pointer_arrays_and_casting/
1328388303.0,pazux,Help: Calling a Constructor Function,xxrepresent,9,4,9,"In lesson 1.3 in the second course

I assume it would like something like this: http://codepad.org/bnZx3VSg but so far any experimentation has failed.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/pazux/help_calling_a_constructor_function/
1318468550.0,la9m6,Difference between different versions of .NET?,,12,8,4,"I was wondering what are the main difference between versions of the .NET framework. My PC has 3.5 and 4.0 and thought if I had 4.0 than 3.5 would have been upgraded. 

I thought that different framework versions had specific classes but sometimes I google a class and find it in more than one version. So why is it sometimes I need to have a specific framework as a prerequisite when installing software?",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/la9m6/difference_between_different_versions_of_net/
1367266924.0,1dczuf,finished the whole course?,thenetworka,4,1,7,Anyone here finished the whole course and created a program themselves?,t5_2r81y,True
1364692489.0,1bc0xc,No explanation of %d,EryHax,10,5,12,"7.2 is pretty clear

No clue what it does. Can someone let me know?

Honestly,False,,t5_2r81y,1364692670.0,,,t3_1bc0xc
1357845365.0,16bv05,Is there any way I can access the entire Carlh website offline easily?,makerender,6,1,5,I'm enjoying the classes and want to keep going but I don't always have internet access. Can I save the whole site using my browser somehow?,t5_2r81y,True
1345545255.0,ykoxt,"[CarlHProgramming] Course #1, Lesson 13.2 Video Lesson now Published (Introducing FOR Loop in C)",CarlH,6,2,http://www.reddit.com/r/carlhprogramming/comments/ykoxt/carlhprogramming_course_1_lesson_132_video_lesson/,,
1341959250.0,wcp36,Why is this so unlike other resources I have found?,sw1sh,5,3,5,"So I have recently started down the road of becoming a programmer(yippe!) and my initial path was down the Java road. I spent a 2 months learning a lot of the basics of programming (control statements/program flow etc) through Java but have been offered an opportunity for future work with my dad's friend if I can change to C. 

So over the past few days I have been looking for resources online to learn C and keep hearing about ""The C Programming Language"" as the go-to C resource. I have been looking at it,but then I heard about this with an interactive reddit site and thought it would be perfect. I thought with my previous programming knowledge I would already have a decent grasp of the basics and it would only be a matter of syntax for the first while as I studied the C basics. How wrong I was.

I found my mind blown by all the binary information

 I just found it wayyyy too confusing and lacking in depth of actual code examples. Maybe others have been more successful with this way of learning,unless someone else can tell me what the advantages of this method are? Or would I be suited to learning a different way?

TLDR; Basic programming skills acquired from Java,False,,t5_2r81y,False,,,t3_wcp36
1360599628.0,18bbwi,I'm currently standing on step 0 of learning programming. What is step 1?,jwojo13,6,4,1,I have no clue. I'm sitting in front of a computer. I don't know anything. How do I begin?,t5_2r81y,True
1366876909.0,1d2kxn,I cannot login to the website with my username and password.,metalreflectslime,4,3,1,What is going on?,t5_2r81y,True
1353084999.0,13b09k,need help with scanf,muffinman007,1,0,6,"I'm reading ""C How to Program"" by Dietel, line 20
When I ran it on my machine

Thank.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/13b09k/need_help_with_scanf/
1335754129.0,sz4rq,Question regarding pointers and using one to change a string,captpiggard,2,1,2,"After finishing Unit 10

[Here's my code](http://codepad.org/TOSAjs3U),False,,t5_2r81y,False,,,t3_sz4rq
1368285034.0,1e4pot,hello. how can i write the NULL charactor ? for example if i work with 3d array. in code bolcks. i dont know how to do the null charactor.,d2idan,2,2,2,,t5_2r81y,True
1366425983.0,1cpwoo,"Hi, all I'm asking is for some help with CMD (I now, lame.)",jigglefish,1,0
@echo off
title Freeman

:Logo
cls
color 0a
cls
echo.
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. 
echo. :Zabawa Inc.:
echo. 
echo. 
echo. :2013:
echo. 
echo. 
pause
goto Start

:Start
cls
echo To begin
set/p NAME=

:1
cls
echo Welcome
echo.
echo.
echo You have been working at the Zawsze
echo coal mine for 12 years. Your father used to 
echo mine here too
echo two years ago in February. Your mother
echo was killed in a freak knitting accident
echo so all you have left is your little brother
echo and your uncle
echo in a small shack a few miles away from the
echo mine. The co-workers name is Gordon.
echo.
echo.
pause
goto 2

:2
cls
echo Life at the mine is excruciating. Beans
echo and lentils everyday. But you have a plan.
echo There is a river about 5 miles down a dirt path 
echo that further connects to the Woda River. It's
echo a small river
echo Freedom. Down stream
echo River dumps into the Szybko Sea. According to 
echo a map you found back on the cave
echo a small city near the coast called Bardzo Dobre.
echo.
echo.
echo This is all you know. This is your quest to become a 
echo free man.  
pause
goto 3

:3
cls
echo. 
echo. 
echo. Mine
echo. 
echo. 
echo. X
echo. House
echo. 
echo. 
echo. 
echo. 
echo. G
echo. a
echo. t
echo. e
echo. 
echo. 
echo. 
echo. Forest
echo. 
echo. 
echo. 
echo. 
echo X= %NAME%
echo W=Up    A=Left
echo S=Down  D=Right
echo O=Objectives
echo Q=Quit
choice /c wasdopq &gt;nul
if %errorlevel%==w goto 4
if %errorlevel%==a goto 5
if %errorlevel%==s goto 3
if %errorlevel%==d goto 6
if %errorlevel%==o goto noobjectives
if %errorlevel%==q goto quit

:quit
cls
echo Are you sure you want to quit?
echo           (Y/N)
choice /c yn &gt;nul
if %errorlevel%==y goto nothing
if %errorlevel%==n goto 3

:noobjectives
cls
echo There are currently no objectives.

:4
cls
echo. 
echo. 
echo. Mine
echo. 
echo. X
echo. 
echo. House
echo. 
echo. 
echo. 
echo. 
echo. G
echo. a
echo. t
echo. e
echo. 
echo. 
echo. 
echo. Forest
echo. 
echo. 
echo. 
echo. 
echo X= %NAME%
echo W=Up    A=Left
echo S=Down  D=Right
echo O=Objectives
echo Q=Quit
choice /c wasdopq &gt;nul
if %errorlevel%==w goto 4
if %errorlevel%==a goto 5
if %errorlevel%==s goto 3
if %errorlevel%==d goto 6
if %errorlevel%==o goto noobjectives
if %errorlevel%==q goto quit
pause

If you try to run and play it it bugs out on the first map part after the introduction. Does anyone know how to fix this?

Edit: Sorry it is formatted wrong.",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1cpwoo/hi_all_im_asking_is_for_some_help_with_cmd_i_now/
1364392754.0,1b3yfw,Hello,jbarlow1,8,10,0,"Hi My name is josh im new to programming but its something ive wanted to do for a few years. i thought your vidoe on Binary was amazing i picked it up really fast. i just thought i would introduce myself and let everyone know how im getting on 

Thanks Carl ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/1b3yfw/hello/
1361287764.0,18tkoa,Grown man Want's to learn.,antares076,1,1,0,"I Used to be a PASCAL Programmer, im being serious and will follow every step, help out. "
1354507914.0,146mky,Float number question,bubblepopcity,1,1,7,"Lets say a short int is 4 bits.  I'm assuming the highest value for my int would be 7 because the first bit is reserved to show if it's a positive or negative value. I'm going to use '-' to demonstrate the reserved part. You can have either 0-111 or 1-111.  Now lets say we have a float that is 8 bits.  That same first bit needs to be reserved for positive or negative.   Do float numbers have some type of priority of whole numbers over decimal numbers or vise versa?  Or are a certain number of bits reserved for the whole number and a certain number reserved for the decimal part of it. I will use '.' for the reserving demonstration.

Example: If I assigned a floating type number that had 8 bits would it reserve bits for certain numbers like this 0-000.0000? As in my whole number part can only reach a certain value(in this case 7).  

Lets say you tried to store 16.9999 into a float value.

The correct binary would look something like this.  0-10000.11111111. But the floating number can only take 8 bits.  So would it prioritize the whole number and look like this?  0-10000.11  (01000011).  Or does it reserve a certain amount of space for the whole number/decimal number and it would cut parts off and look like this?  0-000.1111 (00001111).",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/146mky/float_number_question/
1351653990.0,12doq0,sup carl? music programs? ,theavenger7,4,4,7,"hey,False,
1331973541.0,r0mpv,Mistake in lesson 4.2,justforsaving,1,1,0,"Paragraph 3: ""Everything we talked about in lesson 11 involved a...""

The readers have not yet read lesson 11. ",,t5_2r81y,False,,,True,http://www.reddit.com/r/carlhprogramming/comments/r0mpv/mistake_in_lesson_42/
1326328480.0,od5mh,Is this good for learning C# too?,healxph0enix,2,2,1,"Topic.  I am halfway through c# tutorial

Edit:  Erased unnecessary info:)",,t5_2r81y,True,,,True,http://www.reddit.com/r/carlhprogramming/comments/od5mh/is_this_good_for_learning_c_too/
1324594007.0,nn6rs,I'm working through lesson 59 and I broke it.,soonerguy9782,2,2,3,Here is my [code](http://codepad.org/ZHHNEF0Y) in codepad.  I keep getting a segmentation fault but I've checked several times and my code matches Carl's almost exactly.  I'm totally lost on why this isn't working except that I'm sure it's something stupidly small.  Thanks. :-),t5_2r81y,True
1317873767.0,l2mz8,Can someone help me search through a few text files?,cherner,1,1,2,"Here's the problem: I've got two text files with some content. One file is larger than the other. The larger file has all of the IDs

My problem is that I'm convinced the two separate text files have different binary encoding, that's why I chose this method. But I need a different method, because this isn't working.

Does anyone have any ideas of the best way to do this? The files are located: 
[https://docs.google.com/leaf?id=0BwVWBUxgNYdxM2VkYmY4NWEtNzU3Ni00Y2JhLTg0MjEtNmI3MGRiNDc2YThm&amp;hl=en_US&amp;authkey=CKGg2ugG](https://docs.google.com/leaf?id=0BwVWBUxgNYdxM2VkYmY4NWEtNzU3Ni00Y2JhLTg0MjEtNmI3MGRiNDc2YThm&amp;hl=en_US&amp;authkey=CKGg2ugG)

[https://docs.google.com/leaf?id=0BwVWBUxgNYdxZTRjMmRjMWQtNjhkZi00ODZiLTg3NzMtZTczNjg4NWNhMzk0&amp;hl=en_US&amp;authkey=CLjU-a8I](https://docs.google.com/leaf?id=0BwVWBUxgNYdxZTRjMmRjMWQtNjhkZi00ODZiLTg3NzMtZTczNjg4NWNhMzk0&amp;hl=en_US&amp;authkey=CLjU-a8I)

This should be pretty simple,False,,t5_2r81y,False,,,t3_l2mz8
1364603124.0,1b9xs9,hello. thid video lessons about programming helped me a lot . why there're no videos from lessons 16 or 17 ?,d2idan,1,2,2,,t5_2r81y,True
